nat : type.
succ : nat -> nat.
0 : nat.
1 = succ 0.
2 = succ 1.
3 = succ 2.
4 = succ 3.
5 = succ 4.
6 = succ 5.
7 = succ 6.
8 = succ 7.
9 = succ 8.

plus : nat -> nat -> nat -> type.
plus/z : plus 0 N N.
plus/s : plus N M P -> plus (succ N) M (succ P).

natList : type.
cons : nat -> natList -> natList.
nil : natList.

l1 = cons 1 (cons 2 (cons 3 nil)).


append : natList -> natList -> natList -> type.
append/base : append Xs nil Xs.
append/rec : append Xs Ys Zs -> append Xs (cons X Ys) (cons X Zs).
%mode append +Xs +Ys -Zs.
%query 1 1 append (cons 1 (cons 2 nil)) l1 Zs.

% append (cons 1 (cons 2 nil) nil (cons 1 (cons 2 nil))
% if append (cons 1 (cons 2 nil) nil (cons 1 (cons 2 nil) -> append (cons 1 (cons 2 nil) cons 3 nil (cons 3 append (cons 1 (cons 2 nil)


% Jessica Sensei's exercises

rev : natList -> natList -> type.
rev/base : rev nil nil.
rev/rec : append (cons X nil) Ys Res -> rev Xs Ys -> rev (cons X Xs) Res.
%query 1 1 rev (cons 1 (cons 2 (cons 3 nil))) Res.

contains : nat -> natList -> type.
contains/base : contains X (cons X _).
contains/rec : contains X Xs -> contains X (cons _ Xs).
%mode contains +X +Xs.
%query 1 1 contains 2 (cons 1 (cons 2 (cons 3 nil))).
%query 0 1 contains 3 (cons 1 nil).

eq : nat -> nat -> type.
eq/base : contains X (cons Y nil) -> eq X Y.

lt : nat -> nat -> type.
lt/base : lt 0 (succ _).
lt/rec : lt X Y -> lt (succ X) (succ Y).
%mode lt +X +Y.

gt : nat -> nat -> type.
gt/base : gt (succ _) 0.
gt/rec : gt X Y -> gt (succ X) (succ Y).
%mode gt +X +Y.

neq : nat -> nat -> type.
neq/lt : lt X Y -> neq X Y.
neq/gt : gt X Y -> neq X Y.
%mode neq +X +Y.

notContains : nat -> natList -> type.
notContains/base : notContains X nil.
notContains/rec : notContains X Xs -> neq X Y -> notContains X (cons Y Xs).
%mode notContains +X +Xs.
%query 1 1 notContains 1 (cons 2 (cons 3 (cons 4 nil))).

isEven : nat -> type.
isEven/base : isEven 0.
isEven/rec : isEven N -> isEven (succ (succ N)).
%mode isEven +N.
%query 1 1 isEven 4.
%query 0 1 isEven 3.

isOdd : nat -> type.
isOdd/unique : isEven N -> isOdd (succ N).
%mode isOdd +N.
%query 1 1 isOdd 5.

filterEven : natList -> natList -> type.
filterEven/base : filterEven nil nil.
filterEven/baseEven : isEven X -> filterEven (cons X nil) (cons X nil).
filterEven/baseOdd : isOdd X -> filterEven (cons X nil) nil.
filterEven/even : filterEven Xs Ys -> isEven Y -> filterEven (cons Y Xs) (cons Y Ys).
filterEven/odd : filterEven Xs Ys -> isOdd Y -> filterEven (cons Y Xs) Xs.
%mode filterEven +Xs -Ys.
%query 1 1 filterEven (cons 1 (cons 2 (cons 3 (cons 4 nil)))) Ys.

asSet : natList -> natList -> type.
asSet/base : asSet nil nil.
asSet/Base2 : asSet (cons X nil) (cons X nil).
asSet/RecContains : asSet Xs Ys -> notContains X Xs -> asSet (cons X Xs) (cons X Ys).
asSet/RecNotContains : asSet Xs Ys -> contains X Xs -> asSet (cons X Xs) Ys.
%mode asSet +Xs -Ys.
%query 1 1 asSet (cons 1 (cons 1 (cons 2 (cons 2 (cons 2(cons 3 (cons 3 nil))))))) Res.

removeAll : nat -> natList -> natList -> type.
removeAll/base : removeAll X (cons X nil) nil.
removeAll/baseNil : removeAll X nil nil.
removeAll/rec : removeAll X Xs Ys -> removeAll X (cons X Xs) Ys.
removeAll/recNeq : removeAll X Xs Ys -> neq X Y -> removeAll X (cons Y Xs) (cons Y Ys).
%mode removeAll +X +Xs -Ys.
%query 1 1 removeAll 1 (cons 2 (cons 1 (cons 2 (cons 1 (cons 1 nil))))) Res.

removeFirst : nat -> natList -> natList -> type.
removeFirst/base : removeFirst X (cons X Xs) Xs.
removeFirst/rec : removeFirst X Xs Ys -> removeFirst X (cons Y Xs) (cons Y Ys).
%mode removeFirst +X +Xs -Zs.
%query 1 1 removeFirst 2 (cons 1 (cons 2 (cons 1 (cons 2 (cons 2 nil))))) Zs.
%query 1 1 removeFirst 2 (cons 2 (cons 3 (cons 1 (cons 2 (cons 2 nil))))) Zs.
%query 1 1 removeFirst 2 (cons 1 (cons 3 (cons 2 (cons 1 (cons 2 nil))))) Zs.

