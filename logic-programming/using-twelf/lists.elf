nat : type.
z : nat.
succ : nat -> nat.

1 = succ z.
2 = succ 1.
3 = succ 2.
4 = succ 3.
5 = succ 4.
6 = succ 5.
7 = succ 6.
8 = succ 7.
9 = succ 8.
10 = succ 9.

% let's redefine plus using succ2
plus : nat -> nat -> nat -> type.
plus\z : plus z X X.
%        premise       goal
plus\s : plus A B C -> plus (succ A) B (succ C).
% Procedure
% Substitute plus\z in plus\s
% plus z 1 1 then plus (succ z) 1 (succ 1)
%                                    *
% 2 + 1 = 3
% plus (succ z) 1 (succ 1) -> plus (succ (succ z)) 1 (succ (succ 1))
%                                                          *

% first number is how many solutions
% second number is the number of tries
%query 1 1 plus 2 5 Res.

list : type.
nil : list.
cons : nat -> list -> list.

append : list -> list -> list -> type.
appNil : append nil Xs Xs.
appCons : append Xs Ys Res -> append (cons X Xs) Ys (cons X Res).
% Procedure
% Substitute appNil in appCons
% append nil Xs Xs then append (cons X nil) Xs (cons X Xs)
%
% Example
% append [2;3] [4;5]
% I know that append nil [4;5] (the last [4;5] is the result)
% if append [] [4;5] [4;5] then based on appCons append [3] [4;5] [3;4;5]
% if append [3] [4;5] [3;4;5] then based on appCons append [2;3] [4;5] [2;3;4;5]


% Exercises
% Write a relation that expresses the length of a list
len : list -> nat -> type.
len\base : len nil z.
len\rec : len Xs L -> len (cons X Xs) (succ L).
%query 1 1 len (cons 1 (cons 2 (cons 3 nil))) L.
% Procedure
% len [1;2;3;nil] L.
% len nil z.
% len nil z -> len [3; nil] 1
% len [3; nil] 1 -> len [2; 3; nil] -> 2
% len [2;3; nil] 2 -> len [1,2;3;nil] 3.


% relation from a nat -> list -> list, it should remove nat from the list
% and return the list without the removed item
rem : nat -> list -> list -> type.
rem\base : rem N (cons N Xs) Xs.
rem\rec : rem N Xs Ys -> rem N (cons X Xs) (cons X Ys).
% JessiBit's hint: write down the substitution to figure out what to do
% rem 1 [2;1;3;nil] [2;3;nil] -> rem 1 (cons 2 [1;3;nil]) [3;nil].
%query 1 1 rem 1 (cons 2 (cons 1 (cons 3 nil))) L.
%query 1 1 rem 1 (cons 1 (cons 2 (cons 3 nil))) L.
%query 1 1 rem 1 (cons 1 (cons 1 (cons 3 nil))) L.


boolean : type.
true : boolean.
false : boolean.

or : boolean -> boolean -> type.
or\t1 : or true true.
or\t2 : or true false.
or\t3 : or false true.
% in logic programming we only specify what is true


contains : nat -> list -> boolean -> type.
contains\base : contains N (cons N Xs) true.
% if N is contained in Xs (captured by B) then n is contained in (cons X Xs), or not
contains\rec : contains N Xs B -> contains N (cons X Xs) B.
% contains 1 [2;1;3;nil] true -> contains 1 (cons 2 [1;3;nil]) true.
%query 1 1 contains 1 (cons 2 (cons 1 (cons 3 nil))) B.
%query 1 1 contains 1 (cons 1 (cons 2 (cons 3 nil))) B.
%query 1 0 contains 1 (cons 2 (cons 4 (cons 3 nil))) B.


% reverse : list -> list -> type.
% reverse\base : reverse (cons X nil) (cons X Acc).
% reverse\rec : reverse Xs Acc -> reverse (cons X Xs) (cons X Acc).

rev : list -> list -> list -> type.
rev/nil : rev nil Acc Acc.
rev/cons : rev Xs (cons E Acc) R      % premise
            -> rev (cons E Xs) Acc R.
%query 1 1 rev (cons 1 (cons 2 (cons 3 nil))) nil R.

