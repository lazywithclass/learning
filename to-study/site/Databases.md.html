<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Databases</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p><a href="Relational%20algebra.md">Relational algebra</a> <a
href="PostgreSQL%20exercises.md">PostgreSQL exercises</a></p>
<h1 id="relational-model">Relational model</h1>
<p>Mathematical relations between sets (domains) via a Cartesian
product. Data is organized in rows, all rows are different from each
other (since they are the result of a Cartesian product).</p>
<table>
<thead>
<tr class="header">
<th><span
class="math inline"><em>A</em><em>t</em><em>t</em><em>r</em><em>i</em><em>b</em><em>u</em><em>t</em><em>e</em><sub>1</sub></span></th>
<th><span
class="math inline"><em>A</em><em>t</em><em>t</em><em>r</em><em>i</em><em>b</em><em>u</em><em>t</em><em>e</em><sub>2</sub></span></th>
<th><span class="math inline">…</span></th>
<th><span
class="math inline"><em>A</em><em>t</em><em>t</em><em>r</em><em>i</em><em>b</em><em>u</em><em>t</em><em>e</em><sub><em>k</em></sub></span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span
class="math inline"><em>D</em><em>a</em><em>t</em><em>a</em><sub>1</sub></span></td>
<td><span
class="math inline"><em>D</em><em>a</em><em>t</em><em>a</em><sub>2</sub></span></td>
<td><span class="math inline">…</span></td>
<td><span
class="math inline"><em>D</em><em>a</em><em>t</em><em>a</em><sub><em>k</em></sub></span></td>
</tr>
</tbody>
</table>
<p>Keep the schema as fixed as possible, so that applications using it
do not need to change accordingly.</p>
<p>Given <span
class="math inline"><em>D</em><sub>1</sub> = {<em>a</em>, <em>b</em>}</span>
and <span
class="math inline"><em>D</em><sub>2</sub> = {<em>x</em>, <em>y</em>, <em>z</em>}</span>
the Cartesian product is <span
class="math inline"><em>D</em><sub>1</sub> × <em>D</em><sub>2</sub> = {(<em>a</em>,<em>x</em>), (<em>a</em>,<em>y</em>), (<em>a</em>,<em>z</em>), (<em>b</em>,<em>x</em>), (<em>b</em>,<em>y</em>), (<em>b</em>,<em>z</em>)}</span>.
A relation is a subset of that product such that <span
class="math inline"><em>r</em> ⊆ <em>D</em><sub>1</sub> × <em>D</em><sub>2</sub> = {(<em>a</em>,<em>x</em>), (<em>a</em>,<em>y</em>), (<em>b</em>,<em>x</em>), (<em>b</em>,<em>y</em>)}</span>.</p>
<h2 id="null">NULL</h2>
<p>Absence of a value in the domain. We can’t use it to compare values,
an attribute <span
class="math inline"><em>y</em><em>e</em><em>a</em><em>r</em></span>
which could be <span
class="math inline"><em>N</em><em>U</em><em>L</em><em>L</em></span>
could not be compared with, for example, <span
class="math inline">2024</span> to understand if it comes before or
after. We can’t even say if they’re different or not (in a way).</p>
<h3 id="open-world-semantic">Open-world semantic</h3>
<p>Everything that does not falsify a predicate it’s true.</p>
<h3 id="closed-world-semantic">Closed-world semantic</h3>
<p>Only something that verify a predicate it’s true.</p>
<h2 id="constraints">Constraints</h2>
<p>A predicate that for each instance could return true or false.</p>
<h3 id="in-a-table">In a table</h3>
<ul>
<li>domain constraints - for example <span
class="math inline"><em>y</em><em>e</em><em>a</em><em>r</em> ≥ 1950 <em>A</em><em>N</em><em>D</em> <em>y</em><em>e</em><em>a</em><em>r</em> ≤ 2015</span></li>
<li>row constraints - express conditions on attributes on a row, domain
constraints are row constraints that operate on a single attribute</li>
<li>key constraints</li>
</ul>
<h2 id="functional-dependency">Functional dependency</h2>
<p>A dependency <span
class="math inline"><em>F</em><em>D</em> : <em>X</em>→ <em>Y</em></span> means
that the values of <span class="math inline"><em>Y</em></span> are
determined by the values of <span
class="math inline"><em>X</em></span>.</p>
<p>“Which are the minimum attributes I need to determine that
attribute?”</p>
<p>This allows to determine which attributes go in which tables.</p>
<p>Of course we could only recognize functional dependencies if we know
the domain of the application, if we don’t know anything it’s very hard
to do a good job in identifying them.</p>
<aside>
key concept
</aside>
<p>Key question to ask ourself to see if there’s a functional
dependency: “left side of this hypothetical dependency identifies
precisely the right side?” if not then there isn’t a functional
dependency.</p>
<h2 id="normal-forms">Normal forms</h2>
<p>We want to avoid redundancy in the information.</p>
<p>A database is well formed if it has 1NF, 2NF, 3NF. As a rule of
thumb: * we want lots of writes <span class="math inline">→</span> more
normalization * we want lots of reads <span class="math inline">→</span>
less normalization</p>
<h3 id="nf">1NF</h3>
<p>Only atomic attributes. We don’t have a relational database if we
don’t have this NF.</p>
<h3 id="nf-1">2NF</h3>
<p>Depends on 1NF.</p>
<p>Every non-key attribute must depend on the primary key, as a whole,
and not just on a subset of it. Normalization: put the subset of the key
and the attribute in a new table.</p>
<p>If the key is a single attribute then we always have 2NF.</p>
<h3 id="nf-2">3NF</h3>
<p>Depends on 2NF.</p>
<p>Transitive dependency: <span
class="math inline"><em>X</em> → <em>Y</em></span> is transitive if a
set of attributes <span class="math inline"><em>Z</em></span> (not key
and not subset of a key) exists such that <span
class="math inline"><em>X</em> → <em>Z</em></span> and <span
class="math inline"><em>Z</em> → <em>Y</em></span>. 2NF and no non-prime
attribute in <span class="math inline"><em>R</em></span> depends in a
transitive way on the primary key.</p>
<p>In other words: we don’t want two non-key attributes on the left AND
on the right of a functional dependency. They all have to be on the left
side.</p>
<h3 id="bcnf">BCNF</h3>
<p>All non prime attributes must depend on a super-key.</p>
<p>The key in the decomposed relations must be a super-key in the
original relation.</p>
<h2 id="using-normal-forms-to-decompose-relations">Using normal forms to
decompose relations</h2>
<p>Goal is to start from a big universal relation and finish to a scheme
with multiple relations, which respect the normal forms.</p>
<p>There is a procedure to follow, which has 3 rules: * preserve
attributes * preserve functional dependencies * lossless joins - we
don’t want joins to that create data that was not present in the
original relations</p>
<p>The algorithm is: 1. define functional dependencies 2. minimize
functional dependencies 3. for each functional dependency <span
class="math inline"><em>X</em> → <em>Y</em></span>, create a new
relation where we have <span class="math inline"><em>X</em></span> and
all dependencies on the right side that have <span
class="math inline"><em>X</em></span> on the left side 4. attributes
left out go in a relation of their own</p>
<h2 id="normalization">Normalization</h2>
<p>Anomalies and redundancies arise when we have functional dependencies
like <span class="math inline"><em>X</em> → <em>Y</em></span>, where
<span class="math inline"><em>X</em></span> is not a superkey (a subset
of the key). To avoid redundancies and anomalies, we have to put our
relation in BCNF.</p>
</body>
</html>
