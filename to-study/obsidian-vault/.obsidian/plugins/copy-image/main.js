/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyImagePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/jimp/dist/browser/index.js
var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function getDefaultExportFromCjs(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
function getAugmentedNamespace(e4) {
  if (e4.__esModule)
    return e4;
  var t2 = e4.default;
  if ("function" == typeof t2) {
    var i2 = function e5() {
      return this instanceof e5 ? Reflect.construct(t2, arguments, this.constructor) : t2.apply(this, arguments);
    };
    i2.prototype = t2.prototype;
  } else
    i2 = {};
  return Object.defineProperty(i2, "__esModule", { value: true }), Object.keys(e4).forEach(function(t3) {
    var r2 = Object.getOwnPropertyDescriptor(e4, t3);
    Object.defineProperty(i2, t3, r2.get ? r2 : { enumerable: true, get: function() {
      return e4[t3];
    } });
  }), i2;
}
"undefined" == typeof self && "object" == typeof commonjsGlobal && (commonjsGlobal.self = commonjsGlobal);
var global$1 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
var lookup = [];
var revLookup = [];
var Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  for (var e4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0; t2 < 64; ++t2)
    lookup[t2] = e4[t2], revLookup[e4.charCodeAt(t2)] = t2;
  revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(e4) {
  var t2, i2, r2, n2, a2, o2;
  inited || init();
  var s2 = e4.length;
  if (s2 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  a2 = "=" === e4[s2 - 2] ? 2 : "=" === e4[s2 - 1] ? 1 : 0, o2 = new Arr(3 * s2 / 4 - a2), r2 = a2 > 0 ? s2 - 4 : s2;
  var l2 = 0;
  for (t2 = 0, i2 = 0; t2 < r2; t2 += 4, i2 += 3)
    n2 = revLookup[e4.charCodeAt(t2)] << 18 | revLookup[e4.charCodeAt(t2 + 1)] << 12 | revLookup[e4.charCodeAt(t2 + 2)] << 6 | revLookup[e4.charCodeAt(t2 + 3)], o2[l2++] = n2 >> 16 & 255, o2[l2++] = n2 >> 8 & 255, o2[l2++] = 255 & n2;
  return 2 === a2 ? (n2 = revLookup[e4.charCodeAt(t2)] << 2 | revLookup[e4.charCodeAt(t2 + 1)] >> 4, o2[l2++] = 255 & n2) : 1 === a2 && (n2 = revLookup[e4.charCodeAt(t2)] << 10 | revLookup[e4.charCodeAt(t2 + 1)] << 4 | revLookup[e4.charCodeAt(t2 + 2)] >> 2, o2[l2++] = n2 >> 8 & 255, o2[l2++] = 255 & n2), o2;
}
function tripletToBase64(e4) {
  return lookup[e4 >> 18 & 63] + lookup[e4 >> 12 & 63] + lookup[e4 >> 6 & 63] + lookup[63 & e4];
}
function encodeChunk(e4, t2, i2) {
  for (var r2, n2 = [], a2 = t2; a2 < i2; a2 += 3)
    r2 = (e4[a2] << 16) + (e4[a2 + 1] << 8) + e4[a2 + 2], n2.push(tripletToBase64(r2));
  return n2.join("");
}
function fromByteArray(e4) {
  var t2;
  inited || init();
  for (var i2 = e4.length, r2 = i2 % 3, n2 = "", a2 = [], o2 = 16383, s2 = 0, l2 = i2 - r2; s2 < l2; s2 += o2)
    a2.push(encodeChunk(e4, s2, s2 + o2 > l2 ? l2 : s2 + o2));
  return 1 === r2 ? (t2 = e4[i2 - 1], n2 += lookup[t2 >> 2], n2 += lookup[t2 << 4 & 63], n2 += "==") : 2 === r2 && (t2 = (e4[i2 - 2] << 8) + e4[i2 - 1], n2 += lookup[t2 >> 10], n2 += lookup[t2 >> 4 & 63], n2 += lookup[t2 << 2 & 63], n2 += "="), a2.push(n2), a2.join("");
}
function read(e4, t2, i2, r2, n2) {
  var a2, o2, s2 = 8 * n2 - r2 - 1, l2 = (1 << s2) - 1, u2 = l2 >> 1, h2 = -7, c2 = i2 ? n2 - 1 : 0, f2 = i2 ? -1 : 1, d = e4[t2 + c2];
  for (c2 += f2, a2 = d & (1 << -h2) - 1, d >>= -h2, h2 += s2; h2 > 0; a2 = 256 * a2 + e4[t2 + c2], c2 += f2, h2 -= 8)
    ;
  for (o2 = a2 & (1 << -h2) - 1, a2 >>= -h2, h2 += r2; h2 > 0; o2 = 256 * o2 + e4[t2 + c2], c2 += f2, h2 -= 8)
    ;
  if (0 === a2)
    a2 = 1 - u2;
  else {
    if (a2 === l2)
      return o2 ? NaN : 1 / 0 * (d ? -1 : 1);
    o2 += Math.pow(2, r2), a2 -= u2;
  }
  return (d ? -1 : 1) * o2 * Math.pow(2, a2 - r2);
}
function write(e4, t2, i2, r2, n2, a2) {
  var o2, s2, l2, u2 = 8 * a2 - n2 - 1, h2 = (1 << u2) - 1, c2 = h2 >> 1, f2 = 23 === n2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r2 ? 0 : a2 - 1, p2 = r2 ? 1 : -1, m = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
  for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = h2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), (t2 += o2 + c2 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - c2)) * l2 >= 2 && (o2++, l2 /= 2), o2 + c2 >= h2 ? (s2 = 0, o2 = h2) : o2 + c2 >= 1 ? (s2 = (t2 * l2 - 1) * Math.pow(2, n2), o2 += c2) : (s2 = t2 * Math.pow(2, c2 - 1) * Math.pow(2, n2), o2 = 0)); n2 >= 8; e4[i2 + d] = 255 & s2, d += p2, s2 /= 256, n2 -= 8)
    ;
  for (o2 = o2 << n2 | s2, u2 += n2; u2 > 0; e4[i2 + d] = 255 & o2, d += p2, o2 /= 256, u2 -= 8)
    ;
  e4[i2 + d - p2] |= 128 * m;
}
var toString = {}.toString;
var isArray = Array.isArray || function(e4) {
  return "[object Array]" == toString.call(e4);
};
var INSPECT_MAX_BYTES = 50;
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(e4, t2) {
  if (kMaxLength() < t2)
    throw new RangeError("Invalid typed array length");
  return Buffer2.TYPED_ARRAY_SUPPORT ? (e4 = new Uint8Array(t2)).__proto__ = Buffer2.prototype : (null === e4 && (e4 = new Buffer2(t2)), e4.length = t2), e4;
}
function Buffer2(e4, t2, i2) {
  if (!(Buffer2.TYPED_ARRAY_SUPPORT || this instanceof Buffer2))
    return new Buffer2(e4, t2, i2);
  if ("number" == typeof e4) {
    if ("string" == typeof t2)
      throw new Error("If encoding is specified then the first argument must be a string");
    return allocUnsafe(this, e4);
  }
  return from(this, e4, t2, i2);
}
function from(e4, t2, i2, r2) {
  if ("number" == typeof t2)
    throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t2 instanceof ArrayBuffer ? fromArrayBuffer(e4, t2, i2, r2) : "string" == typeof t2 ? fromString(e4, t2, i2) : fromObject(e4, t2);
}
function assertSize(e4) {
  if ("number" != typeof e4)
    throw new TypeError('"size" argument must be a number');
  if (e4 < 0)
    throw new RangeError('"size" argument must not be negative');
}
function alloc(e4, t2, i2, r2) {
  return assertSize(t2), t2 <= 0 ? createBuffer(e4, t2) : void 0 !== i2 ? "string" == typeof r2 ? createBuffer(e4, t2).fill(i2, r2) : createBuffer(e4, t2).fill(i2) : createBuffer(e4, t2);
}
function allocUnsafe(e4, t2) {
  if (assertSize(t2), e4 = createBuffer(e4, t2 < 0 ? 0 : 0 | checked(t2)), !Buffer2.TYPED_ARRAY_SUPPORT)
    for (var i2 = 0; i2 < t2; ++i2)
      e4[i2] = 0;
  return e4;
}
function fromString(e4, t2, i2) {
  if ("string" == typeof i2 && "" !== i2 || (i2 = "utf8"), !Buffer2.isEncoding(i2))
    throw new TypeError('"encoding" must be a valid string encoding');
  var r2 = 0 | byteLength(t2, i2), n2 = (e4 = createBuffer(e4, r2)).write(t2, i2);
  return n2 !== r2 && (e4 = e4.slice(0, n2)), e4;
}
function fromArrayLike(e4, t2) {
  var i2 = t2.length < 0 ? 0 : 0 | checked(t2.length);
  e4 = createBuffer(e4, i2);
  for (var r2 = 0; r2 < i2; r2 += 1)
    e4[r2] = 255 & t2[r2];
  return e4;
}
function fromArrayBuffer(e4, t2, i2, r2) {
  if (t2.byteLength, i2 < 0 || t2.byteLength < i2)
    throw new RangeError("'offset' is out of bounds");
  if (t2.byteLength < i2 + (r2 || 0))
    throw new RangeError("'length' is out of bounds");
  return t2 = void 0 === i2 && void 0 === r2 ? new Uint8Array(t2) : void 0 === r2 ? new Uint8Array(t2, i2) : new Uint8Array(t2, i2, r2), Buffer2.TYPED_ARRAY_SUPPORT ? (e4 = t2).__proto__ = Buffer2.prototype : e4 = fromArrayLike(e4, t2), e4;
}
function fromObject(e4, t2) {
  if (internalIsBuffer(t2)) {
    var i2 = 0 | checked(t2.length);
    return 0 === (e4 = createBuffer(e4, i2)).length || t2.copy(e4, 0, 0, i2), e4;
  }
  if (t2) {
    if ("undefined" != typeof ArrayBuffer && t2.buffer instanceof ArrayBuffer || "length" in t2)
      return "number" != typeof t2.length || isnan(t2.length) ? createBuffer(e4, 0) : fromArrayLike(e4, t2);
    if ("Buffer" === t2.type && isArray(t2.data))
      return fromArrayLike(e4, t2.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(e4) {
  if (e4 >= kMaxLength())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return 0 | e4;
}
function internalIsBuffer(e4) {
  return !(null == e4 || !e4._isBuffer);
}
function byteLength(e4, t2) {
  if (internalIsBuffer(e4))
    return e4.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e4) || e4 instanceof ArrayBuffer))
    return e4.byteLength;
  "string" != typeof e4 && (e4 = "" + e4);
  var i2 = e4.length;
  if (0 === i2)
    return 0;
  for (var r2 = false; ; )
    switch (t2) {
      case "ascii":
      case "latin1":
      case "binary":
        return i2;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(e4).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * i2;
      case "hex":
        return i2 >>> 1;
      case "base64":
        return base64ToBytes(e4).length;
      default:
        if (r2)
          return utf8ToBytes(e4).length;
        t2 = ("" + t2).toLowerCase(), r2 = true;
    }
}
function slowToString(e4, t2, i2) {
  var r2 = false;
  if ((void 0 === t2 || t2 < 0) && (t2 = 0), t2 > this.length)
    return "";
  if ((void 0 === i2 || i2 > this.length) && (i2 = this.length), i2 <= 0)
    return "";
  if ((i2 >>>= 0) <= (t2 >>>= 0))
    return "";
  for (e4 || (e4 = "utf8"); ; )
    switch (e4) {
      case "hex":
        return hexSlice(this, t2, i2);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, t2, i2);
      case "ascii":
        return asciiSlice(this, t2, i2);
      case "latin1":
      case "binary":
        return latin1Slice(this, t2, i2);
      case "base64":
        return base64Slice(this, t2, i2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, t2, i2);
      default:
        if (r2)
          throw new TypeError("Unknown encoding: " + e4);
        e4 = (e4 + "").toLowerCase(), r2 = true;
    }
}
function swap(e4, t2, i2) {
  var r2 = e4[t2];
  e4[t2] = e4[i2], e4[i2] = r2;
}
function bidirectionalIndexOf(e4, t2, i2, r2, n2) {
  if (0 === e4.length)
    return -1;
  if ("string" == typeof i2 ? (r2 = i2, i2 = 0) : i2 > 2147483647 ? i2 = 2147483647 : i2 < -2147483648 && (i2 = -2147483648), i2 = +i2, isNaN(i2) && (i2 = n2 ? 0 : e4.length - 1), i2 < 0 && (i2 = e4.length + i2), i2 >= e4.length) {
    if (n2)
      return -1;
    i2 = e4.length - 1;
  } else if (i2 < 0) {
    if (!n2)
      return -1;
    i2 = 0;
  }
  if ("string" == typeof t2 && (t2 = Buffer2.from(t2, r2)), internalIsBuffer(t2))
    return 0 === t2.length ? -1 : arrayIndexOf(e4, t2, i2, r2, n2);
  if ("number" == typeof t2)
    return t2 &= 255, Buffer2.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n2 ? Uint8Array.prototype.indexOf.call(e4, t2, i2) : Uint8Array.prototype.lastIndexOf.call(e4, t2, i2) : arrayIndexOf(e4, [t2], i2, r2, n2);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(e4, t2, i2, r2, n2) {
  var a2, o2 = 1, s2 = e4.length, l2 = t2.length;
  if (void 0 !== r2 && ("ucs2" === (r2 = String(r2).toLowerCase()) || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
    if (e4.length < 2 || t2.length < 2)
      return -1;
    o2 = 2, s2 /= 2, l2 /= 2, i2 /= 2;
  }
  function u2(e5, t3) {
    return 1 === o2 ? e5[t3] : e5.readUInt16BE(t3 * o2);
  }
  if (n2) {
    var h2 = -1;
    for (a2 = i2; a2 < s2; a2++)
      if (u2(e4, a2) === u2(t2, -1 === h2 ? 0 : a2 - h2)) {
        if (-1 === h2 && (h2 = a2), a2 - h2 + 1 === l2)
          return h2 * o2;
      } else
        -1 !== h2 && (a2 -= a2 - h2), h2 = -1;
  } else
    for (i2 + l2 > s2 && (i2 = s2 - l2), a2 = i2; a2 >= 0; a2--) {
      for (var c2 = true, f2 = 0; f2 < l2; f2++)
        if (u2(e4, a2 + f2) !== u2(t2, f2)) {
          c2 = false;
          break;
        }
      if (c2)
        return a2;
    }
  return -1;
}
function hexWrite(e4, t2, i2, r2) {
  i2 = Number(i2) || 0;
  var n2 = e4.length - i2;
  r2 ? (r2 = Number(r2)) > n2 && (r2 = n2) : r2 = n2;
  var a2 = t2.length;
  if (a2 % 2 != 0)
    throw new TypeError("Invalid hex string");
  r2 > a2 / 2 && (r2 = a2 / 2);
  for (var o2 = 0; o2 < r2; ++o2) {
    var s2 = parseInt(t2.substr(2 * o2, 2), 16);
    if (isNaN(s2))
      return o2;
    e4[i2 + o2] = s2;
  }
  return o2;
}
function utf8Write(e4, t2, i2, r2) {
  return blitBuffer(utf8ToBytes(t2, e4.length - i2), e4, i2, r2);
}
function asciiWrite(e4, t2, i2, r2) {
  return blitBuffer(asciiToBytes(t2), e4, i2, r2);
}
function latin1Write(e4, t2, i2, r2) {
  return asciiWrite(e4, t2, i2, r2);
}
function base64Write(e4, t2, i2, r2) {
  return blitBuffer(base64ToBytes(t2), e4, i2, r2);
}
function ucs2Write(e4, t2, i2, r2) {
  return blitBuffer(utf16leToBytes(t2, e4.length - i2), e4, i2, r2);
}
function base64Slice(e4, t2, i2) {
  return 0 === t2 && i2 === e4.length ? fromByteArray(e4) : fromByteArray(e4.slice(t2, i2));
}
function utf8Slice(e4, t2, i2) {
  i2 = Math.min(e4.length, i2);
  for (var r2 = [], n2 = t2; n2 < i2; ) {
    var a2, o2, s2, l2, u2 = e4[n2], h2 = null, c2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
    if (n2 + c2 <= i2)
      switch (c2) {
        case 1:
          u2 < 128 && (h2 = u2);
          break;
        case 2:
          128 == (192 & (a2 = e4[n2 + 1])) && (l2 = (31 & u2) << 6 | 63 & a2) > 127 && (h2 = l2);
          break;
        case 3:
          a2 = e4[n2 + 1], o2 = e4[n2 + 2], 128 == (192 & a2) && 128 == (192 & o2) && (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o2) > 2047 && (l2 < 55296 || l2 > 57343) && (h2 = l2);
          break;
        case 4:
          a2 = e4[n2 + 1], o2 = e4[n2 + 2], s2 = e4[n2 + 3], 128 == (192 & a2) && 128 == (192 & o2) && 128 == (192 & s2) && (l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && l2 < 1114112 && (h2 = l2);
      }
    null === h2 ? (h2 = 65533, c2 = 1) : h2 > 65535 && (h2 -= 65536, r2.push(h2 >>> 10 & 1023 | 55296), h2 = 56320 | 1023 & h2), r2.push(h2), n2 += c2;
  }
  return decodeCodePointsArray(r2);
}
Buffer2.TYPED_ARRAY_SUPPORT = void 0 === global$1.TYPED_ARRAY_SUPPORT || global$1.TYPED_ARRAY_SUPPORT, kMaxLength(), Buffer2.poolSize = 8192, Buffer2._augment = function(e4) {
  return e4.__proto__ = Buffer2.prototype, e4;
}, Buffer2.from = function(e4, t2, i2) {
  return from(null, e4, t2, i2);
}, Buffer2.TYPED_ARRAY_SUPPORT && (Buffer2.prototype.__proto__ = Uint8Array.prototype, Buffer2.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && Buffer2[Symbol.species]), Buffer2.alloc = function(e4, t2, i2) {
  return alloc(null, e4, t2, i2);
}, Buffer2.allocUnsafe = function(e4) {
  return allocUnsafe(null, e4);
}, Buffer2.allocUnsafeSlow = function(e4) {
  return allocUnsafe(null, e4);
}, Buffer2.isBuffer = isBuffer, Buffer2.compare = function(e4, t2) {
  if (!internalIsBuffer(e4) || !internalIsBuffer(t2))
    throw new TypeError("Arguments must be Buffers");
  if (e4 === t2)
    return 0;
  for (var i2 = e4.length, r2 = t2.length, n2 = 0, a2 = Math.min(i2, r2); n2 < a2; ++n2)
    if (e4[n2] !== t2[n2]) {
      i2 = e4[n2], r2 = t2[n2];
      break;
    }
  return i2 < r2 ? -1 : r2 < i2 ? 1 : 0;
}, Buffer2.isEncoding = function(e4) {
  switch (String(e4).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, Buffer2.concat = function(e4, t2) {
  if (!isArray(e4))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e4.length)
    return Buffer2.alloc(0);
  var i2;
  if (void 0 === t2)
    for (t2 = 0, i2 = 0; i2 < e4.length; ++i2)
      t2 += e4[i2].length;
  var r2 = Buffer2.allocUnsafe(t2), n2 = 0;
  for (i2 = 0; i2 < e4.length; ++i2) {
    var a2 = e4[i2];
    if (!internalIsBuffer(a2))
      throw new TypeError('"list" argument must be an Array of Buffers');
    a2.copy(r2, n2), n2 += a2.length;
  }
  return r2;
}, Buffer2.byteLength = byteLength, Buffer2.prototype._isBuffer = true, Buffer2.prototype.swap16 = function() {
  var e4 = this.length;
  if (e4 % 2 != 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t2 = 0; t2 < e4; t2 += 2)
    swap(this, t2, t2 + 1);
  return this;
}, Buffer2.prototype.swap32 = function() {
  var e4 = this.length;
  if (e4 % 4 != 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t2 = 0; t2 < e4; t2 += 4)
    swap(this, t2, t2 + 3), swap(this, t2 + 1, t2 + 2);
  return this;
}, Buffer2.prototype.swap64 = function() {
  var e4 = this.length;
  if (e4 % 8 != 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t2 = 0; t2 < e4; t2 += 8)
    swap(this, t2, t2 + 7), swap(this, t2 + 1, t2 + 6), swap(this, t2 + 2, t2 + 5), swap(this, t2 + 3, t2 + 4);
  return this;
}, Buffer2.prototype.toString = function() {
  var e4 = 0 | this.length;
  return 0 === e4 ? "" : 0 === arguments.length ? utf8Slice(this, 0, e4) : slowToString.apply(this, arguments);
}, Buffer2.prototype.equals = function(e4) {
  if (!internalIsBuffer(e4))
    throw new TypeError("Argument must be a Buffer");
  return this === e4 || 0 === Buffer2.compare(this, e4);
}, Buffer2.prototype.inspect = function() {
  var e4 = "", t2 = INSPECT_MAX_BYTES;
  return this.length > 0 && (e4 = this.toString("hex", 0, t2).match(/.{2}/g).join(" "), this.length > t2 && (e4 += " ... ")), "<Buffer " + e4 + ">";
}, Buffer2.prototype.compare = function(e4, t2, i2, r2, n2) {
  if (!internalIsBuffer(e4))
    throw new TypeError("Argument must be a Buffer");
  if (void 0 === t2 && (t2 = 0), void 0 === i2 && (i2 = e4 ? e4.length : 0), void 0 === r2 && (r2 = 0), void 0 === n2 && (n2 = this.length), t2 < 0 || i2 > e4.length || r2 < 0 || n2 > this.length)
    throw new RangeError("out of range index");
  if (r2 >= n2 && t2 >= i2)
    return 0;
  if (r2 >= n2)
    return -1;
  if (t2 >= i2)
    return 1;
  if (this === e4)
    return 0;
  for (var a2 = (n2 >>>= 0) - (r2 >>>= 0), o2 = (i2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(a2, o2), l2 = this.slice(r2, n2), u2 = e4.slice(t2, i2), h2 = 0; h2 < s2; ++h2)
    if (l2[h2] !== u2[h2]) {
      a2 = l2[h2], o2 = u2[h2];
      break;
    }
  return a2 < o2 ? -1 : o2 < a2 ? 1 : 0;
}, Buffer2.prototype.includes = function(e4, t2, i2) {
  return -1 !== this.indexOf(e4, t2, i2);
}, Buffer2.prototype.indexOf = function(e4, t2, i2) {
  return bidirectionalIndexOf(this, e4, t2, i2, true);
}, Buffer2.prototype.lastIndexOf = function(e4, t2, i2) {
  return bidirectionalIndexOf(this, e4, t2, i2, false);
}, Buffer2.prototype.write = function(e4, t2, i2, r2) {
  if (void 0 === t2)
    r2 = "utf8", i2 = this.length, t2 = 0;
  else if (void 0 === i2 && "string" == typeof t2)
    r2 = t2, i2 = this.length, t2 = 0;
  else {
    if (!isFinite(t2))
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t2 |= 0, isFinite(i2) ? (i2 |= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = i2, i2 = void 0);
  }
  var n2 = this.length - t2;
  if ((void 0 === i2 || i2 > n2) && (i2 = n2), e4.length > 0 && (i2 < 0 || t2 < 0) || t2 > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  r2 || (r2 = "utf8");
  for (var a2 = false; ; )
    switch (r2) {
      case "hex":
        return hexWrite(this, e4, t2, i2);
      case "utf8":
      case "utf-8":
        return utf8Write(this, e4, t2, i2);
      case "ascii":
        return asciiWrite(this, e4, t2, i2);
      case "latin1":
      case "binary":
        return latin1Write(this, e4, t2, i2);
      case "base64":
        return base64Write(this, e4, t2, i2);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, e4, t2, i2);
      default:
        if (a2)
          throw new TypeError("Unknown encoding: " + r2);
        r2 = ("" + r2).toLowerCase(), a2 = true;
    }
}, Buffer2.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(e4) {
  var t2 = e4.length;
  if (t2 <= MAX_ARGUMENTS_LENGTH)
    return String.fromCharCode.apply(String, e4);
  for (var i2 = "", r2 = 0; r2 < t2; )
    i2 += String.fromCharCode.apply(String, e4.slice(r2, r2 += MAX_ARGUMENTS_LENGTH));
  return i2;
}
function asciiSlice(e4, t2, i2) {
  var r2 = "";
  i2 = Math.min(e4.length, i2);
  for (var n2 = t2; n2 < i2; ++n2)
    r2 += String.fromCharCode(127 & e4[n2]);
  return r2;
}
function latin1Slice(e4, t2, i2) {
  var r2 = "";
  i2 = Math.min(e4.length, i2);
  for (var n2 = t2; n2 < i2; ++n2)
    r2 += String.fromCharCode(e4[n2]);
  return r2;
}
function hexSlice(e4, t2, i2) {
  var r2 = e4.length;
  (!t2 || t2 < 0) && (t2 = 0), (!i2 || i2 < 0 || i2 > r2) && (i2 = r2);
  for (var n2 = "", a2 = t2; a2 < i2; ++a2)
    n2 += toHex(e4[a2]);
  return n2;
}
function utf16leSlice(e4, t2, i2) {
  for (var r2 = e4.slice(t2, i2), n2 = "", a2 = 0; a2 < r2.length; a2 += 2)
    n2 += String.fromCharCode(r2[a2] + 256 * r2[a2 + 1]);
  return n2;
}
function checkOffset(e4, t2, i2) {
  if (e4 % 1 != 0 || e4 < 0)
    throw new RangeError("offset is not uint");
  if (e4 + t2 > i2)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(e4, t2, i2, r2, n2, a2) {
  if (!internalIsBuffer(e4))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t2 > n2 || t2 < a2)
    throw new RangeError('"value" argument is out of bounds');
  if (i2 + r2 > e4.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(e4, t2, i2, r2) {
  t2 < 0 && (t2 = 65535 + t2 + 1);
  for (var n2 = 0, a2 = Math.min(e4.length - i2, 2); n2 < a2; ++n2)
    e4[i2 + n2] = (t2 & 255 << 8 * (r2 ? n2 : 1 - n2)) >>> 8 * (r2 ? n2 : 1 - n2);
}
function objectWriteUInt32(e4, t2, i2, r2) {
  t2 < 0 && (t2 = 4294967295 + t2 + 1);
  for (var n2 = 0, a2 = Math.min(e4.length - i2, 4); n2 < a2; ++n2)
    e4[i2 + n2] = t2 >>> 8 * (r2 ? n2 : 3 - n2) & 255;
}
function checkIEEE754(e4, t2, i2, r2, n2, a2) {
  if (i2 + r2 > e4.length)
    throw new RangeError("Index out of range");
  if (i2 < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(e4, t2, i2, r2, n2) {
  return n2 || checkIEEE754(e4, t2, i2, 4), write(e4, t2, i2, r2, 23, 4), i2 + 4;
}
function writeDouble(e4, t2, i2, r2, n2) {
  return n2 || checkIEEE754(e4, t2, i2, 8), write(e4, t2, i2, r2, 52, 8), i2 + 8;
}
Buffer2.prototype.slice = function(e4, t2) {
  var i2, r2 = this.length;
  if ((e4 = ~~e4) < 0 ? (e4 += r2) < 0 && (e4 = 0) : e4 > r2 && (e4 = r2), (t2 = void 0 === t2 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e4 && (t2 = e4), Buffer2.TYPED_ARRAY_SUPPORT)
    (i2 = this.subarray(e4, t2)).__proto__ = Buffer2.prototype;
  else {
    var n2 = t2 - e4;
    i2 = new Buffer2(n2, void 0);
    for (var a2 = 0; a2 < n2; ++a2)
      i2[a2] = this[a2 + e4];
  }
  return i2;
}, Buffer2.prototype.readUIntLE = function(e4, t2, i2) {
  e4 |= 0, t2 |= 0, i2 || checkOffset(e4, t2, this.length);
  for (var r2 = this[e4], n2 = 1, a2 = 0; ++a2 < t2 && (n2 *= 256); )
    r2 += this[e4 + a2] * n2;
  return r2;
}, Buffer2.prototype.readUIntBE = function(e4, t2, i2) {
  e4 |= 0, t2 |= 0, i2 || checkOffset(e4, t2, this.length);
  for (var r2 = this[e4 + --t2], n2 = 1; t2 > 0 && (n2 *= 256); )
    r2 += this[e4 + --t2] * n2;
  return r2;
}, Buffer2.prototype.readUInt8 = function(e4, t2) {
  return t2 || checkOffset(e4, 1, this.length), this[e4];
}, Buffer2.prototype.readUInt16LE = function(e4, t2) {
  return t2 || checkOffset(e4, 2, this.length), this[e4] | this[e4 + 1] << 8;
}, Buffer2.prototype.readUInt16BE = function(e4, t2) {
  return t2 || checkOffset(e4, 2, this.length), this[e4] << 8 | this[e4 + 1];
}, Buffer2.prototype.readUInt32LE = function(e4, t2) {
  return t2 || checkOffset(e4, 4, this.length), (this[e4] | this[e4 + 1] << 8 | this[e4 + 2] << 16) + 16777216 * this[e4 + 3];
}, Buffer2.prototype.readUInt32BE = function(e4, t2) {
  return t2 || checkOffset(e4, 4, this.length), 16777216 * this[e4] + (this[e4 + 1] << 16 | this[e4 + 2] << 8 | this[e4 + 3]);
}, Buffer2.prototype.readIntLE = function(e4, t2, i2) {
  e4 |= 0, t2 |= 0, i2 || checkOffset(e4, t2, this.length);
  for (var r2 = this[e4], n2 = 1, a2 = 0; ++a2 < t2 && (n2 *= 256); )
    r2 += this[e4 + a2] * n2;
  return r2 >= (n2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
}, Buffer2.prototype.readIntBE = function(e4, t2, i2) {
  e4 |= 0, t2 |= 0, i2 || checkOffset(e4, t2, this.length);
  for (var r2 = t2, n2 = 1, a2 = this[e4 + --r2]; r2 > 0 && (n2 *= 256); )
    a2 += this[e4 + --r2] * n2;
  return a2 >= (n2 *= 128) && (a2 -= Math.pow(2, 8 * t2)), a2;
}, Buffer2.prototype.readInt8 = function(e4, t2) {
  return t2 || checkOffset(e4, 1, this.length), 128 & this[e4] ? -1 * (255 - this[e4] + 1) : this[e4];
}, Buffer2.prototype.readInt16LE = function(e4, t2) {
  t2 || checkOffset(e4, 2, this.length);
  var i2 = this[e4] | this[e4 + 1] << 8;
  return 32768 & i2 ? 4294901760 | i2 : i2;
}, Buffer2.prototype.readInt16BE = function(e4, t2) {
  t2 || checkOffset(e4, 2, this.length);
  var i2 = this[e4 + 1] | this[e4] << 8;
  return 32768 & i2 ? 4294901760 | i2 : i2;
}, Buffer2.prototype.readInt32LE = function(e4, t2) {
  return t2 || checkOffset(e4, 4, this.length), this[e4] | this[e4 + 1] << 8 | this[e4 + 2] << 16 | this[e4 + 3] << 24;
}, Buffer2.prototype.readInt32BE = function(e4, t2) {
  return t2 || checkOffset(e4, 4, this.length), this[e4] << 24 | this[e4 + 1] << 16 | this[e4 + 2] << 8 | this[e4 + 3];
}, Buffer2.prototype.readFloatLE = function(e4, t2) {
  return t2 || checkOffset(e4, 4, this.length), read(this, e4, true, 23, 4);
}, Buffer2.prototype.readFloatBE = function(e4, t2) {
  return t2 || checkOffset(e4, 4, this.length), read(this, e4, false, 23, 4);
}, Buffer2.prototype.readDoubleLE = function(e4, t2) {
  return t2 || checkOffset(e4, 8, this.length), read(this, e4, true, 52, 8);
}, Buffer2.prototype.readDoubleBE = function(e4, t2) {
  return t2 || checkOffset(e4, 8, this.length), read(this, e4, false, 52, 8);
}, Buffer2.prototype.writeUIntLE = function(e4, t2, i2, r2) {
  (e4 = +e4, t2 |= 0, i2 |= 0, r2) || checkInt(this, e4, t2, i2, Math.pow(2, 8 * i2) - 1, 0);
  var n2 = 1, a2 = 0;
  for (this[t2] = 255 & e4; ++a2 < i2 && (n2 *= 256); )
    this[t2 + a2] = e4 / n2 & 255;
  return t2 + i2;
}, Buffer2.prototype.writeUIntBE = function(e4, t2, i2, r2) {
  (e4 = +e4, t2 |= 0, i2 |= 0, r2) || checkInt(this, e4, t2, i2, Math.pow(2, 8 * i2) - 1, 0);
  var n2 = i2 - 1, a2 = 1;
  for (this[t2 + n2] = 255 & e4; --n2 >= 0 && (a2 *= 256); )
    this[t2 + n2] = e4 / a2 & 255;
  return t2 + i2;
}, Buffer2.prototype.writeUInt8 = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 1, 255, 0), Buffer2.TYPED_ARRAY_SUPPORT || (e4 = Math.floor(e4)), this[t2] = 255 & e4, t2 + 1;
}, Buffer2.prototype.writeUInt16LE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e4, this[t2 + 1] = e4 >>> 8) : objectWriteUInt16(this, e4, t2, true), t2 + 2;
}, Buffer2.prototype.writeUInt16BE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = e4 >>> 8, this[t2 + 1] = 255 & e4) : objectWriteUInt16(this, e4, t2, false), t2 + 2;
}, Buffer2.prototype.writeUInt32LE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e4 >>> 24, this[t2 + 2] = e4 >>> 16, this[t2 + 1] = e4 >>> 8, this[t2] = 255 & e4) : objectWriteUInt32(this, e4, t2, true), t2 + 4;
}, Buffer2.prototype.writeUInt32BE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = e4 >>> 24, this[t2 + 1] = e4 >>> 16, this[t2 + 2] = e4 >>> 8, this[t2 + 3] = 255 & e4) : objectWriteUInt32(this, e4, t2, false), t2 + 4;
}, Buffer2.prototype.writeIntLE = function(e4, t2, i2, r2) {
  if (e4 = +e4, t2 |= 0, !r2) {
    var n2 = Math.pow(2, 8 * i2 - 1);
    checkInt(this, e4, t2, i2, n2 - 1, -n2);
  }
  var a2 = 0, o2 = 1, s2 = 0;
  for (this[t2] = 255 & e4; ++a2 < i2 && (o2 *= 256); )
    e4 < 0 && 0 === s2 && 0 !== this[t2 + a2 - 1] && (s2 = 1), this[t2 + a2] = (e4 / o2 | 0) - s2 & 255;
  return t2 + i2;
}, Buffer2.prototype.writeIntBE = function(e4, t2, i2, r2) {
  if (e4 = +e4, t2 |= 0, !r2) {
    var n2 = Math.pow(2, 8 * i2 - 1);
    checkInt(this, e4, t2, i2, n2 - 1, -n2);
  }
  var a2 = i2 - 1, o2 = 1, s2 = 0;
  for (this[t2 + a2] = 255 & e4; --a2 >= 0 && (o2 *= 256); )
    e4 < 0 && 0 === s2 && 0 !== this[t2 + a2 + 1] && (s2 = 1), this[t2 + a2] = (e4 / o2 | 0) - s2 & 255;
  return t2 + i2;
}, Buffer2.prototype.writeInt8 = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 1, 127, -128), Buffer2.TYPED_ARRAY_SUPPORT || (e4 = Math.floor(e4)), e4 < 0 && (e4 = 255 + e4 + 1), this[t2] = 255 & e4, t2 + 1;
}, Buffer2.prototype.writeInt16LE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e4, this[t2 + 1] = e4 >>> 8) : objectWriteUInt16(this, e4, t2, true), t2 + 2;
}, Buffer2.prototype.writeInt16BE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = e4 >>> 8, this[t2 + 1] = 255 & e4) : objectWriteUInt16(this, e4, t2, false), t2 + 2;
}, Buffer2.prototype.writeInt32LE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 4, 2147483647, -2147483648), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e4, this[t2 + 1] = e4 >>> 8, this[t2 + 2] = e4 >>> 16, this[t2 + 3] = e4 >>> 24) : objectWriteUInt32(this, e4, t2, true), t2 + 4;
}, Buffer2.prototype.writeInt32BE = function(e4, t2, i2) {
  return e4 = +e4, t2 |= 0, i2 || checkInt(this, e4, t2, 4, 2147483647, -2147483648), e4 < 0 && (e4 = 4294967295 + e4 + 1), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t2] = e4 >>> 24, this[t2 + 1] = e4 >>> 16, this[t2 + 2] = e4 >>> 8, this[t2 + 3] = 255 & e4) : objectWriteUInt32(this, e4, t2, false), t2 + 4;
}, Buffer2.prototype.writeFloatLE = function(e4, t2, i2) {
  return writeFloat(this, e4, t2, true, i2);
}, Buffer2.prototype.writeFloatBE = function(e4, t2, i2) {
  return writeFloat(this, e4, t2, false, i2);
}, Buffer2.prototype.writeDoubleLE = function(e4, t2, i2) {
  return writeDouble(this, e4, t2, true, i2);
}, Buffer2.prototype.writeDoubleBE = function(e4, t2, i2) {
  return writeDouble(this, e4, t2, false, i2);
}, Buffer2.prototype.copy = function(e4, t2, i2, r2) {
  if (i2 || (i2 = 0), r2 || 0 === r2 || (r2 = this.length), t2 >= e4.length && (t2 = e4.length), t2 || (t2 = 0), r2 > 0 && r2 < i2 && (r2 = i2), r2 === i2)
    return 0;
  if (0 === e4.length || 0 === this.length)
    return 0;
  if (t2 < 0)
    throw new RangeError("targetStart out of bounds");
  if (i2 < 0 || i2 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (r2 < 0)
    throw new RangeError("sourceEnd out of bounds");
  r2 > this.length && (r2 = this.length), e4.length - t2 < r2 - i2 && (r2 = e4.length - t2 + i2);
  var n2, a2 = r2 - i2;
  if (this === e4 && i2 < t2 && t2 < r2)
    for (n2 = a2 - 1; n2 >= 0; --n2)
      e4[n2 + t2] = this[n2 + i2];
  else if (a2 < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT)
    for (n2 = 0; n2 < a2; ++n2)
      e4[n2 + t2] = this[n2 + i2];
  else
    Uint8Array.prototype.set.call(e4, this.subarray(i2, i2 + a2), t2);
  return a2;
}, Buffer2.prototype.fill = function(e4, t2, i2, r2) {
  if ("string" == typeof e4) {
    if ("string" == typeof t2 ? (r2 = t2, t2 = 0, i2 = this.length) : "string" == typeof i2 && (r2 = i2, i2 = this.length), 1 === e4.length) {
      var n2 = e4.charCodeAt(0);
      n2 < 256 && (e4 = n2);
    }
    if (void 0 !== r2 && "string" != typeof r2)
      throw new TypeError("encoding must be a string");
    if ("string" == typeof r2 && !Buffer2.isEncoding(r2))
      throw new TypeError("Unknown encoding: " + r2);
  } else
    "number" == typeof e4 && (e4 &= 255);
  if (t2 < 0 || this.length < t2 || this.length < i2)
    throw new RangeError("Out of range index");
  if (i2 <= t2)
    return this;
  var a2;
  if (t2 >>>= 0, i2 = void 0 === i2 ? this.length : i2 >>> 0, e4 || (e4 = 0), "number" == typeof e4)
    for (a2 = t2; a2 < i2; ++a2)
      this[a2] = e4;
  else {
    var o2 = internalIsBuffer(e4) ? e4 : utf8ToBytes(new Buffer2(e4, r2).toString()), s2 = o2.length;
    for (a2 = 0; a2 < i2 - t2; ++a2)
      this[a2 + t2] = o2[a2 % s2];
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
var HeaderTypes;
function base64clean(e4) {
  if ((e4 = stringtrim(e4).replace(INVALID_BASE64_RE, "")).length < 2)
    return "";
  for (; e4.length % 4 != 0; )
    e4 += "=";
  return e4;
}
function stringtrim(e4) {
  return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
}
function toHex(e4) {
  return e4 < 16 ? "0" + e4.toString(16) : e4.toString(16);
}
function utf8ToBytes(e4, t2) {
  var i2;
  t2 = t2 || 1 / 0;
  for (var r2 = e4.length, n2 = null, a2 = [], o2 = 0; o2 < r2; ++o2) {
    if ((i2 = e4.charCodeAt(o2)) > 55295 && i2 < 57344) {
      if (!n2) {
        if (i2 > 56319) {
          (t2 -= 3) > -1 && a2.push(239, 191, 189);
          continue;
        }
        if (o2 + 1 === r2) {
          (t2 -= 3) > -1 && a2.push(239, 191, 189);
          continue;
        }
        n2 = i2;
        continue;
      }
      if (i2 < 56320) {
        (t2 -= 3) > -1 && a2.push(239, 191, 189), n2 = i2;
        continue;
      }
      i2 = 65536 + (n2 - 55296 << 10 | i2 - 56320);
    } else
      n2 && (t2 -= 3) > -1 && a2.push(239, 191, 189);
    if (n2 = null, i2 < 128) {
      if ((t2 -= 1) < 0)
        break;
      a2.push(i2);
    } else if (i2 < 2048) {
      if ((t2 -= 2) < 0)
        break;
      a2.push(i2 >> 6 | 192, 63 & i2 | 128);
    } else if (i2 < 65536) {
      if ((t2 -= 3) < 0)
        break;
      a2.push(i2 >> 12 | 224, i2 >> 6 & 63 | 128, 63 & i2 | 128);
    } else {
      if (!(i2 < 1114112))
        throw new Error("Invalid code point");
      if ((t2 -= 4) < 0)
        break;
      a2.push(i2 >> 18 | 240, i2 >> 12 & 63 | 128, i2 >> 6 & 63 | 128, 63 & i2 | 128);
    }
  }
  return a2;
}
function asciiToBytes(e4) {
  for (var t2 = [], i2 = 0; i2 < e4.length; ++i2)
    t2.push(255 & e4.charCodeAt(i2));
  return t2;
}
function utf16leToBytes(e4, t2) {
  for (var i2, r2, n2, a2 = [], o2 = 0; o2 < e4.length && !((t2 -= 2) < 0); ++o2)
    r2 = (i2 = e4.charCodeAt(o2)) >> 8, n2 = i2 % 256, a2.push(n2), a2.push(r2);
  return a2;
}
function base64ToBytes(e4) {
  return toByteArray(base64clean(e4));
}
function blitBuffer(e4, t2, i2, r2) {
  for (var n2 = 0; n2 < r2 && !(n2 + i2 >= t2.length || n2 >= e4.length); ++n2)
    t2[n2 + i2] = e4[n2];
  return n2;
}
function isnan(e4) {
  return e4 != e4;
}
function isBuffer(e4) {
  return null != e4 && (!!e4._isBuffer || isFastBuffer(e4) || isSlowBuffer(e4));
}
function isFastBuffer(e4) {
  return !!e4.constructor && "function" == typeof e4.constructor.isBuffer && e4.constructor.isBuffer(e4);
}
function isSlowBuffer(e4) {
  return "function" == typeof e4.readFloatLE && "function" == typeof e4.slice && isFastBuffer(e4.slice(0, 0));
}
!function(e4) {
  e4[e4.BITMAP_INFO_HEADER = 40] = "BITMAP_INFO_HEADER", e4[e4.BITMAP_V2_INFO_HEADER = 52] = "BITMAP_V2_INFO_HEADER", e4[e4.BITMAP_V3_INFO_HEADER = 56] = "BITMAP_V3_INFO_HEADER", e4[e4.BITMAP_V4_HEADER = 108] = "BITMAP_V4_HEADER", e4[e4.BITMAP_V5_HEADER = 124] = "BITMAP_V5_HEADER";
}(HeaderTypes || (HeaderTypes = {}));
var HeaderTypes$1 = HeaderTypes;
var BmpCompression;
function maskColor(e4, t2, i2, r2) {
  const n2 = 1 + ~e4 & e4, a2 = 1 + ~t2 & t2, o2 = 1 + ~i2 & i2, s2 = 1 + ~r2 & r2, l2 = e4 / n2 + 1, u2 = t2 / a2 + 1, h2 = i2 / o2 + 1, c2 = r2 / s2 + 1;
  return { shiftRed: (t3) => (t3 & e4) / n2 * 256 / l2, shiftGreen: (e5) => (e5 & t2) / a2 * 256 / u2, shiftBlue: (e5) => (e5 & i2) / o2 * 256 / h2, shiftAlpha: 0 !== r2 ? (e5) => (e5 & r2) / s2 * 256 / c2 : () => 255 };
}
!function(e4) {
  e4[e4.NONE = 0] = "NONE", e4[e4.BI_RLE8 = 1] = "BI_RLE8", e4[e4.BI_RLE4 = 2] = "BI_RLE4", e4[e4.BI_BIT_FIELDS = 3] = "BI_BIT_FIELDS", e4[e4.BI_ALPHA_BIT_FIELDS = 6] = "BI_ALPHA_BIT_FIELDS";
}(BmpCompression || (BmpCompression = {}));
var BmpDecoder = class {
  constructor(e4, { toRGBA: t2 } = { toRGBA: false }) {
    __publicField(this, "flag");
    __publicField(this, "fileSize");
    __publicField(this, "reserved1");
    __publicField(this, "reserved2");
    __publicField(this, "offset");
    __publicField(this, "headerSize");
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "planes");
    __publicField(this, "bitPP");
    __publicField(this, "compression");
    __publicField(this, "rawSize");
    __publicField(this, "hr");
    __publicField(this, "vr");
    __publicField(this, "colors");
    __publicField(this, "importantColors");
    __publicField(this, "palette");
    __publicField(this, "data");
    __publicField(this, "maskRed");
    __publicField(this, "maskGreen");
    __publicField(this, "maskBlue");
    __publicField(this, "maskAlpha");
    __publicField(this, "toRGBA");
    __publicField(this, "pos");
    __publicField(this, "bottomUp");
    __publicField(this, "buffer");
    __publicField(this, "locRed");
    __publicField(this, "locGreen");
    __publicField(this, "locBlue");
    __publicField(this, "locAlpha");
    __publicField(this, "shiftRed");
    __publicField(this, "shiftGreen");
    __publicField(this, "shiftBlue");
    __publicField(this, "shiftAlpha");
    if (this.buffer = e4, this.toRGBA = !!t2, this.pos = 0, this.bottomUp = true, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), "BM" !== this.flag)
      throw new Error("Invalid BMP File");
    this.locRed = this.toRGBA ? 0 : 3, this.locGreen = this.toRGBA ? 1 : 2, this.locBlue = this.toRGBA ? 2 : 1, this.locAlpha = this.toRGBA ? 3 : 0, this.parseHeader(), this.parseRGBA();
  }
  parseHeader() {
    if (this.fileSize = this.readUInt32LE(), this.reserved1 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.reserved2 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.offset = this.readUInt32LE(), this.headerSize = this.readUInt32LE(), !(this.headerSize in HeaderTypes$1))
      throw new Error(`Unsupported BMP header size ${this.headerSize}`);
    if (this.width = this.readUInt32LE(), this.height = this.readUInt32LE(), this.height = this.height > 2147483647 ? this.height - 4294967296 : this.height, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compression = this.readUInt32LE(), this.rawSize = this.readUInt32LE(), this.hr = this.readUInt32LE(), this.vr = this.readUInt32LE(), this.colors = this.readUInt32LE(), this.importantColors = this.readUInt32LE(), 32 === this.bitPP ? (this.maskAlpha = 0, this.maskRed = 16711680, this.maskGreen = 65280, this.maskBlue = 255) : 16 === this.bitPP && (this.maskAlpha = 0, this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31), (this.headerSize > HeaderTypes$1.BITMAP_INFO_HEADER || this.compression === BmpCompression.BI_BIT_FIELDS || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskRed = this.readUInt32LE(), this.maskGreen = this.readUInt32LE(), this.maskBlue = this.readUInt32LE()), (this.headerSize > HeaderTypes$1.BITMAP_V2_INFO_HEADER || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskAlpha = this.readUInt32LE()), this.headerSize > HeaderTypes$1.BITMAP_V3_INFO_HEADER && (this.pos += HeaderTypes$1.BITMAP_V4_HEADER - HeaderTypes$1.BITMAP_V3_INFO_HEADER), this.headerSize > HeaderTypes$1.BITMAP_V4_HEADER && (this.pos += HeaderTypes$1.BITMAP_V5_HEADER - HeaderTypes$1.BITMAP_V4_HEADER), this.bitPP <= 8 || this.colors > 0) {
      const e5 = 0 === this.colors ? 1 << this.bitPP : this.colors;
      this.palette = new Array(e5);
      for (let t2 = 0; t2 < e5; t2++) {
        const e6 = this.buffer.readUInt8(this.pos++), i2 = this.buffer.readUInt8(this.pos++), r2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++);
        this.palette[t2] = { red: r2, green: i2, blue: e6, quad: n2 };
      }
    }
    this.height < 0 && (this.height *= -1, this.bottomUp = false);
    const e4 = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
    this.shiftRed = e4.shiftRed, this.shiftGreen = e4.shiftGreen, this.shiftBlue = e4.shiftBlue, this.shiftAlpha = e4.shiftAlpha;
  }
  parseRGBA() {
    switch (this.data = Buffer2.alloc(this.width * this.height * 4), this.bitPP) {
      case 1:
        this.bit1();
        break;
      case 4:
        this.bit4();
        break;
      case 8:
        this.bit8();
        break;
      case 16:
        this.bit16();
        break;
      case 24:
        this.bit24();
        break;
      default:
        this.bit32();
    }
  }
  bit1() {
    const e4 = Math.ceil(this.width / 8), t2 = e4 % 4, i2 = 0 !== t2 ? 4 - t2 : 0;
    this.scanImage(i2, e4, (e5, t3) => {
      const i3 = this.buffer.readUInt8(this.pos++), r2 = t3 * this.width * 4 + 8 * e5 * 4;
      for (let t4 = 0; t4 < 8 && 8 * e5 + t4 < this.width; t4++) {
        const e6 = this.palette[i3 >> 7 - t4 & 1];
        this.data[r2 + t4 * this.locAlpha] = 0, this.data[r2 + 4 * t4 + this.locBlue] = e6.blue, this.data[r2 + 4 * t4 + this.locGreen] = e6.green, this.data[r2 + 4 * t4 + this.locRed] = e6.red;
      }
    });
  }
  bit4() {
    if (this.compression === BmpCompression.BI_RLE4) {
      this.data.fill(0);
      let e4 = false, t2 = this.bottomUp ? this.height - 1 : 0, i2 = 0;
      for (; i2 < this.data.length; ) {
        const r2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++);
        if (0 === r2) {
          if (0 === n2) {
            t2 += this.bottomUp ? -1 : 1, i2 = t2 * this.width * 4, e4 = false;
            continue;
          }
          if (1 === n2)
            break;
          if (2 === n2) {
            const e5 = this.buffer.readUInt8(this.pos++), r3 = this.buffer.readUInt8(this.pos++);
            t2 += this.bottomUp ? -r3 : r3, i2 += r3 * this.width * 4 + 4 * e5;
          } else {
            let t3 = this.buffer.readUInt8(this.pos++);
            for (let r3 = 0; r3 < n2; r3++)
              i2 = this.setPixelData(i2, e4 ? 15 & t3 : (240 & t3) >> 4), 1 & r3 && r3 + 1 < n2 && (t3 = this.buffer.readUInt8(this.pos++)), e4 = !e4;
            1 == (n2 + 1 >> 1 & 1) && this.pos++;
          }
        } else
          for (let t3 = 0; t3 < r2; t3++)
            i2 = this.setPixelData(i2, e4 ? 15 & n2 : (240 & n2) >> 4), e4 = !e4;
      }
    } else {
      const e4 = Math.ceil(this.width / 2), t2 = e4 % 4, i2 = 0 !== t2 ? 4 - t2 : 0;
      this.scanImage(i2, e4, (e5, t3) => {
        const i3 = this.buffer.readUInt8(this.pos++), r2 = t3 * this.width * 4 + 2 * e5 * 4, n2 = i3 >> 4;
        let a2 = this.palette[n2];
        if (this.data[r2] = 0, this.data[r2 + 1] = a2.blue, this.data[r2 + 2] = a2.green, this.data[r2 + 3] = a2.red, 2 * e5 + 1 >= this.width)
          return false;
        const o2 = 15 & i3;
        a2 = this.palette[o2], this.data[r2 + 4] = 0, this.data[r2 + 4 + 1] = a2.blue, this.data[r2 + 4 + 2] = a2.green, this.data[r2 + 4 + 3] = a2.red;
      });
    }
  }
  bit8() {
    if (this.compression === BmpCompression.BI_RLE8) {
      this.data.fill(0);
      let e4 = this.bottomUp ? this.height - 1 : 0, t2 = 0;
      for (; t2 < this.data.length; ) {
        const i2 = this.buffer.readUInt8(this.pos++), r2 = this.buffer.readUInt8(this.pos++);
        if (0 === i2) {
          if (0 === r2) {
            e4 += this.bottomUp ? -1 : 1, t2 = e4 * this.width * 4;
            continue;
          }
          if (1 === r2)
            break;
          if (2 === r2) {
            const i3 = this.buffer.readUInt8(this.pos++), r3 = this.buffer.readUInt8(this.pos++);
            e4 += this.bottomUp ? -r3 : r3, t2 += r3 * this.width * 4 + 4 * i3;
          } else {
            for (let e5 = 0; e5 < r2; e5++) {
              const e6 = this.buffer.readUInt8(this.pos++);
              t2 = this.setPixelData(t2, e6);
            }
            true & r2 && this.pos++;
          }
        } else
          for (let e5 = 0; e5 < i2; e5++)
            t2 = this.setPixelData(t2, r2);
      }
    } else {
      const e4 = this.width % 4, t2 = 0 !== e4 ? 4 - e4 : 0;
      this.scanImage(t2, this.width, (e5, t3) => {
        const i2 = this.buffer.readUInt8(this.pos++), r2 = t3 * this.width * 4 + 4 * e5;
        if (i2 < this.palette.length) {
          const e6 = this.palette[i2];
          this.data[r2] = 0, this.data[r2 + 1] = e6.blue, this.data[r2 + 2] = e6.green, this.data[r2 + 3] = e6.red;
        } else
          this.data[r2] = 0, this.data[r2 + 1] = 255, this.data[r2 + 2] = 255, this.data[r2 + 3] = 255;
      });
    }
  }
  bit16() {
    const e4 = this.width % 2 * 2;
    this.scanImage(e4, this.width, (e5, t2) => {
      const i2 = t2 * this.width * 4 + 4 * e5, r2 = this.buffer.readUInt16LE(this.pos);
      this.pos += 2, this.data[i2 + this.locRed] = this.shiftRed(r2), this.data[i2 + this.locGreen] = this.shiftGreen(r2), this.data[i2 + this.locBlue] = this.shiftBlue(r2), this.data[i2 + this.locAlpha] = this.shiftAlpha(r2);
    });
  }
  bit24() {
    const e4 = this.width % 4;
    this.scanImage(e4, this.width, (e5, t2) => {
      const i2 = t2 * this.width * 4 + 4 * e5, r2 = this.buffer.readUInt8(this.pos++), n2 = this.buffer.readUInt8(this.pos++), a2 = this.buffer.readUInt8(this.pos++);
      this.data[i2 + this.locRed] = a2, this.data[i2 + this.locGreen] = n2, this.data[i2 + this.locBlue] = r2, this.data[i2 + this.locAlpha] = 0;
    });
  }
  bit32() {
    this.scanImage(0, this.width, (e4, t2) => {
      const i2 = t2 * this.width * 4 + 4 * e4, r2 = this.readUInt32LE();
      this.data[i2 + this.locRed] = this.shiftRed(r2), this.data[i2 + this.locGreen] = this.shiftGreen(r2), this.data[i2 + this.locBlue] = this.shiftBlue(r2), this.data[i2 + this.locAlpha] = this.shiftAlpha(r2);
    });
  }
  scanImage(e4 = 0, t2 = this.width, i2) {
    for (let r2 = this.height - 1; r2 >= 0; r2--) {
      const n2 = this.bottomUp ? r2 : this.height - 1 - r2;
      for (let e5 = 0; e5 < t2; e5++) {
        if (false === i2.call(this, e5, n2))
          return;
      }
      this.pos += e4;
    }
  }
  readUInt32LE() {
    const e4 = this.buffer.readUInt32LE(this.pos);
    return this.pos += 4, e4;
  }
  setPixelData(e4, t2) {
    const { blue: i2, green: r2, red: n2 } = this.palette[t2];
    return this.data[e4 + this.locAlpha] = 0, this.data[e4 + 1 + this.locBlue] = i2, this.data[e4 + 2 + this.locGreen] = r2, this.data[e4 + 3 + this.locRed] = n2, e4 + 4;
  }
};
function createInteger(e4) {
  return e4.reduce((e5, t2) => e5 << 1 | t2, 0);
}
function createColor(e4) {
  return e4.quad << 24 | e4.red << 16 | e4.green << 8 | e4.blue;
}
var BmpEncoder = class {
  constructor(e4) {
    __publicField(this, "fileSize");
    __publicField(this, "reserved1");
    __publicField(this, "reserved2");
    __publicField(this, "offset");
    __publicField(this, "width");
    __publicField(this, "flag");
    __publicField(this, "height");
    __publicField(this, "planes");
    __publicField(this, "bitPP");
    __publicField(this, "compress");
    __publicField(this, "hr");
    __publicField(this, "vr");
    __publicField(this, "colors");
    __publicField(this, "importantColors");
    __publicField(this, "rawSize");
    __publicField(this, "headerSize");
    __publicField(this, "data");
    __publicField(this, "palette");
    __publicField(this, "extraBytes");
    __publicField(this, "buffer");
    __publicField(this, "bytesInColor");
    __publicField(this, "pos");
    switch (this.buffer = e4.data, this.width = e4.width, this.height = e4.height, this.headerSize = HeaderTypes$1.BITMAP_INFO_HEADER, this.flag = "BM", this.bitPP = e4.bitPP || 24, this.offset = 54, this.reserved1 = e4.reserved1 || 0, this.reserved2 = e4.reserved2 || 0, this.planes = 1, this.compress = 0, this.hr = e4.hr || 0, this.vr = e4.vr || 0, this.importantColors = e4.importantColors || 0, this.colors = Math.min(2 ** (this.bitPP - 1 || 1), e4.colors || 1 / 0), this.palette = e4.palette || [], this.colors && this.bitPP < 16 ? this.offset += 4 * this.colors : this.colors = 0, this.bitPP) {
      case 32:
        this.bytesInColor = 4;
        break;
      case 16:
        this.bytesInColor = 2;
        break;
      case 8:
        this.bytesInColor = 1;
        break;
      case 4:
        this.bytesInColor = 0.5;
        break;
      case 1:
        this.bytesInColor = 1 / 8;
        break;
      default:
        this.bytesInColor = 3, this.bitPP = 24;
    }
    const t2 = this.width * this.bitPP / 32, i2 = Math.ceil(t2);
    this.extraBytes = 4 * (i2 - t2), this.rawSize = this.height * i2 * 4 + 2, this.fileSize = this.rawSize + this.offset, this.data = Buffer2.alloc(this.fileSize, 1), this.pos = 0, this.encode();
  }
  encode() {
    switch (this.pos = 0, this.writeHeader(), this.bitPP) {
      case 32:
        this.bit32();
        break;
      case 16:
        this.bit16();
        break;
      case 8:
        this.bit8();
        break;
      case 4:
        this.bit4();
        break;
      case 1:
        this.bit1();
        break;
      default:
        this.bit24();
    }
  }
  writeHeader() {
    this.data.write(this.flag, this.pos, 2), this.pos += 2, this.writeUInt32LE(this.fileSize), this.writeUInt32LE(this.reserved1 << 16 | this.reserved2), this.writeUInt32LE(this.offset), this.writeUInt32LE(this.headerSize), this.writeUInt32LE(this.width), this.writeUInt32LE(this.height), this.data.writeUInt16LE(this.planes, this.pos), this.pos += 2, this.data.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, this.writeUInt32LE(this.compress), this.writeUInt32LE(this.rawSize), this.writeUInt32LE(this.hr), this.writeUInt32LE(this.vr), this.writeUInt32LE(this.colors), this.writeUInt32LE(this.importantColors);
  }
  bit1() {
    this.palette.length && 2 === this.colors ? this.initColors(1) : (this.writeUInt32LE(16777215), this.writeUInt32LE(0)), this.pos += 1;
    let e4 = [];
    this.writeImage((t2, i2, r2) => {
      let n2 = i2;
      n2++;
      const a2 = this.buffer[n2++], o2 = this.buffer[n2++], s2 = 0.2126 * this.buffer[n2++] + 0.7152 * o2 + 0.0722 * a2;
      return e4.push(s2 > 127 ? 0 : 1), (r2 + 1) % 8 == 0 ? (this.data[t2 - 1] = createInteger(e4), e4 = []) : r2 === this.width - 1 && e4.length > 0 && (this.data[t2 - 1] = createInteger(e4) << 4, e4 = []), n2;
    });
  }
  bit4() {
    const e4 = this.initColors(4);
    let t2 = [];
    this.writeImage((i2, r2, n2) => {
      let a2 = r2;
      const o2 = createColor({ quad: this.buffer[a2++], blue: this.buffer[a2++], green: this.buffer[a2++], red: this.buffer[a2++] }), s2 = e4.findIndex((e5) => e5 === o2);
      return -1 !== s2 ? t2.push(s2) : t2.push(0), (n2 + 1) % 2 == 0 && (this.data[i2] = t2[0] << 4 | t2[1], t2 = []), a2;
    });
  }
  bit8() {
    const e4 = this.initColors(8);
    this.writeImage((t2, i2) => {
      let r2 = i2;
      const n2 = createColor({ quad: this.buffer[r2++], blue: this.buffer[r2++], green: this.buffer[r2++], red: this.buffer[r2++] }), a2 = e4.findIndex((e5) => e5 === n2);
      return this.data[t2] = -1 !== a2 ? a2 : 0, r2;
    });
  }
  bit16() {
    this.writeImage((e4, t2) => {
      let i2 = t2 + 1;
      const r2 = this.buffer[i2++] / 8, n2 = this.buffer[i2++] / 8, a2 = this.buffer[i2++] / 8 << 10 | n2 << 5 | r2;
      return this.data[e4] = 255 & a2, this.data[e4 + 1] = (65280 & a2) >> 8, i2;
    });
  }
  bit24() {
    this.writeImage((e4, t2) => {
      let i2 = t2 + 1;
      return this.data[e4] = this.buffer[i2++], this.data[e4 + 1] = this.buffer[i2++], this.data[e4 + 2] = this.buffer[i2++], i2;
    });
  }
  bit32() {
    this.writeImage((e4, t2) => {
      let i2 = t2;
      return this.data[e4 + 3] = this.buffer[i2++], this.data[e4] = this.buffer[i2++], this.data[e4 + 1] = this.buffer[i2++], this.data[e4 + 2] = this.buffer[i2++], i2;
    });
  }
  writeImage(e4) {
    const t2 = this.extraBytes + this.width * this.bytesInColor;
    let i2 = 0;
    for (let r2 = 0; r2 < this.height; r2++)
      for (let n2 = 0; n2 < this.width; n2++) {
        const a2 = Math.floor(this.pos + (this.height - 1 - r2) * t2 + n2 * this.bytesInColor);
        i2 = e4.call(this, a2, i2, n2, r2);
      }
  }
  initColors(e4) {
    const t2 = [];
    if (!this.palette.length)
      throw new Error(`To encode ${e4}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
    for (let e5 = 0; e5 < this.colors; e5++) {
      const i2 = createColor(this.palette[e5]);
      this.writeUInt32LE(i2), t2.push(i2);
    }
    return t2;
  }
  writeUInt32LE(e4) {
    this.data.writeUInt32LE(e4, this.pos), this.pos += 4;
  }
};
function decode$2(e4, t2) {
  return new BmpDecoder(e4, t2);
}
function encode$2(e4) {
  return new BmpEncoder(e4);
}
function _typeof(e4) {
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
    return typeof e5;
  } : function(e5) {
    return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
  }, _typeof(e4);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(e4, t2) {
  if (t2 = t2 || {}, (e4 = e4 || "") instanceof tinycolor)
    return e4;
  if (!(this instanceof tinycolor))
    return new tinycolor(e4, t2);
  var i2 = inputToRGB(e4);
  this._originalInput = e4, this._r = i2.r, this._g = i2.g, this._b = i2.b, this._a = i2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = t2.format || i2.format, this._gradientType = t2.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i2.ok;
}
function inputToRGB(e4) {
  var t2 = { r: 0, g: 0, b: 0 }, i2 = 1, r2 = null, n2 = null, a2 = null, o2 = false, s2 = false;
  return "string" == typeof e4 && (e4 = stringInputToObject(e4)), "object" == _typeof(e4) && (isValidCSSUnit(e4.r) && isValidCSSUnit(e4.g) && isValidCSSUnit(e4.b) ? (t2 = rgbToRgb(e4.r, e4.g, e4.b), o2 = true, s2 = "%" === String(e4.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(e4.h) && isValidCSSUnit(e4.s) && isValidCSSUnit(e4.v) ? (r2 = convertToPercentage(e4.s), n2 = convertToPercentage(e4.v), t2 = hsvToRgb(e4.h, r2, n2), o2 = true, s2 = "hsv") : isValidCSSUnit(e4.h) && isValidCSSUnit(e4.s) && isValidCSSUnit(e4.l) && (r2 = convertToPercentage(e4.s), a2 = convertToPercentage(e4.l), t2 = hslToRgb(e4.h, r2, a2), o2 = true, s2 = "hsl"), e4.hasOwnProperty("a") && (i2 = e4.a)), i2 = boundAlpha(i2), { ok: o2, format: e4.format || s2, r: Math.min(255, Math.max(t2.r, 0)), g: Math.min(255, Math.max(t2.g, 0)), b: Math.min(255, Math.max(t2.b, 0)), a: i2 };
}
function rgbToRgb(e4, t2, i2) {
  return { r: 255 * bound01(e4, 255), g: 255 * bound01(t2, 255), b: 255 * bound01(i2, 255) };
}
function rgbToHsl(e4, t2, i2) {
  e4 = bound01(e4, 255), t2 = bound01(t2, 255), i2 = bound01(i2, 255);
  var r2, n2, a2 = Math.max(e4, t2, i2), o2 = Math.min(e4, t2, i2), s2 = (a2 + o2) / 2;
  if (a2 == o2)
    r2 = n2 = 0;
  else {
    var l2 = a2 - o2;
    switch (n2 = s2 > 0.5 ? l2 / (2 - a2 - o2) : l2 / (a2 + o2), a2) {
      case e4:
        r2 = (t2 - i2) / l2 + (t2 < i2 ? 6 : 0);
        break;
      case t2:
        r2 = (i2 - e4) / l2 + 2;
        break;
      case i2:
        r2 = (e4 - t2) / l2 + 4;
    }
    r2 /= 6;
  }
  return { h: r2, s: n2, l: s2 };
}
function hslToRgb(e4, t2, i2) {
  var r2, n2, a2;
  function o2(e5, t3, i3) {
    return i3 < 0 && (i3 += 1), i3 > 1 && (i3 -= 1), i3 < 1 / 6 ? e5 + 6 * (t3 - e5) * i3 : i3 < 0.5 ? t3 : i3 < 2 / 3 ? e5 + (t3 - e5) * (2 / 3 - i3) * 6 : e5;
  }
  if (e4 = bound01(e4, 360), t2 = bound01(t2, 100), i2 = bound01(i2, 100), 0 === t2)
    r2 = n2 = a2 = i2;
  else {
    var s2 = i2 < 0.5 ? i2 * (1 + t2) : i2 + t2 - i2 * t2, l2 = 2 * i2 - s2;
    r2 = o2(l2, s2, e4 + 1 / 3), n2 = o2(l2, s2, e4), a2 = o2(l2, s2, e4 - 1 / 3);
  }
  return { r: 255 * r2, g: 255 * n2, b: 255 * a2 };
}
function rgbToHsv(e4, t2, i2) {
  e4 = bound01(e4, 255), t2 = bound01(t2, 255), i2 = bound01(i2, 255);
  var r2, n2, a2 = Math.max(e4, t2, i2), o2 = Math.min(e4, t2, i2), s2 = a2, l2 = a2 - o2;
  if (n2 = 0 === a2 ? 0 : l2 / a2, a2 == o2)
    r2 = 0;
  else {
    switch (a2) {
      case e4:
        r2 = (t2 - i2) / l2 + (t2 < i2 ? 6 : 0);
        break;
      case t2:
        r2 = (i2 - e4) / l2 + 2;
        break;
      case i2:
        r2 = (e4 - t2) / l2 + 4;
    }
    r2 /= 6;
  }
  return { h: r2, s: n2, v: s2 };
}
function hsvToRgb(e4, t2, i2) {
  e4 = 6 * bound01(e4, 360), t2 = bound01(t2, 100), i2 = bound01(i2, 100);
  var r2 = Math.floor(e4), n2 = e4 - r2, a2 = i2 * (1 - t2), o2 = i2 * (1 - n2 * t2), s2 = i2 * (1 - (1 - n2) * t2), l2 = r2 % 6;
  return { r: 255 * [i2, o2, a2, a2, s2, i2][l2], g: 255 * [s2, i2, i2, o2, a2, a2][l2], b: 255 * [a2, a2, s2, i2, i2, o2][l2] };
}
function rgbToHex(e4, t2, i2, r2) {
  var n2 = [pad2(Math.round(e4).toString(16)), pad2(Math.round(t2).toString(16)), pad2(Math.round(i2).toString(16))];
  return r2 && n2[0].charAt(0) == n2[0].charAt(1) && n2[1].charAt(0) == n2[1].charAt(1) && n2[2].charAt(0) == n2[2].charAt(1) ? n2[0].charAt(0) + n2[1].charAt(0) + n2[2].charAt(0) : n2.join("");
}
function rgbaToHex(e4, t2, i2, r2, n2) {
  var a2 = [pad2(Math.round(e4).toString(16)), pad2(Math.round(t2).toString(16)), pad2(Math.round(i2).toString(16)), pad2(convertDecimalToHex(r2))];
  return n2 && a2[0].charAt(0) == a2[0].charAt(1) && a2[1].charAt(0) == a2[1].charAt(1) && a2[2].charAt(0) == a2[2].charAt(1) && a2[3].charAt(0) == a2[3].charAt(1) ? a2[0].charAt(0) + a2[1].charAt(0) + a2[2].charAt(0) + a2[3].charAt(0) : a2.join("");
}
function rgbaToArgbHex(e4, t2, i2, r2) {
  return [pad2(convertDecimalToHex(r2)), pad2(Math.round(e4).toString(16)), pad2(Math.round(t2).toString(16)), pad2(Math.round(i2).toString(16))].join("");
}
function _desaturate(e4, t2) {
  t2 = 0 === t2 ? 0 : t2 || 10;
  var i2 = tinycolor(e4).toHsl();
  return i2.s -= t2 / 100, i2.s = clamp01(i2.s), tinycolor(i2);
}
function _saturate(e4, t2) {
  t2 = 0 === t2 ? 0 : t2 || 10;
  var i2 = tinycolor(e4).toHsl();
  return i2.s += t2 / 100, i2.s = clamp01(i2.s), tinycolor(i2);
}
function _greyscale(e4) {
  return tinycolor(e4).desaturate(100);
}
function _lighten(e4, t2) {
  t2 = 0 === t2 ? 0 : t2 || 10;
  var i2 = tinycolor(e4).toHsl();
  return i2.l += t2 / 100, i2.l = clamp01(i2.l), tinycolor(i2);
}
function _brighten(e4, t2) {
  t2 = 0 === t2 ? 0 : t2 || 10;
  var i2 = tinycolor(e4).toRgb();
  return i2.r = Math.max(0, Math.min(255, i2.r - Math.round(-t2 / 100 * 255))), i2.g = Math.max(0, Math.min(255, i2.g - Math.round(-t2 / 100 * 255))), i2.b = Math.max(0, Math.min(255, i2.b - Math.round(-t2 / 100 * 255))), tinycolor(i2);
}
function _darken(e4, t2) {
  t2 = 0 === t2 ? 0 : t2 || 10;
  var i2 = tinycolor(e4).toHsl();
  return i2.l -= t2 / 100, i2.l = clamp01(i2.l), tinycolor(i2);
}
function _spin(e4, t2) {
  var i2 = tinycolor(e4).toHsl(), r2 = (i2.h + t2) % 360;
  return i2.h = r2 < 0 ? 360 + r2 : r2, tinycolor(i2);
}
function _complement(e4) {
  var t2 = tinycolor(e4).toHsl();
  return t2.h = (t2.h + 180) % 360, tinycolor(t2);
}
function polyad(e4, t2) {
  if (isNaN(t2) || t2 <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var i2 = tinycolor(e4).toHsl(), r2 = [tinycolor(e4)], n2 = 360 / t2, a2 = 1; a2 < t2; a2++)
    r2.push(tinycolor({ h: (i2.h + a2 * n2) % 360, s: i2.s, l: i2.l }));
  return r2;
}
function _splitcomplement(e4) {
  var t2 = tinycolor(e4).toHsl(), i2 = t2.h;
  return [tinycolor(e4), tinycolor({ h: (i2 + 72) % 360, s: t2.s, l: t2.l }), tinycolor({ h: (i2 + 216) % 360, s: t2.s, l: t2.l })];
}
function _analogous(e4, t2, i2) {
  t2 = t2 || 6, i2 = i2 || 30;
  var r2 = tinycolor(e4).toHsl(), n2 = 360 / i2, a2 = [tinycolor(e4)];
  for (r2.h = (r2.h - (n2 * t2 >> 1) + 720) % 360; --t2; )
    r2.h = (r2.h + n2) % 360, a2.push(tinycolor(r2));
  return a2;
}
function _monochromatic(e4, t2) {
  t2 = t2 || 6;
  for (var i2 = tinycolor(e4).toHsv(), r2 = i2.h, n2 = i2.s, a2 = i2.v, o2 = [], s2 = 1 / t2; t2--; )
    o2.push(tinycolor({ h: r2, s: n2, v: a2 })), a2 = (a2 + s2) % 1;
  return o2;
}
tinycolor.prototype = { isDark: function() {
  return this.getBrightness() < 128;
}, isLight: function() {
  return !this.isDark();
}, isValid: function() {
  return this._ok;
}, getOriginalInput: function() {
  return this._originalInput;
}, getFormat: function() {
  return this._format;
}, getAlpha: function() {
  return this._a;
}, getBrightness: function() {
  var e4 = this.toRgb();
  return (299 * e4.r + 587 * e4.g + 114 * e4.b) / 1e3;
}, getLuminance: function() {
  var e4, t2, i2, r2 = this.toRgb();
  return e4 = r2.r / 255, t2 = r2.g / 255, i2 = r2.b / 255, 0.2126 * (e4 <= 0.03928 ? e4 / 12.92 : Math.pow((e4 + 0.055) / 1.055, 2.4)) + 0.7152 * (t2 <= 0.03928 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4)) + 0.0722 * (i2 <= 0.03928 ? i2 / 12.92 : Math.pow((i2 + 0.055) / 1.055, 2.4));
}, setAlpha: function(e4) {
  return this._a = boundAlpha(e4), this._roundA = Math.round(100 * this._a) / 100, this;
}, toHsv: function() {
  var e4 = rgbToHsv(this._r, this._g, this._b);
  return { h: 360 * e4.h, s: e4.s, v: e4.v, a: this._a };
}, toHsvString: function() {
  var e4 = rgbToHsv(this._r, this._g, this._b), t2 = Math.round(360 * e4.h), i2 = Math.round(100 * e4.s), r2 = Math.round(100 * e4.v);
  return 1 == this._a ? "hsv(" + t2 + ", " + i2 + "%, " + r2 + "%)" : "hsva(" + t2 + ", " + i2 + "%, " + r2 + "%, " + this._roundA + ")";
}, toHsl: function() {
  var e4 = rgbToHsl(this._r, this._g, this._b);
  return { h: 360 * e4.h, s: e4.s, l: e4.l, a: this._a };
}, toHslString: function() {
  var e4 = rgbToHsl(this._r, this._g, this._b), t2 = Math.round(360 * e4.h), i2 = Math.round(100 * e4.s), r2 = Math.round(100 * e4.l);
  return 1 == this._a ? "hsl(" + t2 + ", " + i2 + "%, " + r2 + "%)" : "hsla(" + t2 + ", " + i2 + "%, " + r2 + "%, " + this._roundA + ")";
}, toHex: function(e4) {
  return rgbToHex(this._r, this._g, this._b, e4);
}, toHexString: function(e4) {
  return "#" + this.toHex(e4);
}, toHex8: function(e4) {
  return rgbaToHex(this._r, this._g, this._b, this._a, e4);
}, toHex8String: function(e4) {
  return "#" + this.toHex8(e4);
}, toRgb: function() {
  return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
}, toRgbString: function() {
  return 1 == this._a ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
}, toPercentageRgb: function() {
  return { r: Math.round(100 * bound01(this._r, 255)) + "%", g: Math.round(100 * bound01(this._g, 255)) + "%", b: Math.round(100 * bound01(this._b, 255)) + "%", a: this._a };
}, toPercentageRgbString: function() {
  return 1 == this._a ? "rgb(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
}, toName: function() {
  return 0 === this._a ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, true)] || false);
}, toFilter: function(e4) {
  var t2 = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), i2 = t2, r2 = this._gradientType ? "GradientType = 1, " : "";
  if (e4) {
    var n2 = tinycolor(e4);
    i2 = "#" + rgbaToArgbHex(n2._r, n2._g, n2._b, n2._a);
  }
  return "progid:DXImageTransform.Microsoft.gradient(" + r2 + "startColorstr=" + t2 + ",endColorstr=" + i2 + ")";
}, toString: function(e4) {
  var t2 = !!e4;
  e4 = e4 || this._format;
  var i2 = false, r2 = this._a < 1 && this._a >= 0;
  return t2 || !r2 || "hex" !== e4 && "hex6" !== e4 && "hex3" !== e4 && "hex4" !== e4 && "hex8" !== e4 && "name" !== e4 ? ("rgb" === e4 && (i2 = this.toRgbString()), "prgb" === e4 && (i2 = this.toPercentageRgbString()), "hex" !== e4 && "hex6" !== e4 || (i2 = this.toHexString()), "hex3" === e4 && (i2 = this.toHexString(true)), "hex4" === e4 && (i2 = this.toHex8String(true)), "hex8" === e4 && (i2 = this.toHex8String()), "name" === e4 && (i2 = this.toName()), "hsl" === e4 && (i2 = this.toHslString()), "hsv" === e4 && (i2 = this.toHsvString()), i2 || this.toHexString()) : "name" === e4 && 0 === this._a ? this.toName() : this.toRgbString();
}, clone: function() {
  return tinycolor(this.toString());
}, _applyModification: function(e4, t2) {
  var i2 = e4.apply(null, [this].concat([].slice.call(t2)));
  return this._r = i2._r, this._g = i2._g, this._b = i2._b, this.setAlpha(i2._a), this;
}, lighten: function() {
  return this._applyModification(_lighten, arguments);
}, brighten: function() {
  return this._applyModification(_brighten, arguments);
}, darken: function() {
  return this._applyModification(_darken, arguments);
}, desaturate: function() {
  return this._applyModification(_desaturate, arguments);
}, saturate: function() {
  return this._applyModification(_saturate, arguments);
}, greyscale: function() {
  return this._applyModification(_greyscale, arguments);
}, spin: function() {
  return this._applyModification(_spin, arguments);
}, _applyCombination: function(e4, t2) {
  return e4.apply(null, [this].concat([].slice.call(t2)));
}, analogous: function() {
  return this._applyCombination(_analogous, arguments);
}, complement: function() {
  return this._applyCombination(_complement, arguments);
}, monochromatic: function() {
  return this._applyCombination(_monochromatic, arguments);
}, splitcomplement: function() {
  return this._applyCombination(_splitcomplement, arguments);
}, triad: function() {
  return this._applyCombination(polyad, [3]);
}, tetrad: function() {
  return this._applyCombination(polyad, [4]);
} }, tinycolor.fromRatio = function(e4, t2) {
  if ("object" == _typeof(e4)) {
    var i2 = {};
    for (var r2 in e4)
      e4.hasOwnProperty(r2) && (i2[r2] = "a" === r2 ? e4[r2] : convertToPercentage(e4[r2]));
    e4 = i2;
  }
  return tinycolor(e4, t2);
}, tinycolor.equals = function(e4, t2) {
  return !(!e4 || !t2) && tinycolor(e4).toRgbString() == tinycolor(t2).toRgbString();
}, tinycolor.random = function() {
  return tinycolor.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
}, tinycolor.mix = function(e4, t2, i2) {
  i2 = 0 === i2 ? 0 : i2 || 50;
  var r2 = tinycolor(e4).toRgb(), n2 = tinycolor(t2).toRgb(), a2 = i2 / 100;
  return tinycolor({ r: (n2.r - r2.r) * a2 + r2.r, g: (n2.g - r2.g) * a2 + r2.g, b: (n2.b - r2.b) * a2 + r2.b, a: (n2.a - r2.a) * a2 + r2.a });
}, tinycolor.readability = function(e4, t2) {
  var i2 = tinycolor(e4), r2 = tinycolor(t2);
  return (Math.max(i2.getLuminance(), r2.getLuminance()) + 0.05) / (Math.min(i2.getLuminance(), r2.getLuminance()) + 0.05);
}, tinycolor.isReadable = function(e4, t2, i2) {
  var r2, n2, a2 = tinycolor.readability(e4, t2);
  switch (n2 = false, (r2 = validateWCAG2Parms(i2)).level + r2.size) {
    case "AAsmall":
    case "AAAlarge":
      n2 = a2 >= 4.5;
      break;
    case "AAlarge":
      n2 = a2 >= 3;
      break;
    case "AAAsmall":
      n2 = a2 >= 7;
  }
  return n2;
}, tinycolor.mostReadable = function(e4, t2, i2) {
  var r2, n2, a2, o2, s2 = null, l2 = 0;
  n2 = (i2 = i2 || {}).includeFallbackColors, a2 = i2.level, o2 = i2.size;
  for (var u2 = 0; u2 < t2.length; u2++)
    (r2 = tinycolor.readability(e4, t2[u2])) > l2 && (l2 = r2, s2 = tinycolor(t2[u2]));
  return tinycolor.isReadable(e4, s2, { level: a2, size: o2 }) || !n2 ? s2 : (i2.includeFallbackColors = false, tinycolor.mostReadable(e4, ["#fff", "#000"], i2));
};
var names$1 = tinycolor.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
var hexNames = tinycolor.hexNames = flip(names$1);
function flip(e4) {
  var t2 = {};
  for (var i2 in e4)
    e4.hasOwnProperty(i2) && (t2[e4[i2]] = i2);
  return t2;
}
function boundAlpha(e4) {
  return e4 = parseFloat(e4), (isNaN(e4) || e4 < 0 || e4 > 1) && (e4 = 1), e4;
}
function bound01(e4, t2) {
  isOnePointZero(e4) && (e4 = "100%");
  var i2 = isPercentage(e4);
  return e4 = Math.min(t2, Math.max(0, parseFloat(e4))), i2 && (e4 = parseInt(e4 * t2, 10) / 100), Math.abs(e4 - t2) < 1e-6 ? 1 : e4 % t2 / parseFloat(t2);
}
function clamp01(e4) {
  return Math.min(1, Math.max(0, e4));
}
function parseIntFromHex(e4) {
  return parseInt(e4, 16);
}
function isOnePointZero(e4) {
  return "string" == typeof e4 && -1 != e4.indexOf(".") && 1 === parseFloat(e4);
}
function isPercentage(e4) {
  return "string" == typeof e4 && -1 != e4.indexOf("%");
}
function pad2(e4) {
  return 1 == e4.length ? "0" + e4 : "" + e4;
}
function convertToPercentage(e4) {
  return e4 <= 1 && (e4 = 100 * e4 + "%"), e4;
}
function convertDecimalToHex(e4) {
  return Math.round(255 * parseFloat(e4)).toString(16);
}
function convertHexToDecimal(e4) {
  return parseIntFromHex(e4) / 255;
}
var matchers = (CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", { CSS_UNIT: new RegExp(CSS_UNIT), rgb: new RegExp("rgb" + PERMISSIVE_MATCH3), rgba: new RegExp("rgba" + PERMISSIVE_MATCH4), hsl: new RegExp("hsl" + PERMISSIVE_MATCH3), hsla: new RegExp("hsla" + PERMISSIVE_MATCH4), hsv: new RegExp("hsv" + PERMISSIVE_MATCH3), hsva: new RegExp("hsva" + PERMISSIVE_MATCH4), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ });
var CSS_UNIT;
var PERMISSIVE_MATCH3;
var PERMISSIVE_MATCH4;
function isValidCSSUnit(e4) {
  return !!matchers.CSS_UNIT.exec(e4);
}
function stringInputToObject(e4) {
  e4 = e4.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var t2, i2 = false;
  if (names$1[e4])
    e4 = names$1[e4], i2 = true;
  else if ("transparent" == e4)
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  return (t2 = matchers.rgb.exec(e4)) ? { r: t2[1], g: t2[2], b: t2[3] } : (t2 = matchers.rgba.exec(e4)) ? { r: t2[1], g: t2[2], b: t2[3], a: t2[4] } : (t2 = matchers.hsl.exec(e4)) ? { h: t2[1], s: t2[2], l: t2[3] } : (t2 = matchers.hsla.exec(e4)) ? { h: t2[1], s: t2[2], l: t2[3], a: t2[4] } : (t2 = matchers.hsv.exec(e4)) ? { h: t2[1], s: t2[2], v: t2[3] } : (t2 = matchers.hsva.exec(e4)) ? { h: t2[1], s: t2[2], v: t2[3], a: t2[4] } : (t2 = matchers.hex8.exec(e4)) ? { r: parseIntFromHex(t2[1]), g: parseIntFromHex(t2[2]), b: parseIntFromHex(t2[3]), a: convertHexToDecimal(t2[4]), format: i2 ? "name" : "hex8" } : (t2 = matchers.hex6.exec(e4)) ? { r: parseIntFromHex(t2[1]), g: parseIntFromHex(t2[2]), b: parseIntFromHex(t2[3]), format: i2 ? "name" : "hex" } : (t2 = matchers.hex4.exec(e4)) ? { r: parseIntFromHex(t2[1] + "" + t2[1]), g: parseIntFromHex(t2[2] + "" + t2[2]), b: parseIntFromHex(t2[3] + "" + t2[3]), a: convertHexToDecimal(t2[4] + "" + t2[4]), format: i2 ? "name" : "hex8" } : !!(t2 = matchers.hex3.exec(e4)) && { r: parseIntFromHex(t2[1] + "" + t2[1]), g: parseIntFromHex(t2[2] + "" + t2[2]), b: parseIntFromHex(t2[3] + "" + t2[3]), format: i2 ? "name" : "hex" };
}
function validateWCAG2Parms(e4) {
  var t2, i2;
  return "AA" !== (t2 = ((e4 = e4 || { level: "AA", size: "small" }).level || "AA").toUpperCase()) && "AAA" !== t2 && (t2 = "AA"), "small" !== (i2 = (e4.size || "small").toLowerCase()) && "large" !== i2 && (i2 = "small"), { level: t2, size: i2 };
}
function clone(e4) {
  const t2 = { width: e4.bitmap.width, height: e4.bitmap.height, data: Buffer2.from(e4.bitmap.data) };
  return new e4.constructor(t2);
}
function scan(e4, t2, i2, r2, n2, a2) {
  let o2, s2, l2, u2, h2;
  if ("function" == typeof t2)
    h2 = t2, o2 = 0, s2 = 0, l2 = e4.bitmap.width, u2 = e4.bitmap.height;
  else {
    if (o2 = t2, "number" != typeof i2)
      throw new Error("y must be a number");
    if (s2 = i2, "number" != typeof r2)
      throw new Error("w must be a number");
    if (l2 = r2, "number" != typeof n2)
      throw new Error("h must be a number");
    if (u2 = n2, "function" != typeof a2)
      throw new Error("cb must be a function");
    h2 = a2;
  }
  o2 = Math.round(o2), s2 = Math.round(s2), l2 = Math.round(l2), u2 = Math.round(u2);
  const c2 = h2.bind(e4);
  for (let t3 = s2; t3 < s2 + u2; t3++)
    for (let i3 = o2; i3 < o2 + l2; i3++) {
      c2(i3, t3, e4.bitmap.width * t3 + i3 << 2);
    }
  return e4;
}
function* scanIterator(e4, t2, i2, r2, n2) {
  t2 = Math.round(t2), i2 = Math.round(i2), r2 = Math.round(r2), n2 = Math.round(n2);
  for (let a2 = i2; a2 < i2 + n2; a2++)
    for (let i3 = t2; i3 < t2 + r2; i3++) {
      const t3 = e4.bitmap.width * a2 + i3 << 2;
      yield { x: i3, y: a2, idx: t3, image: e4 };
    }
}
function intToRGBA$1(e4) {
  if ("number" != typeof e4)
    throw new Error("i must be a number");
  const t2 = { r: 0, g: 0, b: 0, a: 0 };
  return t2.r = Math.floor(e4 / Math.pow(256, 3)), t2.g = Math.floor((e4 - t2.r * Math.pow(256, 3)) / Math.pow(256, 2)), t2.b = Math.floor((e4 - t2.r * Math.pow(256, 3) - t2.g * Math.pow(256, 2)) / Math.pow(256, 1)), t2.a = Math.floor((e4 - t2.r * Math.pow(256, 3) - t2.g * Math.pow(256, 2) - t2.b * Math.pow(256, 1)) / Math.pow(256, 0)), t2;
}
function rgbaToInt(e4, t2, i2, r2) {
  if ("number" != typeof e4 || "number" != typeof t2 || "number" != typeof i2 || "number" != typeof r2)
    throw new Error("r, g, b and a must be numbers");
  if (e4 < 0 || e4 > 255)
    throw new Error("r must be between 0 and 255");
  if (t2 < 0 || t2 > 255)
    throw new Error("g must be between 0 and 255");
  if (i2 < 0 || i2 > 255)
    throw new Error("b must be between 0 and 255");
  if (r2 < 0 || r2 > 255)
    throw new Error("a must be between 0 and 255");
  let n2 = 255 & e4;
  return n2 <<= 8, n2 |= 255 & t2, n2 <<= 8, n2 |= 255 & i2, n2 <<= 8, n2 |= 255 & r2, n2 >>>= 0, n2;
}
function colorDiff(e4, t2) {
  const i2 = (e5) => Math.pow(e5, 2), { max: r2 } = Math, n2 = "a" in e4 ? e4.a : 255, a2 = "a" in t2 ? t2.a : 255;
  return (r2(i2(e4.r - t2.r), i2(e4.r - t2.r - n2 + a2)) + r2(i2(e4.g - t2.g), i2(e4.g - t2.g - n2 + a2)) + r2(i2(e4.b - t2.b), i2(e4.b - t2.b - n2 + a2))) / 195075;
}
function limit255(e4) {
  return e4 = Math.max(e4, 0), e4 = Math.min(e4, 255);
}
function cssColorToHex(e4) {
  return "number" == typeof e4 ? e4 : parseInt(tinycolor(e4).toHex8(), 16);
}
function encode$1(e4, t2 = {}) {
  return scan({ bitmap: e4 }, 0, 0, e4.width, e4.height, function(t3, i2, r2) {
    const n2 = e4.data[r2 + 0], a2 = e4.data[r2 + 1], o2 = e4.data[r2 + 2], s2 = e4.data[r2 + 3];
    e4.data[r2 + 0] = s2, e4.data[r2 + 1] = o2, e4.data[r2 + 2] = a2, e4.data[r2 + 3] = n2;
  }), encode$2({ ...e4, ...t2 }).data;
}
function decode$1(e4, t2) {
  const i2 = decode$2(e4, t2);
  return scan({ bitmap: i2 }, 0, 0, i2.width, i2.height, function(e5, t3, r2) {
    const n2 = i2.data[r2 + 1], a2 = i2.data[r2 + 2], o2 = i2.data[r2 + 3];
    i2.data[r2 + 0] = o2, i2.data[r2 + 1] = a2, i2.data[r2 + 2] = n2, i2.data[r2 + 3] = 255;
  }), i2;
}
function msBmp() {
  return { mime: "image/x-ms-bmp", encode: encode$1, decode: decode$1 };
}
function bmp() {
  return { mime: "image/bmp", encode: encode$1, decode: decode$1 };
}
var omggif = {};
var GifReader_1;
var GifWriter_1;
function GifWriter(e4, t2, i2, r2) {
  var n2 = 0, a2 = void 0 === (r2 = void 0 === r2 ? {} : r2).loop ? null : r2.loop, o2 = void 0 === r2.palette ? null : r2.palette;
  if (t2 <= 0 || i2 <= 0 || t2 > 65535 || i2 > 65535)
    throw new Error("Width/Height invalid.");
  function s2(e5) {
    var t3 = e5.length;
    if (t3 < 2 || t3 > 256 || t3 & t3 - 1)
      throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
    return t3;
  }
  e4[n2++] = 71, e4[n2++] = 73, e4[n2++] = 70, e4[n2++] = 56, e4[n2++] = 57, e4[n2++] = 97;
  var l2 = 0, u2 = 0;
  if (null !== o2) {
    for (var h2 = s2(o2); h2 >>= 1; )
      ++l2;
    if (h2 = 1 << l2, --l2, void 0 !== r2.background) {
      if ((u2 = r2.background) >= h2)
        throw new Error("Background index out of range.");
      if (0 === u2)
        throw new Error("Background index explicitly passed as 0.");
    }
  }
  if (e4[n2++] = 255 & t2, e4[n2++] = t2 >> 8 & 255, e4[n2++] = 255 & i2, e4[n2++] = i2 >> 8 & 255, e4[n2++] = (null !== o2 ? 128 : 0) | l2, e4[n2++] = u2, e4[n2++] = 0, null !== o2)
    for (var c2 = 0, f2 = o2.length; c2 < f2; ++c2) {
      var d = o2[c2];
      e4[n2++] = d >> 16 & 255, e4[n2++] = d >> 8 & 255, e4[n2++] = 255 & d;
    }
  if (null !== a2) {
    if (a2 < 0 || a2 > 65535)
      throw new Error("Loop count invalid.");
    e4[n2++] = 33, e4[n2++] = 255, e4[n2++] = 11, e4[n2++] = 78, e4[n2++] = 69, e4[n2++] = 84, e4[n2++] = 83, e4[n2++] = 67, e4[n2++] = 65, e4[n2++] = 80, e4[n2++] = 69, e4[n2++] = 50, e4[n2++] = 46, e4[n2++] = 48, e4[n2++] = 3, e4[n2++] = 1, e4[n2++] = 255 & a2, e4[n2++] = a2 >> 8 & 255, e4[n2++] = 0;
  }
  var p2 = false;
  this.addFrame = function(t3, i3, r3, a3, l3, u3) {
    if (true === p2 && (--n2, p2 = false), u3 = void 0 === u3 ? {} : u3, t3 < 0 || i3 < 0 || t3 > 65535 || i3 > 65535)
      throw new Error("x/y invalid.");
    if (r3 <= 0 || a3 <= 0 || r3 > 65535 || a3 > 65535)
      throw new Error("Width/Height invalid.");
    if (l3.length < r3 * a3)
      throw new Error("Not enough pixels for the frame size.");
    var h3 = true, c3 = u3.palette;
    if (null == c3 && (h3 = false, c3 = o2), null == c3)
      throw new Error("Must supply either a local or global palette.");
    for (var f3 = s2(c3), d2 = 0; f3 >>= 1; )
      ++d2;
    f3 = 1 << d2;
    var m = void 0 === u3.delay ? 0 : u3.delay, _2 = void 0 === u3.disposal ? 0 : u3.disposal;
    if (_2 < 0 || _2 > 3)
      throw new Error("Disposal out of range.");
    var g = false, b2 = 0;
    if (void 0 !== u3.transparent && null !== u3.transparent && (g = true, (b2 = u3.transparent) < 0 || b2 >= f3))
      throw new Error("Transparent color index.");
    if ((0 !== _2 || g || 0 !== m) && (e4[n2++] = 33, e4[n2++] = 249, e4[n2++] = 4, e4[n2++] = _2 << 2 | (true === g ? 1 : 0), e4[n2++] = 255 & m, e4[n2++] = m >> 8 & 255, e4[n2++] = b2, e4[n2++] = 0), e4[n2++] = 44, e4[n2++] = 255 & t3, e4[n2++] = t3 >> 8 & 255, e4[n2++] = 255 & i3, e4[n2++] = i3 >> 8 & 255, e4[n2++] = 255 & r3, e4[n2++] = r3 >> 8 & 255, e4[n2++] = 255 & a3, e4[n2++] = a3 >> 8 & 255, e4[n2++] = true === h3 ? 128 | d2 - 1 : 0, true === h3)
      for (var y2 = 0, w = c3.length; y2 < w; ++y2) {
        var v2 = c3[y2];
        e4[n2++] = v2 >> 16 & 255, e4[n2++] = v2 >> 8 & 255, e4[n2++] = 255 & v2;
      }
    return n2 = GifWriterOutputLZWCodeStream(e4, n2, d2 < 2 ? 2 : d2, l3);
  }, this.end = function() {
    return false === p2 && (e4[n2++] = 59, p2 = true), n2;
  }, this.getOutputBuffer = function() {
    return e4;
  }, this.setOutputBuffer = function(t3) {
    e4 = t3;
  }, this.getOutputBufferPosition = function() {
    return n2;
  }, this.setOutputBufferPosition = function(e5) {
    n2 = e5;
  };
}
function GifWriterOutputLZWCodeStream(e4, t2, i2, r2) {
  e4[t2++] = i2;
  var n2 = t2++, a2 = 1 << i2, o2 = a2 - 1, s2 = a2 + 1, l2 = s2 + 1, u2 = i2 + 1, h2 = 0, c2 = 0;
  function f2(i3) {
    for (; h2 >= i3; )
      e4[t2++] = 255 & c2, c2 >>= 8, h2 -= 8, t2 === n2 + 256 && (e4[n2] = 255, n2 = t2++);
  }
  function d(e5) {
    c2 |= e5 << h2, h2 += u2, f2(8);
  }
  var p2 = r2[0] & o2, m = {};
  d(a2);
  for (var _2 = 1, g = r2.length; _2 < g; ++_2) {
    var b2 = r2[_2] & o2, y2 = p2 << 8 | b2, w = m[y2];
    if (void 0 === w) {
      for (c2 |= p2 << h2, h2 += u2; h2 >= 8; )
        e4[t2++] = 255 & c2, c2 >>= 8, h2 -= 8, t2 === n2 + 256 && (e4[n2] = 255, n2 = t2++);
      4096 === l2 ? (d(a2), l2 = s2 + 1, u2 = i2 + 1, m = {}) : (l2 >= 1 << u2 && ++u2, m[y2] = l2++), p2 = b2;
    } else
      p2 = w;
  }
  return d(p2), d(s2), f2(1), n2 + 1 === t2 ? e4[n2] = 0 : (e4[n2] = t2 - n2 - 1, e4[t2++] = 0), t2;
}
function GifReader(e4) {
  var t2 = 0;
  if (71 !== e4[t2++] || 73 !== e4[t2++] || 70 !== e4[t2++] || 56 !== e4[t2++] || 56 != (e4[t2++] + 1 & 253) || 97 !== e4[t2++])
    throw new Error("Invalid GIF 87a/89a header.");
  var i2 = e4[t2++] | e4[t2++] << 8, r2 = e4[t2++] | e4[t2++] << 8, n2 = e4[t2++], a2 = n2 >> 7, o2 = 1 << (7 & n2) + 1;
  e4[t2++], e4[t2++];
  var s2 = null, l2 = null;
  a2 && (s2 = t2, l2 = o2, t2 += 3 * o2);
  var u2 = true, h2 = [], c2 = 0, f2 = null, d = 0, p2 = null;
  for (this.width = i2, this.height = r2; u2 && t2 < e4.length; )
    switch (e4[t2++]) {
      case 33:
        switch (e4[t2++]) {
          case 255:
            if (11 !== e4[t2] || 78 == e4[t2 + 1] && 69 == e4[t2 + 2] && 84 == e4[t2 + 3] && 83 == e4[t2 + 4] && 67 == e4[t2 + 5] && 65 == e4[t2 + 6] && 80 == e4[t2 + 7] && 69 == e4[t2 + 8] && 50 == e4[t2 + 9] && 46 == e4[t2 + 10] && 48 == e4[t2 + 11] && 3 == e4[t2 + 12] && 1 == e4[t2 + 13] && 0 == e4[t2 + 16])
              t2 += 14, p2 = e4[t2++] | e4[t2++] << 8, t2++;
            else
              for (t2 += 12; ; ) {
                if (!((I = e4[t2++]) >= 0))
                  throw Error("Invalid block size");
                if (0 === I)
                  break;
                t2 += I;
              }
            break;
          case 249:
            if (4 !== e4[t2++] || 0 !== e4[t2 + 4])
              throw new Error("Invalid graphics extension block.");
            var m = e4[t2++];
            c2 = e4[t2++] | e4[t2++] << 8, f2 = e4[t2++], 1 & m || (f2 = null), d = m >> 2 & 7, t2++;
            break;
          case 254:
            for (; ; ) {
              if (!((I = e4[t2++]) >= 0))
                throw Error("Invalid block size");
              if (0 === I)
                break;
              t2 += I;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + e4[t2 - 1].toString(16));
        }
        break;
      case 44:
        var _2 = e4[t2++] | e4[t2++] << 8, g = e4[t2++] | e4[t2++] << 8, b2 = e4[t2++] | e4[t2++] << 8, y2 = e4[t2++] | e4[t2++] << 8, w = e4[t2++], v2 = w >> 6 & 1, x2 = 1 << (7 & w) + 1, E2 = s2, k2 = l2, S2 = false;
        if (w >> 7) {
          S2 = true;
          E2 = t2, k2 = x2, t2 += 3 * x2;
        }
        var A2 = t2;
        for (t2++; ; ) {
          var I;
          if (!((I = e4[t2++]) >= 0))
            throw Error("Invalid block size");
          if (0 === I)
            break;
          t2 += I;
        }
        h2.push({ x: _2, y: g, width: b2, height: y2, has_local_palette: S2, palette_offset: E2, palette_size: k2, data_offset: A2, data_length: t2 - A2, transparent_index: f2, interlaced: !!v2, delay: c2, disposal: d });
        break;
      case 59:
        u2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + e4[t2 - 1].toString(16));
    }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(e5) {
    if (e5 < 0 || e5 >= h2.length)
      throw new Error("Frame index out of range.");
    return h2[e5];
  }, this.decodeAndBlitFrameBGRA = function(t3, r3) {
    var n3 = this.frameInfo(t3), a3 = n3.width * n3.height, o3 = new Uint8Array(a3);
    GifReaderLZWOutputIndexStream(e4, n3.data_offset, o3, a3);
    var s3 = n3.palette_offset, l3 = n3.transparent_index;
    null === l3 && (l3 = 256);
    var u3 = n3.width, h3 = i2 - u3, c3 = u3, f3 = 4 * (n3.y * i2 + n3.x), d2 = 4 * ((n3.y + n3.height) * i2 + n3.x), p3 = f3, m2 = 4 * h3;
    true === n3.interlaced && (m2 += 4 * i2 * 7);
    for (var _3 = 8, g2 = 0, b3 = o3.length; g2 < b3; ++g2) {
      var y3 = o3[g2];
      if (0 === c3 && (c3 = u3, (p3 += m2) >= d2 && (m2 = 4 * h3 + 4 * i2 * (_3 - 1), p3 = f3 + (u3 + h3) * (_3 << 1), _3 >>= 1)), y3 === l3)
        p3 += 4;
      else {
        var w2 = e4[s3 + 3 * y3], v3 = e4[s3 + 3 * y3 + 1], x3 = e4[s3 + 3 * y3 + 2];
        r3[p3++] = x3, r3[p3++] = v3, r3[p3++] = w2, r3[p3++] = 255;
      }
      --c3;
    }
  }, this.decodeAndBlitFrameRGBA = function(t3, r3) {
    var n3 = this.frameInfo(t3), a3 = n3.width * n3.height, o3 = new Uint8Array(a3);
    GifReaderLZWOutputIndexStream(e4, n3.data_offset, o3, a3);
    var s3 = n3.palette_offset, l3 = n3.transparent_index;
    null === l3 && (l3 = 256);
    var u3 = n3.width, h3 = i2 - u3, c3 = u3, f3 = 4 * (n3.y * i2 + n3.x), d2 = 4 * ((n3.y + n3.height) * i2 + n3.x), p3 = f3, m2 = 4 * h3;
    true === n3.interlaced && (m2 += 4 * i2 * 7);
    for (var _3 = 8, g2 = 0, b3 = o3.length; g2 < b3; ++g2) {
      var y3 = o3[g2];
      if (0 === c3 && (c3 = u3, (p3 += m2) >= d2 && (m2 = 4 * h3 + 4 * i2 * (_3 - 1), p3 = f3 + (u3 + h3) * (_3 << 1), _3 >>= 1)), y3 === l3)
        p3 += 4;
      else {
        var w2 = e4[s3 + 3 * y3], v3 = e4[s3 + 3 * y3 + 1], x3 = e4[s3 + 3 * y3 + 2];
        r3[p3++] = w2, r3[p3++] = v3, r3[p3++] = x3, r3[p3++] = 255;
      }
      --c3;
    }
  };
}
function GifReaderLZWOutputIndexStream(e4, t2, i2, r2) {
  for (var n2 = e4[t2++], a2 = 1 << n2, o2 = a2 + 1, s2 = o2 + 1, l2 = n2 + 1, u2 = (1 << l2) - 1, h2 = 0, c2 = 0, f2 = 0, d = e4[t2++], p2 = new Int32Array(4096), m = null; ; ) {
    for (; h2 < 16 && 0 !== d; )
      c2 |= e4[t2++] << h2, h2 += 8, 1 === d ? d = e4[t2++] : --d;
    if (h2 < l2)
      break;
    var _2 = c2 & u2;
    if (c2 >>= l2, h2 -= l2, _2 !== a2) {
      if (_2 === o2)
        break;
      for (var g = _2 < s2 ? _2 : m, b2 = 0, y2 = g; y2 > a2; )
        y2 = p2[y2] >> 8, ++b2;
      var w = y2;
      if (f2 + b2 + (g !== _2 ? 1 : 0) > r2)
        return void console.log("Warning, gif stream longer than expected.");
      i2[f2++] = w;
      var v2 = f2 += b2;
      for (g !== _2 && (i2[f2++] = w), y2 = g; b2--; )
        y2 = p2[y2], i2[--v2] = 255 & y2, y2 >>= 8;
      null !== m && s2 < 4096 && (p2[s2++] = m << 8 | w, s2 >= u2 + 1 && l2 < 12 && (++l2, u2 = u2 << 1 | 1)), m = _2;
    } else
      s2 = o2 + 1, u2 = (1 << (l2 = n2 + 1)) - 1, m = null;
  }
  return f2 !== r2 && console.log("Warning, gif stream shorter than expected."), i2;
}
try {
  GifWriter_1 = omggif.GifWriter = GifWriter, GifReader_1 = omggif.GifReader = GifReader;
} catch (e4) {
}
var BitmapImage$2 = class e {
  constructor(...t2) {
    if (0 === t2.length)
      throw new Error("constructor requires parameters");
    const i2 = t2[0];
    if (null !== i2 && "object" == typeof i2)
      if (i2 instanceof e) {
        const e4 = i2.bitmap;
        this.bitmap = { width: e4.width, height: e4.height, data: new Buffer2(e4.width * e4.height * 4) }, e4.data.copy(this.bitmap.data);
      } else {
        if (!(i2.width && i2.height && i2.data))
          throw new Error("unrecognized constructor parameters");
        this.bitmap = i2;
      }
    else {
      if ("number" != typeof i2 || "number" != typeof t2[1])
        throw new Error("unrecognized constructor parameters");
      {
        const e4 = i2, r2 = t2[1], n2 = t2[2];
        this.bitmap = { width: e4, height: r2 }, Buffer2.isBuffer(n2) ? this.bitmap.data = n2 : (this.bitmap.data = new Buffer2(e4 * r2 * 4), "number" == typeof n2 && this.fillRGBA(n2));
      }
    }
  }
  blit(e4, t2, i2, r2, n2, a2, o2) {
    if (r2 + a2 > this.bitmap.width)
      throw new Error("copy exceeds width of source bitmap");
    if (t2 + a2 > e4.bitmap.width)
      throw new Error("copy exceeds width of target bitmap");
    if (n2 + o2 > this.bitmap.height)
      throw new Error("copy exceeds height of source bitmap");
    if (i2 + o2 > e4.bitmap.height)
      throw new Erro("copy exceeds height of target bitmap");
    const s2 = this.bitmap.data, l2 = e4.bitmap.data, u2 = 4 * this.bitmap.width, h2 = 4 * e4.bitmap.width, c2 = 4 * a2;
    let f2 = n2 * u2 + 4 * r2, d = i2 * h2 + 4 * t2;
    for (; --o2 >= 0; )
      s2.copy(l2, d, f2, f2 + c2), f2 += u2, d += h2;
    return this;
  }
  fillRGBA(e4) {
    const t2 = this.bitmap.data, i2 = 4 * this.bitmap.height;
    let r2 = 0;
    for (; r2 < i2; )
      t2.writeUInt32BE(e4, r2), r2 += 4;
    for (; r2 < t2.length; )
      t2.copy(t2, r2, 0, i2), r2 += i2;
    return this;
  }
  getRGBA(e4, t2) {
    const i2 = 4 * (t2 * this.bitmap.width + e4);
    return this.bitmap.data.readUInt32BE(i2);
  }
  getRGBASet() {
    const e4 = /* @__PURE__ */ new Set(), t2 = this.bitmap.data;
    for (let i2 = 0; i2 < t2.length; i2 += 4)
      e4.add(t2.readUInt32BE(i2, true));
    return e4;
  }
  greyscale() {
    const e4 = this.bitmap.data;
    return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (t2, i2, r2) => {
      const n2 = Math.round(0.299 * e4[r2] + 0.587 * e4[r2 + 1] + 0.114 * e4[r2 + 2]);
      e4[r2] = n2, e4[r2 + 1] = n2, e4[r2 + 2] = n2;
    }), this;
  }
  reframe(t2, i2, r2, n2, a2) {
    const o2 = t2 < 0 ? 0 : t2, s2 = i2 < 0 ? 0 : i2, l2 = r2 + o2 > this.bitmap.width ? this.bitmap.width - o2 : r2, u2 = n2 + s2 > this.bitmap.height ? this.bitmap.height - s2 : n2, h2 = t2 < 0 ? -t2 : 0, c2 = i2 < 0 ? -i2 : 0;
    let f2;
    if (void 0 === a2) {
      if (o2 !== t2 || s2 != i2 || l2 !== r2 || u2 !== n2)
        throw new GifError("fillRGBA required for this reframing");
      f2 = new e(r2, n2);
    } else
      f2 = new e(r2, n2, a2);
    return this.blit(f2, h2, c2, o2, s2, l2, u2), this.bitmap = f2.bitmap, this;
  }
  scale(e4) {
    if (1 === e4)
      return;
    if (!Number.isInteger(e4) || e4 < 1)
      throw new Error("the scale must be an integer >= 1");
    const t2 = this.bitmap.width, i2 = this.bitmap.height, r2 = t2 * e4 * 4, n2 = this.bitmap.data, a2 = new Buffer2(i2 * r2 * e4);
    let o2, s2 = 0, l2 = 0;
    for (let u2 = 0; u2 < i2; ++u2) {
      o2 = l2;
      for (let i3 = 0; i3 < t2; ++i3) {
        const t3 = n2.readUInt32BE(s2, true);
        for (let i4 = 0; i4 < e4; ++i4)
          a2.writeUInt32BE(t3, l2), l2 += 4;
        s2 += 4;
      }
      for (let t3 = 1; t3 < e4; ++t3)
        a2.copy(a2, l2, o2, l2), l2 += r2, o2 += r2;
    }
    return this.bitmap = { width: t2 * e4, height: i2 * e4, data: a2 }, this;
  }
  scanAllCoords(e4) {
    const t2 = this.bitmap.width, i2 = this.bitmap.data.length;
    let r2 = 0, n2 = 0;
    for (let a2 = 0; a2 < i2; a2 += 4)
      e4(r2, n2, a2), ++r2 === t2 && (r2 = 0, ++n2);
  }
  scanAllIndexes(e4) {
    const t2 = this.bitmap.data.length;
    for (let i2 = 0; i2 < t2; i2 += 4)
      e4(i2);
  }
};
var bitmapimage = BitmapImage$2;
var gif$1 = {};
var Gif$1 = class {
  constructor(e4, t2, i2) {
    this.width = i2.width, this.height = i2.height, this.loops = i2.loops, this.usesTransparency = i2.usesTransparency, this.colorScope = i2.colorScope, this.frames = t2, this.buffer = e4;
  }
};
Gif$1.GlobalColorsPreferred = 0, Gif$1.GlobalColorsOnly = 1, Gif$1.LocalColorsOnly = 2;
var GifError$2 = class extends Error {
  constructor(e4) {
    super(e4), e4 instanceof Error && (this.stack = "Gif" + e4.stack);
  }
};
gif$1.Gif = Gif$1, gif$1.GifError = GifError$2;
var gifcodec = {};
var gifutil = {};
var _polyfillNode_fs = {};
var _polyfillNode_fs$1 = Object.freeze({ __proto__: null, default: _polyfillNode_fs });
var require$$0 = getAugmentedNamespace(_polyfillNode_fs$1);
var __defProp$3 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __defNormalProp$3 = (e4, t2, i2) => t2 in e4 ? __defProp$3(e4, t2, { enumerable: true, configurable: true, writable: true, value: i2 }) : e4[t2] = i2;
var __markAsModule = (e4) => __defProp$3(e4, "__esModule", { value: true });
var __export$1 = (e4, t2) => {
  for (var i2 in t2)
    __defProp$3(e4, i2, { get: t2[i2], enumerable: true });
};
var __reExport = (e4, t2, i2, r2) => {
  if (t2 && "object" == typeof t2 || "function" == typeof t2)
    for (let n2 of __getOwnPropNames2(t2))
      !__hasOwnProp2.call(e4, n2) && i2 && __defProp$3(e4, n2, { get: () => t2[n2], enumerable: !(r2 = __getOwnPropDesc2(t2, n2)) || r2.enumerable });
  return e4;
};
var __toCommonJS2 = ((e4) => (t2, i2) => e4 && e4.get(t2) || (i2 = __reExport(__markAsModule({}), t2, 1), e4 && e4.set(t2, i2), i2))("undefined" != typeof WeakMap ? /* @__PURE__ */ new WeakMap() : 0);
var __publicField$3 = (e4, t2, i2) => (__defNormalProp$3(e4, "symbol" != typeof t2 ? t2 + "" : t2, i2), i2);
var src_exports = {};
__export$1(src_exports, { applyPalette: () => applyPalette, applyPaletteSync: () => applyPaletteSync$1, buildPalette: () => buildPalette, buildPaletteSync: () => buildPaletteSync$1, constants: () => constants_exports$1, conversion: () => conversion_exports$1, distance: () => distance_exports$1, image: () => image_exports$1, palette: () => palette_exports$1, quality: () => quality_exports$1, utils: () => utils_exports$1 });
var constants_exports$1 = {};
__export$1(constants_exports$1, { bt709: () => bt709_exports$1 });
var bt709_exports$1 = {};
__export$1(bt709_exports$1, { Y: () => Y$1, x: () => x$2, y: () => y$2 });
var Y$1 = ((e4) => (e4[e4.RED = 0.2126] = "RED", e4[e4.GREEN = 0.7152] = "GREEN", e4[e4.BLUE = 0.0722] = "BLUE", e4[e4.WHITE = 1] = "WHITE", e4))(Y$1 || {});
var x$2 = ((e4) => (e4[e4.RED = 0.64] = "RED", e4[e4.GREEN = 0.3] = "GREEN", e4[e4.BLUE = 0.15] = "BLUE", e4[e4.WHITE = 0.3127] = "WHITE", e4))(x$2 || {});
var y$2 = ((e4) => (e4[e4.RED = 0.33] = "RED", e4[e4.GREEN = 0.6] = "GREEN", e4[e4.BLUE = 0.06] = "BLUE", e4[e4.WHITE = 0.329] = "WHITE", e4))(y$2 || {});
var conversion_exports$1 = {};
function correctGamma$1(e4) {
  return e4 > 0.04045 ? ((e4 + 0.055) / 1.055) ** 2.4 : e4 / 12.92;
}
function rgb2xyz$1(e4, t2, i2) {
  return { x: 0.4124 * (e4 = correctGamma$1(e4 / 255)) + 0.3576 * (t2 = correctGamma$1(t2 / 255)) + 0.1805 * (i2 = correctGamma$1(i2 / 255)), y: 0.2126 * e4 + 0.7152 * t2 + 0.0722 * i2, z: 0.0193 * e4 + 0.1192 * t2 + 0.9505 * i2 };
}
__export$1(conversion_exports$1, { lab2rgb: () => lab2rgb$1, lab2xyz: () => lab2xyz$1, rgb2hsl: () => rgb2hsl$1, rgb2lab: () => rgb2lab$1, rgb2xyz: () => rgb2xyz$1, xyz2lab: () => xyz2lab$1, xyz2rgb: () => xyz2rgb$1 });
var arithmetic_exports$1 = {};
function degrees2radians$1(e4) {
  return e4 * (Math.PI / 180);
}
function max3$1(e4, t2, i2) {
  let r2 = e4;
  return r2 < t2 && (r2 = t2), r2 < i2 && (r2 = i2), r2;
}
function min3$1(e4, t2, i2) {
  let r2 = e4;
  return r2 > t2 && (r2 = t2), r2 > i2 && (r2 = i2), r2;
}
function intInRange$1(e4, t2, i2) {
  return e4 > i2 && (e4 = i2), e4 < t2 && (e4 = t2), 0 | e4;
}
function inRange0to255Rounded$1(e4) {
  return (e4 = Math.round(e4)) > 255 ? e4 = 255 : e4 < 0 && (e4 = 0), e4;
}
function inRange0to255$1(e4) {
  return e4 > 255 ? e4 = 255 : e4 < 0 && (e4 = 0), e4;
}
function stableSort$1(e4, t2) {
  const i2 = typeof e4[0];
  let r2;
  if ("number" === i2 || "string" === i2) {
    const i3 = /* @__PURE__ */ Object.create(null);
    for (let t3 = 0, r3 = e4.length; t3 < r3; t3++) {
      const r4 = e4[t3];
      i3[r4] || 0 === i3[r4] || (i3[r4] = t3);
    }
    r2 = e4.sort((e5, r3) => t2(e5, r3) || i3[e5] - i3[r3]);
  } else {
    const i3 = e4.slice(0);
    r2 = e4.sort((e5, r3) => t2(e5, r3) || i3.indexOf(e5) - i3.indexOf(r3));
  }
  return r2;
}
function rgb2hsl$1(e4, t2, i2) {
  const r2 = min3$1(e4, t2, i2), n2 = max3$1(e4, t2, i2), a2 = n2 - r2, o2 = (r2 + n2) / 510;
  let s2 = 0;
  o2 > 0 && o2 < 1 && (s2 = a2 / (o2 < 0.5 ? n2 + r2 : 510 - n2 - r2));
  let l2 = 0;
  return a2 > 0 && (l2 = n2 === e4 ? (t2 - i2) / a2 : n2 === t2 ? 2 + (i2 - e4) / a2 : 4 + (e4 - t2) / a2, l2 *= 60, l2 < 0 && (l2 += 360)), { h: l2, s: s2, l: o2 };
}
__export$1(arithmetic_exports$1, { degrees2radians: () => degrees2radians$1, inRange0to255: () => inRange0to255$1, inRange0to255Rounded: () => inRange0to255Rounded$1, intInRange: () => intInRange$1, max3: () => max3$1, min3: () => min3$1, stableSort: () => stableSort$1 });
var refX$1 = 0.95047;
var refY$1 = 1;
var refZ$1 = 1.08883;
function pivot$1(e4) {
  return e4 > 8856e-6 ? e4 ** (1 / 3) : 7.787 * e4 + 16 / 116;
}
function xyz2lab$1(e4, t2, i2) {
  if (e4 = pivot$1(e4 / refX$1), t2 = pivot$1(t2 / refY$1), i2 = pivot$1(i2 / refZ$1), 116 * t2 - 16 < 0)
    throw new Error("xxx");
  return { L: Math.max(0, 116 * t2 - 16), a: 500 * (e4 - t2), b: 200 * (t2 - i2) };
}
function rgb2lab$1(e4, t2, i2) {
  const r2 = rgb2xyz$1(e4, t2, i2);
  return xyz2lab$1(r2.x, r2.y, r2.z);
}
var refX2$1 = 0.95047;
var refY2$1 = 1;
var refZ2$1 = 1.08883;
function pivot2$1(e4) {
  return e4 > 0.206893034 ? e4 ** 3 : (e4 - 16 / 116) / 7.787;
}
function lab2xyz$1(e4, t2, i2) {
  const r2 = (e4 + 16) / 116, n2 = r2 - i2 / 200;
  return { x: refX2$1 * pivot2$1(t2 / 500 + r2), y: refY2$1 * pivot2$1(r2), z: refZ2$1 * pivot2$1(n2) };
}
function correctGamma2$1(e4) {
  return e4 > 31308e-7 ? 1.055 * e4 ** (1 / 2.4) - 0.055 : 12.92 * e4;
}
function xyz2rgb$1(e4, t2, i2) {
  const r2 = correctGamma2$1(3.2406 * e4 + -1.5372 * t2 + -0.4986 * i2), n2 = correctGamma2$1(-0.9689 * e4 + 1.8758 * t2 + 0.0415 * i2), a2 = correctGamma2$1(0.0557 * e4 + -0.204 * t2 + 1.057 * i2);
  return { r: inRange0to255Rounded$1(255 * r2), g: inRange0to255Rounded$1(255 * n2), b: inRange0to255Rounded$1(255 * a2) };
}
function lab2rgb$1(e4, t2, i2) {
  const r2 = lab2xyz$1(e4, t2, i2);
  return xyz2rgb$1(r2.x, r2.y, r2.z);
}
var distance_exports$1 = {};
__export$1(distance_exports$1, { AbstractDistanceCalculator: () => AbstractDistanceCalculator$1, AbstractEuclidean: () => AbstractEuclidean$1, AbstractManhattan: () => AbstractManhattan$1, CIE94GraphicArts: () => CIE94GraphicArts$1, CIE94Textiles: () => CIE94Textiles$1, CIEDE2000: () => CIEDE2000$1, CMetric: () => CMetric$1, Euclidean: () => Euclidean$1, EuclideanBT709: () => EuclideanBT709$1, EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha$1, Manhattan: () => Manhattan$1, ManhattanBT709: () => ManhattanBT709$1, ManhattanNommyde: () => ManhattanNommyde$1, PNGQuant: () => PNGQuant$1 });
var AbstractDistanceCalculator$1 = class {
  constructor() {
    __publicField$3(this, "_maxDistance"), __publicField$3(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(e4, t2, i2, r2) {
    this._whitePoint = { r: e4 > 0 ? 255 / e4 : 0, g: t2 > 0 ? 255 / t2 : 0, b: i2 > 0 ? 255 / i2 : 0, a: r2 > 0 ? 255 / r2 : 0 }, this._maxDistance = this.calculateRaw(e4, t2, i2, r2, 0, 0, 0, 0);
  }
  calculateNormalized(e4, t2) {
    return this.calculateRaw(e4.r, e4.g, e4.b, e4.a, t2.r, t2.g, t2.b, t2.a) / this._maxDistance;
  }
};
var AbstractCIE94$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = rgb2lab$1(inRange0to255$1(e4 * this._whitePoint.r), inRange0to255$1(t2 * this._whitePoint.g), inRange0to255$1(i2 * this._whitePoint.b)), u2 = rgb2lab$1(inRange0to255$1(n2 * this._whitePoint.r), inRange0to255$1(a2 * this._whitePoint.g), inRange0to255$1(o2 * this._whitePoint.b)), h2 = l2.L - u2.L, c2 = l2.a - u2.a, f2 = l2.b - u2.b, d = Math.sqrt(l2.a * l2.a + l2.b * l2.b), p2 = d - Math.sqrt(u2.a * u2.a + u2.b * u2.b);
    let m = c2 * c2 + f2 * f2 - p2 * p2;
    m = m < 0 ? 0 : Math.sqrt(m);
    const _2 = (s2 - r2) * this._whitePoint.a * this._kA;
    return Math.sqrt((h2 / this._Kl) ** 2 + (p2 / (1 + this._K1 * d)) ** 2 + (m / (1 + this._K2 * d)) ** 2 + _2 ** 2);
  }
};
var CIE94Textiles$1 = class extends AbstractCIE94$1 {
  _setDefaults() {
    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
  }
};
var CIE94GraphicArts$1 = class extends AbstractCIE94$1 {
  _setDefaults() {
    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
  }
};
var _CIEDE2000$1 = class extends AbstractDistanceCalculator$1 {
  _setDefaults() {
  }
  static _calculatehp(e4, t2) {
    const i2 = Math.atan2(e4, t2);
    return i2 >= 0 ? i2 : i2 + _CIEDE2000$1._deg360InRad;
  }
  static _calculateRT(e4, t2) {
    const i2 = t2 ** 7, r2 = 2 * Math.sqrt(i2 / (i2 + _CIEDE2000$1._pow25to7)), n2 = _CIEDE2000$1._deg30InRad * Math.exp(-(((e4 - _CIEDE2000$1._deg275InRad) / _CIEDE2000$1._deg25InRad) ** 2));
    return -Math.sin(2 * n2) * r2;
  }
  static _calculateT(e4) {
    return 1 - 0.17 * Math.cos(e4 - _CIEDE2000$1._deg30InRad) + 0.24 * Math.cos(2 * e4) + 0.32 * Math.cos(3 * e4 + _CIEDE2000$1._deg6InRad) - 0.2 * Math.cos(4 * e4 - _CIEDE2000$1._deg63InRad);
  }
  static _calculate_ahp(e4, t2, i2, r2) {
    const n2 = i2 + r2;
    return 0 === e4 ? n2 : t2 <= _CIEDE2000$1._deg180InRad ? n2 / 2 : n2 < _CIEDE2000$1._deg360InRad ? (n2 + _CIEDE2000$1._deg360InRad) / 2 : (n2 - _CIEDE2000$1._deg360InRad) / 2;
  }
  static _calculate_dHp(e4, t2, i2, r2) {
    let n2;
    return n2 = 0 === e4 ? 0 : t2 <= _CIEDE2000$1._deg180InRad ? i2 - r2 : i2 <= r2 ? i2 - r2 + _CIEDE2000$1._deg360InRad : i2 - r2 - _CIEDE2000$1._deg360InRad, 2 * Math.sqrt(e4) * Math.sin(n2 / 2);
  }
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = rgb2lab$1(inRange0to255$1(e4 * this._whitePoint.r), inRange0to255$1(t2 * this._whitePoint.g), inRange0to255$1(i2 * this._whitePoint.b)), u2 = rgb2lab$1(inRange0to255$1(n2 * this._whitePoint.r), inRange0to255$1(a2 * this._whitePoint.g), inRange0to255$1(o2 * this._whitePoint.b)), h2 = (s2 - r2) * this._whitePoint.a * _CIEDE2000$1._kA, c2 = this.calculateRawInLab(l2, u2);
    return Math.sqrt(c2 + h2 * h2);
  }
  calculateRawInLab(e4, t2) {
    const i2 = e4.L, r2 = e4.a, n2 = e4.b, a2 = t2.L, o2 = t2.a, s2 = t2.b, l2 = ((Math.sqrt(r2 * r2 + n2 * n2) + Math.sqrt(o2 * o2 + s2 * s2)) / 2) ** 7, u2 = 0.5 * (1 - Math.sqrt(l2 / (l2 + _CIEDE2000$1._pow25to7))), h2 = (1 + u2) * r2, c2 = (1 + u2) * o2, f2 = Math.sqrt(h2 * h2 + n2 * n2), d = Math.sqrt(c2 * c2 + s2 * s2), p2 = f2 * d, m = _CIEDE2000$1._calculatehp(n2, h2), _2 = _CIEDE2000$1._calculatehp(s2, c2), g = Math.abs(m - _2), b2 = a2 - i2, y2 = d - f2, w = _CIEDE2000$1._calculate_dHp(p2, g, _2, m), v2 = _CIEDE2000$1._calculate_ahp(p2, g, m, _2), x2 = (f2 + d) / 2, E2 = ((i2 + a2) / 2 - 50) ** 2, k2 = y2 / (1 + 0.045 * x2), S2 = w / (1 + 0.015 * _CIEDE2000$1._calculateT(v2) * x2);
    return (b2 / (1 + 0.015 * E2 / Math.sqrt(20 + E2))) ** 2 + k2 ** 2 + S2 ** 2 + _CIEDE2000$1._calculateRT(v2, x2) * k2 * S2;
  }
};
var CIEDE2000$1 = _CIEDE2000$1;
__publicField$3(CIEDE2000$1, "_kA", 25 / 255), __publicField$3(CIEDE2000$1, "_pow25to7", 25 ** 7), __publicField$3(CIEDE2000$1, "_deg360InRad", degrees2radians$1(360)), __publicField$3(CIEDE2000$1, "_deg180InRad", degrees2radians$1(180)), __publicField$3(CIEDE2000$1, "_deg30InRad", degrees2radians$1(30)), __publicField$3(CIEDE2000$1, "_deg6InRad", degrees2radians$1(6)), __publicField$3(CIEDE2000$1, "_deg63InRad", degrees2radians$1(63)), __publicField$3(CIEDE2000$1, "_deg275InRad", degrees2radians$1(275)), __publicField$3(CIEDE2000$1, "_deg25InRad", degrees2radians$1(25));
var CMetric$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = (e4 + n2) / 2 * this._whitePoint.r, u2 = (e4 - n2) * this._whitePoint.r, h2 = (t2 - a2) * this._whitePoint.g, c2 = (i2 - o2) * this._whitePoint.b, f2 = ((512 + l2) * u2 * u2 >> 8) + 4 * h2 * h2 + ((767 - l2) * c2 * c2 >> 8), d = (s2 - r2) * this._whitePoint.a;
    return Math.sqrt(f2 + d * d);
  }
  _setDefaults() {
  }
};
var AbstractEuclidean$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = n2 - e4, u2 = a2 - t2, h2 = o2 - i2, c2 = s2 - r2;
    return Math.sqrt(this._kR * l2 * l2 + this._kG * u2 * u2 + this._kB * h2 * h2 + this._kA * c2 * c2);
  }
};
var Euclidean$1 = class extends AbstractEuclidean$1 {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
};
var EuclideanBT709$1 = class extends AbstractEuclidean$1 {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
};
var EuclideanBT709NoAlpha$1 = class extends AbstractEuclidean$1 {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
  }
};
var AbstractManhattan$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    let l2 = n2 - e4, u2 = a2 - t2, h2 = o2 - i2, c2 = s2 - r2;
    return l2 < 0 && (l2 = 0 - l2), u2 < 0 && (u2 = 0 - u2), h2 < 0 && (h2 = 0 - h2), c2 < 0 && (c2 = 0 - c2), this._kR * l2 + this._kG * u2 + this._kB * h2 + this._kA * c2;
  }
};
var Manhattan$1 = class extends AbstractManhattan$1 {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
};
var ManhattanNommyde$1 = class extends AbstractManhattan$1 {
  _setDefaults() {
    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
  }
};
var ManhattanBT709$1 = class extends AbstractManhattan$1 {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
};
var PNGQuant$1 = class extends AbstractDistanceCalculator$1 {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = (s2 - r2) * this._whitePoint.a;
    return this._colordifferenceCh(e4 * this._whitePoint.r, n2 * this._whitePoint.r, l2) + this._colordifferenceCh(t2 * this._whitePoint.g, a2 * this._whitePoint.g, l2) + this._colordifferenceCh(i2 * this._whitePoint.b, o2 * this._whitePoint.b, l2);
  }
  _colordifferenceCh(e4, t2, i2) {
    const r2 = e4 - t2, n2 = r2 + i2;
    return r2 * r2 + n2 * n2;
  }
  _setDefaults() {
  }
};
var palette_exports$1 = {};
__export$1(palette_exports$1, { AbstractPaletteQuantizer: () => AbstractPaletteQuantizer$1, ColorHistogram: () => ColorHistogram$1, NeuQuant: () => NeuQuant$1, NeuQuantFloat: () => NeuQuantFloat$1, RGBQuant: () => RGBQuant$1, WuColorCube: () => WuColorCube$1, WuQuant: () => WuQuant$1 });
var AbstractPaletteQuantizer$1 = class {
  quantizeSync() {
    for (const e4 of this.quantize())
      if (e4.palette)
        return e4.palette;
    throw new Error("unreachable");
  }
};
var Point$1 = class {
  constructor() {
    __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), __publicField$3(this, "uint32"), __publicField$3(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
  }
  static createByQuadruplet(e4) {
    const t2 = new Point$1();
    return t2.r = 0 | e4[0], t2.g = 0 | e4[1], t2.b = 0 | e4[2], t2.a = 0 | e4[3], t2._loadUINT32(), t2._loadQuadruplet(), t2;
  }
  static createByRGBA(e4, t2, i2, r2) {
    const n2 = new Point$1();
    return n2.r = 0 | e4, n2.g = 0 | t2, n2.b = 0 | i2, n2.a = 0 | r2, n2._loadUINT32(), n2._loadQuadruplet(), n2;
  }
  static createByUint32(e4) {
    const t2 = new Point$1();
    return t2.uint32 = e4 >>> 0, t2._loadRGBA(), t2._loadQuadruplet(), t2;
  }
  from(e4) {
    this.r = e4.r, this.g = e4.g, this.b = e4.b, this.a = e4.a, this.uint32 = e4.uint32, this.rgba[0] = e4.r, this.rgba[1] = e4.g, this.rgba[2] = e4.b, this.rgba[3] = e4.a;
  }
  getLuminosity(e4) {
    let t2 = this.r, i2 = this.g, r2 = this.b;
    return e4 && (t2 = Math.min(255, 255 - this.a + this.a * t2 / 255), i2 = Math.min(255, 255 - this.a + this.a * i2 / 255), r2 = Math.min(255, 255 - this.a + this.a * r2 / 255)), 0.2126 * t2 + 0.7152 * i2 + 0.0722 * r2;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
  }
};
var PointContainer$1 = class {
  constructor() {
    __publicField$3(this, "_pointArray"), __publicField$3(this, "_width"), __publicField$3(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(e4) {
    this._width = e4;
  }
  setHeight(e4) {
    this._height = e4;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const e4 = new PointContainer$1();
    e4._width = this._width, e4._height = this._height;
    for (let t2 = 0, i2 = this._pointArray.length; t2 < i2; t2++)
      e4._pointArray[t2] = Point$1.createByUint32(0 | this._pointArray[t2].uint32);
    return e4;
  }
  toUint32Array() {
    const e4 = this._pointArray.length, t2 = new Uint32Array(e4);
    for (let i2 = 0; i2 < e4; i2++)
      t2[i2] = this._pointArray[i2].uint32;
    return t2;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(e4) {
    const t2 = e4.naturalWidth, i2 = e4.naturalHeight, r2 = document.createElement("canvas");
    r2.width = t2, r2.height = i2;
    return r2.getContext("2d").drawImage(e4, 0, 0, t2, i2, 0, 0, t2, i2), PointContainer$1.fromHTMLCanvasElement(r2);
  }
  static fromHTMLCanvasElement(e4) {
    const t2 = e4.width, i2 = e4.height, r2 = e4.getContext("2d").getImageData(0, 0, t2, i2);
    return PointContainer$1.fromImageData(r2);
  }
  static fromImageData(e4) {
    const t2 = e4.width, i2 = e4.height;
    return PointContainer$1.fromUint8Array(e4.data, t2, i2);
  }
  static fromUint8Array(e4, t2, i2) {
    switch (Object.prototype.toString.call(e4)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        e4 = new Uint8Array(e4);
    }
    const r2 = new Uint32Array(e4.buffer);
    return PointContainer$1.fromUint32Array(r2, t2, i2);
  }
  static fromUint32Array(e4, t2, i2) {
    const r2 = new PointContainer$1();
    r2._width = t2, r2._height = i2;
    for (let t3 = 0, i3 = e4.length; t3 < i3; t3++)
      r2._pointArray[t3] = Point$1.createByUint32(0 | e4[t3]);
    return r2;
  }
  static fromBuffer(e4, t2, i2) {
    const r2 = new Uint32Array(e4.buffer, e4.byteOffset, e4.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer$1.fromUint32Array(r2, t2, i2);
  }
};
var hueGroups$1 = 10;
function hueGroup$1(e4, t2) {
  const i2 = 360 / t2;
  for (let r2 = 1, n2 = i2 - i2 / 2; r2 < t2; r2++, n2 += i2)
    if (e4 >= n2 && e4 < n2 + i2)
      return r2;
  return 0;
}
var Palette$1 = class {
  constructor() {
    __publicField$3(this, "_pointContainer"), __publicField$3(this, "_pointArray", []), __publicField$3(this, "_i32idx", {}), this._pointContainer = new PointContainer$1(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
  }
  add(e4) {
    this._pointArray.push(e4), this._pointContainer.setWidth(this._pointArray.length);
  }
  has(e4) {
    for (let t2 = this._pointArray.length - 1; t2 >= 0; t2--)
      if (e4.uint32 === this._pointArray[t2].uint32)
        return true;
    return false;
  }
  getNearestColor(e4, t2) {
    return this._pointArray[0 | this._getNearestIndex(e4, t2)];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(e4) {
    return "number" == typeof this._i32idx[e4] ? this._i32idx[e4] : -1;
  }
  _getNearestIndex(e4, t2) {
    let i2 = this._nearestPointFromCache("" + t2.uint32);
    if (i2 >= 0)
      return i2;
    let r2 = Number.MAX_VALUE;
    i2 = 0;
    for (let n2 = 0, a2 = this._pointArray.length; n2 < a2; n2++) {
      const a3 = this._pointArray[n2], o2 = e4.calculateRaw(t2.r, t2.g, t2.b, t2.a, a3.r, a3.g, a3.b, a3.a);
      o2 < r2 && (r2 = o2, i2 = n2);
    }
    return this._i32idx[t2.uint32] = i2, i2;
  }
  sort() {
    this._i32idx = {}, this._pointArray.sort((e4, t2) => {
      const i2 = rgb2hsl$1(e4.r, e4.g, e4.b), r2 = rgb2hsl$1(t2.r, t2.g, t2.b), n2 = e4.r === e4.g && e4.g === e4.b ? 0 : 1 + hueGroup$1(i2.h, hueGroups$1), a2 = (t2.r === t2.g && t2.g === t2.b ? 0 : 1 + hueGroup$1(r2.h, hueGroups$1)) - n2;
      if (a2)
        return -a2;
      const o2 = e4.getLuminosity(true), s2 = t2.getLuminosity(true);
      if (s2 - o2 != 0)
        return s2 - o2;
      const l2 = (100 * r2.s | 0) - (100 * i2.s | 0);
      return l2 ? -l2 : 0;
    });
  }
};
var utils_exports$1 = {};
__export$1(utils_exports$1, { HueStatistics: () => HueStatistics$1, Palette: () => Palette$1, Point: () => Point$1, PointContainer: () => PointContainer$1, ProgressTracker: () => ProgressTracker$1, arithmetic: () => arithmetic_exports$1 });
var HueGroup$1 = class {
  constructor() {
    __publicField$3(this, "num", 0), __publicField$3(this, "cols", []);
  }
};
var HueStatistics$1 = class {
  constructor(e4, t2) {
    __publicField$3(this, "_numGroups"), __publicField$3(this, "_minCols"), __publicField$3(this, "_stats"), __publicField$3(this, "_groupsFull"), this._numGroups = e4, this._minCols = t2, this._stats = [];
    for (let t3 = 0; t3 <= e4; t3++)
      this._stats[t3] = new HueGroup$1();
    this._groupsFull = 0;
  }
  check(e4) {
    this._groupsFull === this._numGroups + 1 && (this.check = () => {
    });
    const t2 = 255 & e4, i2 = e4 >>> 8 & 255, r2 = e4 >>> 16 & 255, n2 = t2 === i2 && i2 === r2 ? 0 : 1 + hueGroup$1(rgb2hsl$1(t2, i2, r2).h, this._numGroups), a2 = this._stats[n2], o2 = this._minCols;
    a2.num++, a2.num > o2 || (a2.num === o2 && this._groupsFull++, a2.num <= o2 && this._stats[n2].cols.push(e4));
  }
  injectIntoDictionary(e4) {
    for (let t2 = 0; t2 <= this._numGroups; t2++)
      this._stats[t2].num <= this._minCols && this._stats[t2].cols.forEach((t3) => {
        e4[t3] ? e4[t3]++ : e4[t3] = 1;
      });
  }
  injectIntoArray(e4) {
    for (let t2 = 0; t2 <= this._numGroups; t2++)
      this._stats[t2].num <= this._minCols && this._stats[t2].cols.forEach((t3) => {
        -1 === e4.indexOf(t3) && e4.push(t3);
      });
  }
};
var _ProgressTracker$1 = class {
  constructor(e4, t2) {
    __publicField$3(this, "progress"), __publicField$3(this, "_step"), __publicField$3(this, "_range"), __publicField$3(this, "_last"), __publicField$3(this, "_progressRange"), this._range = e4, this._progressRange = t2, this._step = Math.max(1, this._range / (_ProgressTracker$1.steps + 1) | 0), this._last = -this._step, this.progress = 0;
  }
  shouldNotify(e4) {
    return e4 - this._last >= this._step && (this._last = e4, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), true);
  }
};
var ProgressTracker$1 = _ProgressTracker$1;
__publicField$3(ProgressTracker$1, "steps", 100);
var networkBiasShift$1 = 3;
var Neuron$1 = class {
  constructor(e4) {
    __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = e4;
  }
  toPoint() {
    return Point$1.createByRGBA(this.r >> networkBiasShift$1, this.g >> networkBiasShift$1, this.b >> networkBiasShift$1, this.a >> networkBiasShift$1);
  }
  subtract(e4, t2, i2, r2) {
    this.r -= 0 | e4, this.g -= 0 | t2, this.b -= 0 | i2, this.a -= 0 | r2;
  }
};
var _NeuQuant$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(e4, t2 = 256) {
    super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = e4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t2, this._distance.setWhitePoint(255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1);
  }
  sample(e4) {
    this._pointArray = this._pointArray.concat(e4.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let e4 = 0; e4 < this._networkSize; e4++)
      this._network[e4] = new Neuron$1((e4 << networkBiasShift$1 + 8) / this._networkSize | 0), this._freq[e4] = _NeuQuant$1._initialBias / this._networkSize | 0, this._bias[e4] = 0;
  }
  *_learn() {
    let e4 = this._sampleFactor;
    const t2 = this._pointArray.length;
    t2 < _NeuQuant$1._minpicturebytes && (e4 = 1);
    const i2 = 30 + (e4 - 1) / 3 | 0, r2 = t2 / e4 | 0;
    let n2, a2 = r2 / _NeuQuant$1._nCycles | 0, o2 = _NeuQuant$1._initAlpha, s2 = (this._networkSize >> 3) * _NeuQuant$1._radiusBias, l2 = s2 >> _NeuQuant$1._radiusBiasShift;
    l2 <= 1 && (l2 = 0);
    for (let e5 = 0; e5 < l2; e5++)
      this._radPower[e5] = o2 * ((l2 * l2 - e5 * e5) * _NeuQuant$1._radBias / (l2 * l2)) >>> 0;
    n2 = t2 < _NeuQuant$1._minpicturebytes ? 1 : t2 % _NeuQuant$1._prime1 != 0 ? _NeuQuant$1._prime1 : t2 % _NeuQuant$1._prime2 != 0 ? _NeuQuant$1._prime2 : t2 % _NeuQuant$1._prime3 != 0 ? _NeuQuant$1._prime3 : _NeuQuant$1._prime4;
    const u2 = new ProgressTracker$1(r2, 99);
    for (let e5 = 0, h2 = 0; e5 < r2; ) {
      u2.shouldNotify(e5) && (yield { progress: u2.progress });
      const r3 = this._pointArray[h2], c2 = r3.b << networkBiasShift$1, f2 = r3.g << networkBiasShift$1, d = r3.r << networkBiasShift$1, p2 = r3.a << networkBiasShift$1, m = this._contest(c2, f2, d, p2);
      if (this._alterSingle(o2, m, c2, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c2, f2, d, p2), h2 += n2, h2 >= t2 && (h2 -= t2), e5++, 0 === a2 && (a2 = 1), e5 % a2 == 0) {
        o2 -= o2 / i2 | 0, s2 -= s2 / _NeuQuant$1._radiusDecrease | 0, l2 = s2 >> _NeuQuant$1._radiusBiasShift, l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++)
          this._radPower[e6] = o2 * ((l2 * l2 - e6 * e6) * _NeuQuant$1._radBias / (l2 * l2)) >>> 0;
      }
    }
  }
  _buildPalette() {
    const e4 = new Palette$1();
    return this._network.forEach((t2) => {
      e4.add(t2.toPoint());
    }), e4.sort(), e4;
  }
  _alterNeighbour(e4, t2, i2, r2, n2, a2) {
    let o2 = t2 - e4;
    o2 < -1 && (o2 = -1);
    let s2 = t2 + e4;
    s2 > this._networkSize && (s2 = this._networkSize);
    let l2 = t2 + 1, u2 = t2 - 1, h2 = 1;
    for (; l2 < s2 || u2 > o2; ) {
      const e5 = this._radPower[h2++] / _NeuQuant$1._alphaRadBias;
      if (l2 < s2) {
        const t3 = this._network[l2++];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
      if (u2 > o2) {
        const t3 = this._network[u2--];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
    }
  }
  _alterSingle(e4, t2, i2, r2, n2, a2) {
    e4 /= _NeuQuant$1._initAlpha;
    const o2 = this._network[t2];
    o2.subtract(e4 * (o2.r - n2), e4 * (o2.g - r2), e4 * (o2.b - i2), e4 * (o2.a - a2));
  }
  _contest(e4, t2, i2, r2) {
    const n2 = 1020 << networkBiasShift$1;
    let a2 = ~(1 << 31), o2 = a2, s2 = -1, l2 = s2;
    for (let u2 = 0; u2 < this._networkSize; u2++) {
      const h2 = this._network[u2], c2 = this._distance.calculateNormalized(h2, { r: i2, g: t2, b: e4, a: r2 }) * n2 | 0;
      c2 < a2 && (a2 = c2, s2 = u2);
      const f2 = c2 - (this._bias[u2] >> _NeuQuant$1._initialBiasShift - networkBiasShift$1);
      f2 < o2 && (o2 = f2, l2 = u2);
      const d = this._freq[u2] >> _NeuQuant$1._betaShift;
      this._freq[u2] -= d, this._bias[u2] += d << _NeuQuant$1._gammaShift;
    }
    return this._freq[s2] += _NeuQuant$1._beta, this._bias[s2] -= _NeuQuant$1._betaGamma, l2;
  }
};
var NeuQuant$1 = _NeuQuant$1;
__publicField$3(NeuQuant$1, "_prime1", 499), __publicField$3(NeuQuant$1, "_prime2", 491), __publicField$3(NeuQuant$1, "_prime3", 487), __publicField$3(NeuQuant$1, "_prime4", 503), __publicField$3(NeuQuant$1, "_minpicturebytes", _NeuQuant$1._prime4), __publicField$3(NeuQuant$1, "_nCycles", 100), __publicField$3(NeuQuant$1, "_initialBiasShift", 16), __publicField$3(NeuQuant$1, "_initialBias", 1 << _NeuQuant$1._initialBiasShift), __publicField$3(NeuQuant$1, "_gammaShift", 10), __publicField$3(NeuQuant$1, "_betaShift", 10), __publicField$3(NeuQuant$1, "_beta", _NeuQuant$1._initialBias >> _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_betaGamma", _NeuQuant$1._initialBias << _NeuQuant$1._gammaShift - _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_radiusBiasShift", 6), __publicField$3(NeuQuant$1, "_radiusBias", 1 << _NeuQuant$1._radiusBiasShift), __publicField$3(NeuQuant$1, "_radiusDecrease", 30), __publicField$3(NeuQuant$1, "_alphaBiasShift", 10), __publicField$3(NeuQuant$1, "_initAlpha", 1 << _NeuQuant$1._alphaBiasShift), __publicField$3(NeuQuant$1, "_radBiasShift", 8), __publicField$3(NeuQuant$1, "_radBias", 1 << _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBiasShift", _NeuQuant$1._alphaBiasShift + _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBias", 1 << _NeuQuant$1._alphaRadBiasShift);
var networkBiasShift2$1 = 3;
var NeuronFloat$1 = class {
  constructor(e4) {
    __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = e4;
  }
  toPoint() {
    return Point$1.createByRGBA(this.r >> networkBiasShift2$1, this.g >> networkBiasShift2$1, this.b >> networkBiasShift2$1, this.a >> networkBiasShift2$1);
  }
  subtract(e4, t2, i2, r2) {
    this.r -= e4, this.g -= t2, this.b -= i2, this.a -= r2;
  }
};
var _NeuQuantFloat$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(e4, t2 = 256) {
    super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = e4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t2, this._distance.setWhitePoint(255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1);
  }
  sample(e4) {
    this._pointArray = this._pointArray.concat(e4.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let e4 = 0; e4 < this._networkSize; e4++)
      this._network[e4] = new NeuronFloat$1((e4 << networkBiasShift2$1 + 8) / this._networkSize), this._freq[e4] = _NeuQuantFloat$1._initialBias / this._networkSize, this._bias[e4] = 0;
  }
  *_learn() {
    let e4 = this._sampleFactor;
    const t2 = this._pointArray.length;
    t2 < _NeuQuantFloat$1._minpicturebytes && (e4 = 1);
    const i2 = 30 + (e4 - 1) / 3, r2 = t2 / e4;
    let n2, a2 = r2 / _NeuQuantFloat$1._nCycles | 0, o2 = _NeuQuantFloat$1._initAlpha, s2 = (this._networkSize >> 3) * _NeuQuantFloat$1._radiusBias, l2 = s2 >> _NeuQuantFloat$1._radiusBiasShift;
    l2 <= 1 && (l2 = 0);
    for (let e5 = 0; e5 < l2; e5++)
      this._radPower[e5] = o2 * ((l2 * l2 - e5 * e5) * _NeuQuantFloat$1._radBias / (l2 * l2));
    n2 = t2 < _NeuQuantFloat$1._minpicturebytes ? 1 : t2 % _NeuQuantFloat$1._prime1 != 0 ? _NeuQuantFloat$1._prime1 : t2 % _NeuQuantFloat$1._prime2 != 0 ? _NeuQuantFloat$1._prime2 : t2 % _NeuQuantFloat$1._prime3 != 0 ? _NeuQuantFloat$1._prime3 : _NeuQuantFloat$1._prime4;
    const u2 = new ProgressTracker$1(r2, 99);
    for (let e5 = 0, h2 = 0; e5 < r2; ) {
      u2.shouldNotify(e5) && (yield { progress: u2.progress });
      const r3 = this._pointArray[h2], c2 = r3.b << networkBiasShift2$1, f2 = r3.g << networkBiasShift2$1, d = r3.r << networkBiasShift2$1, p2 = r3.a << networkBiasShift2$1, m = this._contest(c2, f2, d, p2);
      if (this._alterSingle(o2, m, c2, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c2, f2, d, p2), h2 += n2, h2 >= t2 && (h2 -= t2), e5++, 0 === a2 && (a2 = 1), e5 % a2 == 0) {
        o2 -= o2 / i2, s2 -= s2 / _NeuQuantFloat$1._radiusDecrease, l2 = s2 >> _NeuQuantFloat$1._radiusBiasShift, l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++)
          this._radPower[e6] = o2 * ((l2 * l2 - e6 * e6) * _NeuQuantFloat$1._radBias / (l2 * l2));
      }
    }
  }
  _buildPalette() {
    const e4 = new Palette$1();
    return this._network.forEach((t2) => {
      e4.add(t2.toPoint());
    }), e4.sort(), e4;
  }
  _alterNeighbour(e4, t2, i2, r2, n2, a2) {
    let o2 = t2 - e4;
    o2 < -1 && (o2 = -1);
    let s2 = t2 + e4;
    s2 > this._networkSize && (s2 = this._networkSize);
    let l2 = t2 + 1, u2 = t2 - 1, h2 = 1;
    for (; l2 < s2 || u2 > o2; ) {
      const e5 = this._radPower[h2++] / _NeuQuantFloat$1._alphaRadBias;
      if (l2 < s2) {
        const t3 = this._network[l2++];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
      if (u2 > o2) {
        const t3 = this._network[u2--];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
    }
  }
  _alterSingle(e4, t2, i2, r2, n2, a2) {
    e4 /= _NeuQuantFloat$1._initAlpha;
    const o2 = this._network[t2];
    o2.subtract(e4 * (o2.r - n2), e4 * (o2.g - r2), e4 * (o2.b - i2), e4 * (o2.a - a2));
  }
  _contest(e4, t2, i2, r2) {
    const n2 = 1020 << networkBiasShift2$1;
    let a2 = ~(1 << 31), o2 = a2, s2 = -1, l2 = s2;
    for (let u2 = 0; u2 < this._networkSize; u2++) {
      const h2 = this._network[u2], c2 = this._distance.calculateNormalized(h2, { r: i2, g: t2, b: e4, a: r2 }) * n2;
      c2 < a2 && (a2 = c2, s2 = u2);
      const f2 = c2 - (this._bias[u2] >> _NeuQuantFloat$1._initialBiasShift - networkBiasShift2$1);
      f2 < o2 && (o2 = f2, l2 = u2);
      const d = this._freq[u2] >> _NeuQuantFloat$1._betaShift;
      this._freq[u2] -= d, this._bias[u2] += d << _NeuQuantFloat$1._gammaShift;
    }
    return this._freq[s2] += _NeuQuantFloat$1._beta, this._bias[s2] -= _NeuQuantFloat$1._betaGamma, l2;
  }
};
var NeuQuantFloat$1 = _NeuQuantFloat$1;
__publicField$3(NeuQuantFloat$1, "_prime1", 499), __publicField$3(NeuQuantFloat$1, "_prime2", 491), __publicField$3(NeuQuantFloat$1, "_prime3", 487), __publicField$3(NeuQuantFloat$1, "_prime4", 503), __publicField$3(NeuQuantFloat$1, "_minpicturebytes", _NeuQuantFloat$1._prime4), __publicField$3(NeuQuantFloat$1, "_nCycles", 100), __publicField$3(NeuQuantFloat$1, "_initialBiasShift", 16), __publicField$3(NeuQuantFloat$1, "_initialBias", 1 << _NeuQuantFloat$1._initialBiasShift), __publicField$3(NeuQuantFloat$1, "_gammaShift", 10), __publicField$3(NeuQuantFloat$1, "_betaShift", 10), __publicField$3(NeuQuantFloat$1, "_beta", _NeuQuantFloat$1._initialBias >> _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_betaGamma", _NeuQuantFloat$1._initialBias << _NeuQuantFloat$1._gammaShift - _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_radiusBiasShift", 6), __publicField$3(NeuQuantFloat$1, "_radiusBias", 1 << _NeuQuantFloat$1._radiusBiasShift), __publicField$3(NeuQuantFloat$1, "_radiusDecrease", 30), __publicField$3(NeuQuantFloat$1, "_alphaBiasShift", 10), __publicField$3(NeuQuantFloat$1, "_initAlpha", 1 << _NeuQuantFloat$1._alphaBiasShift), __publicField$3(NeuQuantFloat$1, "_radBiasShift", 8), __publicField$3(NeuQuantFloat$1, "_radBias", 1 << _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBiasShift", _NeuQuantFloat$1._alphaBiasShift + _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBias", 1 << _NeuQuantFloat$1._alphaRadBiasShift);
var _ColorHistogram$1 = class {
  constructor(e4, t2) {
    __publicField$3(this, "_method"), __publicField$3(this, "_hueStats"), __publicField$3(this, "_histogram"), __publicField$3(this, "_initColors"), __publicField$3(this, "_minHueCols"), this._method = e4, this._minHueCols = t2 << 2, this._initColors = t2 << 2, this._hueStats = new HueStatistics$1(_ColorHistogram$1._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(e4) {
    switch (this._method) {
      case 1:
        this._colorStats1D(e4);
        break;
      case 2:
        this._colorStats2D(e4);
    }
  }
  getImportanceSortedColorsIDXI32() {
    const e4 = stableSort$1(Object.keys(this._histogram), (e5, t3) => this._histogram[t3] - this._histogram[e5]);
    if (0 === e4.length)
      return [];
    let t2;
    switch (this._method) {
      case 1:
        const i2 = Math.min(e4.length, this._initColors), r2 = e4[i2 - 1], n2 = this._histogram[r2];
        t2 = e4.slice(0, i2);
        let a2 = i2;
        const o2 = e4.length;
        for (; a2 < o2 && this._histogram[e4[a2]] === n2; )
          t2.push(e4[a2++]);
        this._hueStats.injectIntoArray(t2);
        break;
      case 2:
        t2 = e4;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return t2.map((e5) => +e5);
  }
  _colorStats1D(e4) {
    const t2 = this._histogram, i2 = e4.getPointArray(), r2 = i2.length;
    for (let e5 = 0; e5 < r2; e5++) {
      const r3 = i2[e5].uint32;
      this._hueStats.check(r3), r3 in t2 ? t2[r3]++ : t2[r3] = 1;
    }
  }
  _colorStats2D(e4) {
    const t2 = e4.getWidth(), i2 = e4.getHeight(), r2 = e4.getPointArray(), n2 = _ColorHistogram$1._boxSize[0], a2 = _ColorHistogram$1._boxSize[1], o2 = n2 * a2, s2 = this._makeBoxes(t2, i2, n2, a2), l2 = this._histogram;
    s2.forEach((e5) => {
      let i3 = Math.round(e5.w * e5.h / o2) * _ColorHistogram$1._boxPixels;
      i3 < 2 && (i3 = 2);
      const n3 = {};
      this._iterateBox(e5, t2, (e6) => {
        const t3 = r2[e6].uint32;
        this._hueStats.check(t3), t3 in l2 ? l2[t3]++ : t3 in n3 ? ++n3[t3] >= i3 && (l2[t3] = n3[t3]) : n3[t3] = 1;
      });
    }), this._hueStats.injectIntoDictionary(l2);
  }
  _iterateBox(e4, t2, i2) {
    const r2 = e4, n2 = r2.y * t2 + r2.x, a2 = (r2.y + r2.h - 1) * t2 + (r2.x + r2.w - 1), o2 = t2 - r2.w + 1;
    let s2 = 0, l2 = n2;
    do {
      i2.call(this, l2), l2 += ++s2 % r2.w == 0 ? o2 : 1;
    } while (l2 <= a2);
  }
  _makeBoxes(e4, t2, i2, r2) {
    const n2 = e4 % i2, a2 = t2 % r2, o2 = e4 - n2, s2 = t2 - a2, l2 = [];
    for (let u2 = 0; u2 < t2; u2 += r2)
      for (let t3 = 0; t3 < e4; t3 += i2)
        l2.push({ x: t3, y: u2, w: t3 === o2 ? n2 : i2, h: u2 === s2 ? a2 : r2 });
    return l2;
  }
};
var ColorHistogram$1 = _ColorHistogram$1;
__publicField$3(ColorHistogram$1, "_boxSize", [64, 64]), __publicField$3(ColorHistogram$1, "_boxPixels", 2), __publicField$3(ColorHistogram$1, "_hueGroups", 10);
var RemovedColor$1 = class {
  constructor(e4, t2, i2) {
    __publicField$3(this, "index"), __publicField$3(this, "color"), __publicField$3(this, "distance"), this.index = e4, this.color = t2, this.distance = i2;
  }
};
var RGBQuant$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(e4, t2 = 256, i2 = 2) {
    super(), __publicField$3(this, "_colors"), __publicField$3(this, "_initialDistance"), __publicField$3(this, "_distanceIncrement"), __publicField$3(this, "_histogram"), __publicField$3(this, "_distance"), this._distance = e4, this._colors = t2, this._histogram = new ColorHistogram$1(i2, t2), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
  }
  sample(e4) {
    this._histogram.sample(e4);
  }
  *quantize() {
    const e4 = this._histogram.getImportanceSortedColorsIDXI32();
    if (0 === e4.length)
      throw new Error("No colors in image");
    yield* this._buildPalette(e4);
  }
  *_buildPalette(e4) {
    const t2 = new Palette$1(), i2 = t2.getPointContainer().getPointArray(), r2 = new Array(e4.length);
    for (let t3 = 0; t3 < e4.length; t3++)
      i2.push(Point$1.createByUint32(e4[t3])), r2[t3] = 1;
    const n2 = i2.length, a2 = [];
    let o2 = n2, s2 = this._initialDistance;
    const l2 = new ProgressTracker$1(o2 - this._colors, 99);
    for (; o2 > this._colors; ) {
      a2.length = 0;
      for (let e5 = 0; e5 < n2; e5++) {
        if (l2.shouldNotify(n2 - o2) && (yield { progress: l2.progress }), 0 === r2[e5])
          continue;
        const t3 = i2[e5];
        for (let l3 = e5 + 1; l3 < n2; l3++) {
          if (0 === r2[l3])
            continue;
          const e6 = i2[l3], n3 = this._distance.calculateNormalized(t3, e6);
          n3 < s2 && (a2.push(new RemovedColor$1(l3, e6, n3)), r2[l3] = 0, o2--);
        }
      }
      s2 += o2 > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
    }
    if (o2 < this._colors) {
      stableSort$1(a2, (e6, t3) => t3.distance - e6.distance);
      let e5 = 0;
      for (; o2 < this._colors && e5 < a2.length; ) {
        r2[a2[e5].index] = 1, o2++, e5++;
      }
    }
    let u2 = i2.length;
    for (let e5 = u2 - 1; e5 >= 0; e5--)
      0 === r2[e5] && (e5 !== u2 - 1 && (i2[e5] = i2[u2 - 1]), --u2);
    i2.length = u2, t2.sort(), yield { palette: t2, progress: 100 };
  }
};
function createArray1D$1(e4) {
  const t2 = [];
  for (let i2 = 0; i2 < e4; i2++)
    t2[i2] = 0;
  return t2;
}
function createArray4D$1(e4, t2, i2, r2) {
  const n2 = new Array(e4);
  for (let a2 = 0; a2 < e4; a2++) {
    n2[a2] = new Array(t2);
    for (let e5 = 0; e5 < t2; e5++) {
      n2[a2][e5] = new Array(i2);
      for (let t3 = 0; t3 < i2; t3++) {
        n2[a2][e5][t3] = new Array(r2);
        for (let i3 = 0; i3 < r2; i3++)
          n2[a2][e5][t3][i3] = 0;
      }
    }
  }
  return n2;
}
function createArray3D$1(e4, t2, i2) {
  const r2 = new Array(e4);
  for (let n2 = 0; n2 < e4; n2++) {
    r2[n2] = new Array(t2);
    for (let e5 = 0; e5 < t2; e5++) {
      r2[n2][e5] = new Array(i2);
      for (let t3 = 0; t3 < i2; t3++)
        r2[n2][e5][t3] = 0;
    }
  }
  return r2;
}
function fillArray3D$1(e4, t2, i2, r2, n2) {
  for (let a2 = 0; a2 < t2; a2++) {
    e4[a2] = [];
    for (let t3 = 0; t3 < i2; t3++) {
      e4[a2][t3] = [];
      for (let i3 = 0; i3 < r2; i3++)
        e4[a2][t3][i3] = n2;
    }
  }
}
function fillArray1D$1(e4, t2, i2) {
  for (let r2 = 0; r2 < t2; r2++)
    e4[r2] = i2;
}
var WuColorCube$1 = class {
  constructor() {
    __publicField$3(this, "redMinimum"), __publicField$3(this, "redMaximum"), __publicField$3(this, "greenMinimum"), __publicField$3(this, "greenMaximum"), __publicField$3(this, "blueMinimum"), __publicField$3(this, "blueMaximum"), __publicField$3(this, "volume"), __publicField$3(this, "alphaMinimum"), __publicField$3(this, "alphaMaximum");
  }
};
var _WuQuant$1 = class extends AbstractPaletteQuantizer$1 {
  constructor(e4, t2 = 256, i2 = 5) {
    super(), __publicField$3(this, "_reds"), __publicField$3(this, "_greens"), __publicField$3(this, "_blues"), __publicField$3(this, "_alphas"), __publicField$3(this, "_sums"), __publicField$3(this, "_weights"), __publicField$3(this, "_momentsRed"), __publicField$3(this, "_momentsGreen"), __publicField$3(this, "_momentsBlue"), __publicField$3(this, "_momentsAlpha"), __publicField$3(this, "_moments"), __publicField$3(this, "_table"), __publicField$3(this, "_pixels"), __publicField$3(this, "_cubes"), __publicField$3(this, "_colors"), __publicField$3(this, "_significantBitsPerChannel"), __publicField$3(this, "_maxSideIndex"), __publicField$3(this, "_alphaMaxSideIndex"), __publicField$3(this, "_sideSize"), __publicField$3(this, "_alphaSideSize"), __publicField$3(this, "_distance"), this._distance = e4, this._setQuality(i2), this._initialize(t2);
  }
  sample(e4) {
    const t2 = e4.getPointArray();
    for (let e5 = 0, i2 = t2.length; e5 < i2; e5++)
      this._addColor(t2[e5]);
    this._pixels = this._pixels.concat(t2);
  }
  *quantize() {
    yield* this._preparePalette();
    const e4 = new Palette$1();
    for (let t2 = 0; t2 < this._colors; t2++)
      if (this._sums[t2] > 0) {
        const i2 = this._sums[t2], r2 = this._reds[t2] / i2, n2 = this._greens[t2] / i2, a2 = this._blues[t2] / i2, o2 = this._alphas[t2] / i2, s2 = Point$1.createByRGBA(0 | r2, 0 | n2, 0 | a2, 0 | o2);
        e4.add(s2);
      }
    e4.sort(), yield { palette: e4, progress: 100 };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let e4 = 0;
    const t2 = createArray1D$1(this._colors);
    for (let i3 = 1; i3 < this._colors; ++i3) {
      this._cut(this._cubes[e4], this._cubes[i3]) ? (t2[e4] = this._cubes[e4].volume > 1 ? this._calculateVariance(this._cubes[e4]) : 0, t2[i3] = this._cubes[i3].volume > 1 ? this._calculateVariance(this._cubes[i3]) : 0) : (t2[e4] = 0, i3--), e4 = 0;
      let r3 = t2[0];
      for (let n3 = 1; n3 <= i3; ++n3)
        t2[n3] > r3 && (r3 = t2[n3], e4 = n3);
      if (r3 <= 0) {
        this._colors = i3 + 1;
        break;
      }
    }
    const i2 = [], r2 = [], n2 = [], a2 = [];
    for (let e5 = 0; e5 < this._colors; ++e5) {
      const t3 = _WuQuant$1._volume(this._cubes[e5], this._weights);
      t3 > 0 ? (i2[e5] = _WuQuant$1._volume(this._cubes[e5], this._momentsRed) / t3 | 0, r2[e5] = _WuQuant$1._volume(this._cubes[e5], this._momentsGreen) / t3 | 0, n2[e5] = _WuQuant$1._volume(this._cubes[e5], this._momentsBlue) / t3 | 0, a2[e5] = _WuQuant$1._volume(this._cubes[e5], this._momentsAlpha) / t3 | 0) : (i2[e5] = 0, r2[e5] = 0, n2[e5] = 0, a2[e5] = 0);
    }
    this._reds = createArray1D$1(this._colors + 1), this._greens = createArray1D$1(this._colors + 1), this._blues = createArray1D$1(this._colors + 1), this._alphas = createArray1D$1(this._colors + 1), this._sums = createArray1D$1(this._colors + 1);
    for (let e5 = 0, t3 = this._pixels.length; e5 < t3; e5++) {
      const t4 = this._pixels[e5];
      let o2 = -1, s2 = Number.MAX_VALUE;
      for (let e6 = 0; e6 < this._colors; e6++) {
        const l2 = i2[e6], u2 = r2[e6], h2 = n2[e6], c2 = a2[e6], f2 = this._distance.calculateRaw(l2, u2, h2, c2, t4.r, t4.g, t4.b, t4.a);
        f2 < s2 && (s2 = f2, o2 = e6);
      }
      this._reds[o2] += t4.r, this._greens[o2] += t4.g, this._blues[o2] += t4.b, this._alphas[o2] += t4.a, this._sums[o2]++;
    }
  }
  _addColor(e4) {
    const t2 = 8 - this._significantBitsPerChannel, i2 = 1 + (e4.r >> t2), r2 = 1 + (e4.g >> t2), n2 = 1 + (e4.b >> t2), a2 = 1 + (e4.a >> t2);
    this._weights[a2][i2][r2][n2]++, this._momentsRed[a2][i2][r2][n2] += e4.r, this._momentsGreen[a2][i2][r2][n2] += e4.g, this._momentsBlue[a2][i2][r2][n2] += e4.b, this._momentsAlpha[a2][i2][r2][n2] += e4.a, this._moments[a2][i2][r2][n2] += this._table[e4.r] + this._table[e4.g] + this._table[e4.b] + this._table[e4.a];
  }
  *_calculateMoments() {
    const e4 = [], t2 = [], i2 = [], r2 = [], n2 = [], a2 = [], o2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), s2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), l2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), u2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), h2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), c2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize);
    let f2 = 0;
    const d = new ProgressTracker$1(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let p2 = 1; p2 <= this._alphaMaxSideIndex; ++p2) {
      fillArray3D$1(o2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(s2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(l2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(u2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(h2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(c2, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let m = 1; m <= this._maxSideIndex; ++m, ++f2) {
        d.shouldNotify(f2) && (yield { progress: d.progress }), fillArray1D$1(e4, this._sideSize, 0), fillArray1D$1(t2, this._sideSize, 0), fillArray1D$1(i2, this._sideSize, 0), fillArray1D$1(r2, this._sideSize, 0), fillArray1D$1(n2, this._sideSize, 0), fillArray1D$1(a2, this._sideSize, 0);
        for (let f3 = 1; f3 <= this._maxSideIndex; ++f3) {
          let d2 = 0, _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0;
          for (let v2 = 1; v2 <= this._maxSideIndex; ++v2)
            d2 += this._weights[p2][m][f3][v2], _2 += this._momentsRed[p2][m][f3][v2], g += this._momentsGreen[p2][m][f3][v2], b2 += this._momentsBlue[p2][m][f3][v2], y2 += this._momentsAlpha[p2][m][f3][v2], w += this._moments[p2][m][f3][v2], e4[v2] += d2, t2[v2] += _2, i2[v2] += g, r2[v2] += b2, n2[v2] += y2, a2[v2] += w, o2[m][f3][v2] = o2[m - 1][f3][v2] + e4[v2], s2[m][f3][v2] = s2[m - 1][f3][v2] + t2[v2], l2[m][f3][v2] = l2[m - 1][f3][v2] + i2[v2], u2[m][f3][v2] = u2[m - 1][f3][v2] + r2[v2], h2[m][f3][v2] = h2[m - 1][f3][v2] + n2[v2], c2[m][f3][v2] = c2[m - 1][f3][v2] + a2[v2], this._weights[p2][m][f3][v2] = this._weights[p2 - 1][m][f3][v2] + o2[m][f3][v2], this._momentsRed[p2][m][f3][v2] = this._momentsRed[p2 - 1][m][f3][v2] + s2[m][f3][v2], this._momentsGreen[p2][m][f3][v2] = this._momentsGreen[p2 - 1][m][f3][v2] + l2[m][f3][v2], this._momentsBlue[p2][m][f3][v2] = this._momentsBlue[p2 - 1][m][f3][v2] + u2[m][f3][v2], this._momentsAlpha[p2][m][f3][v2] = this._momentsAlpha[p2 - 1][m][f3][v2] + h2[m][f3][v2], this._moments[p2][m][f3][v2] = this._moments[p2 - 1][m][f3][v2] + c2[m][f3][v2];
        }
      }
    }
  }
  static _volumeFloat(e4, t2) {
    return t2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] - t2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - t2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + t2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - t2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] + t2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + t2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - t2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (t2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - t2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - t2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + t2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - t2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + t2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + t2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] - t2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
  }
  static _volume(e4, t2) {
    return 0 | _WuQuant$1._volumeFloat(e4, t2);
  }
  static _top(e4, t2, i2, r2) {
    let n2;
    switch (t2) {
      case _WuQuant$1._alpha:
        n2 = r2[i2][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] - r2[i2][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - r2[i2][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + r2[i2][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (r2[i2][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - r2[i2][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - r2[i2][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + r2[i2][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
        break;
      case _WuQuant$1._red:
        n2 = r2[e4.alphaMaximum][i2][e4.greenMaximum][e4.blueMaximum] - r2[e4.alphaMaximum][i2][e4.greenMinimum][e4.blueMaximum] - r2[e4.alphaMinimum][i2][e4.greenMaximum][e4.blueMaximum] + r2[e4.alphaMinimum][i2][e4.greenMinimum][e4.blueMaximum] - (r2[e4.alphaMaximum][i2][e4.greenMaximum][e4.blueMinimum] - r2[e4.alphaMaximum][i2][e4.greenMinimum][e4.blueMinimum] - r2[e4.alphaMinimum][i2][e4.greenMaximum][e4.blueMinimum] + r2[e4.alphaMinimum][i2][e4.greenMinimum][e4.blueMinimum]);
        break;
      case _WuQuant$1._green:
        n2 = r2[e4.alphaMaximum][e4.redMaximum][i2][e4.blueMaximum] - r2[e4.alphaMaximum][e4.redMinimum][i2][e4.blueMaximum] - r2[e4.alphaMinimum][e4.redMaximum][i2][e4.blueMaximum] + r2[e4.alphaMinimum][e4.redMinimum][i2][e4.blueMaximum] - (r2[e4.alphaMaximum][e4.redMaximum][i2][e4.blueMinimum] - r2[e4.alphaMaximum][e4.redMinimum][i2][e4.blueMinimum] - r2[e4.alphaMinimum][e4.redMaximum][i2][e4.blueMinimum] + r2[e4.alphaMinimum][e4.redMinimum][i2][e4.blueMinimum]);
        break;
      case _WuQuant$1._blue:
        n2 = r2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][i2] - r2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][i2] - r2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][i2] + r2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][i2] - (r2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][i2] - r2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][i2] - r2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][i2] + r2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][i2]);
        break;
      default:
        throw new Error("impossible");
    }
    return 0 | n2;
  }
  static _bottom(e4, t2, i2) {
    switch (t2) {
      case _WuQuant$1._alpha:
        return -i2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      case _WuQuant$1._red:
        return -i2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      case _WuQuant$1._green:
        return -i2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      case _WuQuant$1._blue:
        return -i2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] - (-i2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(e4) {
    const t2 = _WuQuant$1._volume(e4, this._momentsRed), i2 = _WuQuant$1._volume(e4, this._momentsGreen), r2 = _WuQuant$1._volume(e4, this._momentsBlue), n2 = _WuQuant$1._volume(e4, this._momentsAlpha);
    return _WuQuant$1._volumeFloat(e4, this._moments) - (t2 * t2 + i2 * i2 + r2 * r2 + n2 * n2) / _WuQuant$1._volume(e4, this._weights);
  }
  _maximize(e4, t2, i2, r2, n2, a2, o2, s2, l2) {
    const u2 = 0 | _WuQuant$1._bottom(e4, t2, this._momentsRed), h2 = 0 | _WuQuant$1._bottom(e4, t2, this._momentsGreen), c2 = 0 | _WuQuant$1._bottom(e4, t2, this._momentsBlue), f2 = 0 | _WuQuant$1._bottom(e4, t2, this._momentsAlpha), d = 0 | _WuQuant$1._bottom(e4, t2, this._weights);
    let p2 = 0, m = -1;
    for (let _2 = i2; _2 < r2; ++_2) {
      let i3 = u2 + _WuQuant$1._top(e4, t2, _2, this._momentsRed), r3 = h2 + _WuQuant$1._top(e4, t2, _2, this._momentsGreen), g = c2 + _WuQuant$1._top(e4, t2, _2, this._momentsBlue), b2 = f2 + _WuQuant$1._top(e4, t2, _2, this._momentsAlpha), y2 = d + _WuQuant$1._top(e4, t2, _2, this._weights);
      if (0 !== y2) {
        let e5 = i3 * i3 + r3 * r3 + g * g + b2 * b2, t3 = e5 / y2;
        i3 = n2 - i3, r3 = a2 - r3, g = o2 - g, b2 = s2 - b2, y2 = l2 - y2, 0 !== y2 && (e5 = i3 * i3 + r3 * r3 + g * g + b2 * b2, t3 += e5 / y2, t3 > p2 && (p2 = t3, m = _2));
      }
    }
    return { max: p2, position: m };
  }
  _cut(e4, t2) {
    let i2;
    const r2 = _WuQuant$1._volume(e4, this._momentsRed), n2 = _WuQuant$1._volume(e4, this._momentsGreen), a2 = _WuQuant$1._volume(e4, this._momentsBlue), o2 = _WuQuant$1._volume(e4, this._momentsAlpha), s2 = _WuQuant$1._volume(e4, this._weights), l2 = this._maximize(e4, _WuQuant$1._red, e4.redMinimum + 1, e4.redMaximum, r2, n2, a2, o2, s2), u2 = this._maximize(e4, _WuQuant$1._green, e4.greenMinimum + 1, e4.greenMaximum, r2, n2, a2, o2, s2), h2 = this._maximize(e4, _WuQuant$1._blue, e4.blueMinimum + 1, e4.blueMaximum, r2, n2, a2, o2, s2), c2 = this._maximize(e4, _WuQuant$1._alpha, e4.alphaMinimum + 1, e4.alphaMaximum, r2, n2, a2, o2, s2);
    if (c2.max >= l2.max && c2.max >= u2.max && c2.max >= h2.max) {
      if (i2 = _WuQuant$1._alpha, c2.position < 0)
        return false;
    } else
      i2 = l2.max >= c2.max && l2.max >= u2.max && l2.max >= h2.max ? _WuQuant$1._red : u2.max >= c2.max && u2.max >= l2.max && u2.max >= h2.max ? _WuQuant$1._green : _WuQuant$1._blue;
    switch (t2.redMaximum = e4.redMaximum, t2.greenMaximum = e4.greenMaximum, t2.blueMaximum = e4.blueMaximum, t2.alphaMaximum = e4.alphaMaximum, i2) {
      case _WuQuant$1._red:
        t2.redMinimum = e4.redMaximum = l2.position, t2.greenMinimum = e4.greenMinimum, t2.blueMinimum = e4.blueMinimum, t2.alphaMinimum = e4.alphaMinimum;
        break;
      case _WuQuant$1._green:
        t2.greenMinimum = e4.greenMaximum = u2.position, t2.redMinimum = e4.redMinimum, t2.blueMinimum = e4.blueMinimum, t2.alphaMinimum = e4.alphaMinimum;
        break;
      case _WuQuant$1._blue:
        t2.blueMinimum = e4.blueMaximum = h2.position, t2.redMinimum = e4.redMinimum, t2.greenMinimum = e4.greenMinimum, t2.alphaMinimum = e4.alphaMinimum;
        break;
      case _WuQuant$1._alpha:
        t2.alphaMinimum = e4.alphaMaximum = c2.position, t2.blueMinimum = e4.blueMinimum, t2.redMinimum = e4.redMinimum, t2.greenMinimum = e4.greenMinimum;
    }
    return e4.volume = (e4.redMaximum - e4.redMinimum) * (e4.greenMaximum - e4.greenMinimum) * (e4.blueMaximum - e4.blueMinimum) * (e4.alphaMaximum - e4.alphaMinimum), t2.volume = (t2.redMaximum - t2.redMinimum) * (t2.greenMaximum - t2.greenMinimum) * (t2.blueMaximum - t2.blueMinimum) * (t2.alphaMaximum - t2.alphaMinimum), true;
  }
  _initialize(e4) {
    this._colors = e4, this._cubes = [];
    for (let t2 = 0; t2 < e4; t2++)
      this._cubes[t2] = new WuColorCube$1();
    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
    for (let e5 = 0; e5 < 256; ++e5)
      this._table[e5] = e5 * e5;
    this._pixels = [];
  }
  _setQuality(e4 = 5) {
    this._significantBitsPerChannel = e4, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
};
var WuQuant$1 = _WuQuant$1;
__publicField$3(WuQuant$1, "_alpha", 3), __publicField$3(WuQuant$1, "_red", 2), __publicField$3(WuQuant$1, "_green", 1), __publicField$3(WuQuant$1, "_blue", 0);
var image_exports$1 = {};
__export$1(image_exports$1, { AbstractImageQuantizer: () => AbstractImageQuantizer$1, ErrorDiffusionArray: () => ErrorDiffusionArray$1, ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel$1, ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma$1, NearestColor: () => NearestColor$1 });
var AbstractImageQuantizer$1 = class {
  quantizeSync(e4, t2) {
    for (const i2 of this.quantize(e4, t2))
      if (i2.pointContainer)
        return i2.pointContainer;
    throw new Error("unreachable");
  }
};
var NearestColor$1 = class extends AbstractImageQuantizer$1 {
  constructor(e4) {
    super(), __publicField$3(this, "_distance"), this._distance = e4;
  }
  *quantize(e4, t2) {
    const i2 = e4.getPointArray(), r2 = e4.getWidth(), n2 = e4.getHeight(), a2 = new ProgressTracker$1(n2, 99);
    for (let e5 = 0; e5 < n2; e5++) {
      a2.shouldNotify(e5) && (yield { progress: a2.progress });
      for (let n3 = 0, a3 = e5 * r2; n3 < r2; n3++, a3++) {
        const e6 = i2[a3];
        e6.from(t2.getNearestColor(this._distance, e6));
      }
    }
    yield { pointContainer: e4, progress: 100 };
  }
};
var ErrorDiffusionArrayKernel$1 = ((e4) => (e4[e4.FloydSteinberg = 0] = "FloydSteinberg", e4[e4.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e4[e4.Stucki = 2] = "Stucki", e4[e4.Atkinson = 3] = "Atkinson", e4[e4.Jarvis = 4] = "Jarvis", e4[e4.Burkes = 5] = "Burkes", e4[e4.Sierra = 6] = "Sierra", e4[e4.TwoSierra = 7] = "TwoSierra", e4[e4.SierraLite = 8] = "SierraLite", e4))(ErrorDiffusionArrayKernel$1 || {});
var ErrorDiffusionArray$1 = class extends AbstractImageQuantizer$1 {
  constructor(e4, t2, i2 = true, r2 = 0, n2 = false) {
    super(), __publicField$3(this, "_minColorDistance"), __publicField$3(this, "_serpentine"), __publicField$3(this, "_kernel"), __publicField$3(this, "_calculateErrorLikeGIMP"), __publicField$3(this, "_distance"), this._setKernel(t2), this._distance = e4, this._minColorDistance = r2, this._serpentine = i2, this._calculateErrorLikeGIMP = n2;
  }
  *quantize(e4, t2) {
    const i2 = e4.getPointArray(), r2 = new Point$1(), n2 = e4.getWidth(), a2 = e4.getHeight(), o2 = [];
    let s2 = 1, l2 = 1;
    for (const e5 of this._kernel) {
      const t3 = e5[2] + 1;
      l2 < t3 && (l2 = t3);
    }
    for (let e5 = 0; e5 < l2; e5++)
      this._fillErrorLine(o2[e5] = [], n2);
    const u2 = new ProgressTracker$1(a2, 99);
    for (let e5 = 0; e5 < a2; e5++) {
      u2.shouldNotify(e5) && (yield { progress: u2.progress }), this._serpentine && (s2 *= -1);
      const l3 = e5 * n2, h2 = 1 === s2 ? 0 : n2 - 1, c2 = 1 === s2 ? n2 : -1;
      this._fillErrorLine(o2[0], n2), o2.push(o2.shift());
      const f2 = o2[0];
      for (let u3 = h2, d = l3 + h2; u3 !== c2; u3 += s2, d += s2) {
        const l4 = i2[d], h3 = f2[u3];
        r2.from(l4);
        const c3 = Point$1.createByRGBA(inRange0to255Rounded$1(l4.r + h3[0]), inRange0to255Rounded$1(l4.g + h3[1]), inRange0to255Rounded$1(l4.b + h3[2]), inRange0to255Rounded$1(l4.a + h3[3])), p2 = t2.getNearestColor(this._distance, c3);
        if (l4.from(p2), this._minColorDistance) {
          if (this._distance.calculateNormalized(r2, p2) < this._minColorDistance)
            continue;
        }
        let m, _2, g, b2;
        this._calculateErrorLikeGIMP ? (m = c3.r - p2.r, _2 = c3.g - p2.g, g = c3.b - p2.b, b2 = c3.a - p2.a) : (m = r2.r - p2.r, _2 = r2.g - p2.g, g = r2.b - p2.b, b2 = r2.a - p2.a);
        const y2 = 1 === s2 ? 0 : this._kernel.length - 1, w = 1 === s2 ? this._kernel.length : -1;
        for (let t3 = y2; t3 !== w; t3 += s2) {
          const i3 = this._kernel[t3][1] * s2, r3 = this._kernel[t3][2];
          if (i3 + u3 >= 0 && i3 + u3 < n2 && r3 + e5 >= 0 && r3 + e5 < a2) {
            const e6 = this._kernel[t3][0], n3 = o2[r3][i3 + u3];
            n3[0] += m * e6, n3[1] += _2 * e6, n3[2] += g * e6, n3[3] += b2 * e6;
          }
        }
      }
    }
    yield { pointContainer: e4, progress: 100 };
  }
  _fillErrorLine(e4, t2) {
    e4.length > t2 && (e4.length = t2);
    const i2 = e4.length;
    for (let t3 = 0; t3 < i2; t3++) {
      const i3 = e4[t3];
      i3[0] = i3[1] = i3[2] = i3[3] = 0;
    }
    for (let r2 = i2; r2 < t2; r2++)
      e4[r2] = [0, 0, 0, 0];
  }
  _setKernel(e4) {
    switch (e4) {
      case 0:
        this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
        break;
      case 1:
        this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
        break;
      case 2:
        this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
        break;
      case 3:
        this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
        break;
      case 4:
        this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
        break;
      case 5:
        this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
        break;
      case 6:
        this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
        break;
      case 7:
        this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
        break;
      case 8:
        this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${e4}`);
    }
  }
};
function* hilbertCurve$1(e4, t2, i2) {
  const r2 = Math.max(e4, t2), n2 = { width: e4, height: t2, level: Math.floor(Math.log(r2) / Math.log(2) + 1), callback: i2, tracker: new ProgressTracker$1(e4 * t2, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert$1(n2, 1), visit$1(n2, 0);
}
function* walkHilbert$1(e4, t2) {
  if (!(e4.level < 1)) {
    switch (e4.tracker.shouldNotify(e4.index) && (yield { progress: e4.tracker.progress }), e4.level--, t2) {
      case 2:
        yield* walkHilbert$1(e4, 1), visit$1(e4, 3), yield* walkHilbert$1(e4, 2), visit$1(e4, 4), yield* walkHilbert$1(e4, 2), visit$1(e4, 2), yield* walkHilbert$1(e4, 4);
        break;
      case 3:
        yield* walkHilbert$1(e4, 4), visit$1(e4, 2), yield* walkHilbert$1(e4, 3), visit$1(e4, 1), yield* walkHilbert$1(e4, 3), visit$1(e4, 3), yield* walkHilbert$1(e4, 1);
        break;
      case 1:
        yield* walkHilbert$1(e4, 2), visit$1(e4, 4), yield* walkHilbert$1(e4, 1), visit$1(e4, 3), yield* walkHilbert$1(e4, 1), visit$1(e4, 1), yield* walkHilbert$1(e4, 3);
        break;
      case 4:
        yield* walkHilbert$1(e4, 3), visit$1(e4, 1), yield* walkHilbert$1(e4, 4), visit$1(e4, 2), yield* walkHilbert$1(e4, 4), visit$1(e4, 4), yield* walkHilbert$1(e4, 2);
    }
    e4.level++;
  }
}
function visit$1(e4, t2) {
  switch (e4.x >= 0 && e4.x < e4.width && e4.y >= 0 && e4.y < e4.height && (e4.callback(e4.x, e4.y), e4.index++), t2) {
    case 2:
      e4.x--;
      break;
    case 3:
      e4.x++;
      break;
    case 1:
      e4.y--;
      break;
    case 4:
      e4.y++;
  }
}
var ErrorDiffusionRiemersma$1 = class extends AbstractImageQuantizer$1 {
  constructor(e4, t2 = 16, i2 = 1) {
    super(), __publicField$3(this, "_distance"), __publicField$3(this, "_weights"), __publicField$3(this, "_errorQueueSize"), this._distance = e4, this._errorQueueSize = t2, this._weights = ErrorDiffusionRiemersma$1._createWeights(i2, t2);
  }
  *quantize(e4, t2) {
    const i2 = e4.getPointArray(), r2 = e4.getWidth(), n2 = e4.getHeight(), a2 = [];
    let o2 = 0;
    for (let e5 = 0; e5 < this._errorQueueSize; e5++)
      a2[e5] = { r: 0, g: 0, b: 0, a: 0 };
    yield* hilbertCurve$1(r2, n2, (e5, n3) => {
      const s2 = i2[e5 + n3 * r2];
      let { r: l2, g: u2, b: h2, a: c2 } = s2;
      for (let e6 = 0; e6 < this._errorQueueSize; e6++) {
        const t3 = this._weights[e6], i3 = a2[(e6 + o2) % this._errorQueueSize];
        l2 += i3.r * t3, u2 += i3.g * t3, h2 += i3.b * t3, c2 += i3.a * t3;
      }
      const f2 = Point$1.createByRGBA(inRange0to255Rounded$1(l2), inRange0to255Rounded$1(u2), inRange0to255Rounded$1(h2), inRange0to255Rounded$1(c2)), d = t2.getNearestColor(this._distance, f2);
      o2 = (o2 + 1) % this._errorQueueSize;
      const p2 = (o2 + this._errorQueueSize - 1) % this._errorQueueSize;
      a2[p2].r = s2.r - d.r, a2[p2].g = s2.g - d.g, a2[p2].b = s2.b - d.b, a2[p2].a = s2.a - d.a, s2.from(d);
    }), yield { pointContainer: e4, progress: 100 };
  }
  static _createWeights(e4, t2) {
    const i2 = [], r2 = Math.exp(Math.log(t2) / (t2 - 1));
    for (let n2 = 0, a2 = 1; n2 < t2; n2++)
      i2[n2] = (a2 + 0.5 | 0) / t2 * e4, a2 *= r2;
    return i2;
  }
};
var quality_exports$1 = {};
__export$1(quality_exports$1, { ssim: () => ssim$1 });
var K1$1 = 0.01;
var K2$1 = 0.03;
function ssim$1(e4, t2) {
  if (e4.getHeight() !== t2.getHeight() || e4.getWidth() !== t2.getWidth())
    throw new Error("Images have different sizes!");
  const i2 = (255 * K1$1) ** 2, r2 = (255 * K2$1) ** 2;
  let n2 = 0, a2 = 0;
  return iterate$1(e4, t2, (e5, t3, o2, s2) => {
    let l2 = 0, u2 = 0, h2 = 0;
    for (let i3 = 0; i3 < e5.length; i3++)
      u2 += (e5[i3] - o2) ** 2, h2 += (t3[i3] - s2) ** 2, l2 += (e5[i3] - o2) * (t3[i3] - s2);
    const c2 = e5.length - 1;
    u2 /= c2, h2 /= c2, l2 /= c2;
    a2 += (2 * o2 * s2 + i2) * (2 * l2 + r2) / ((o2 ** 2 + s2 ** 2 + i2) * (u2 + h2 + r2)), n2++;
  }), a2 / n2;
}
function iterate$1(e4, t2, i2) {
  const r2 = e4.getWidth(), n2 = e4.getHeight();
  for (let a2 = 0; a2 < n2; a2 += 8)
    for (let o2 = 0; o2 < r2; o2 += 8) {
      const s2 = Math.min(8, r2 - o2), l2 = Math.min(8, n2 - a2), u2 = calculateLumaValuesForWindow$1(e4, o2, a2, s2, l2), h2 = calculateLumaValuesForWindow$1(t2, o2, a2, s2, l2);
      i2(u2, h2, calculateAverageLuma$1(u2), calculateAverageLuma$1(h2));
    }
}
function calculateLumaValuesForWindow$1(e4, t2, i2, r2, n2) {
  const a2 = e4.getPointArray(), o2 = [];
  let s2 = 0;
  for (let l2 = i2; l2 < i2 + n2; l2++) {
    const i3 = l2 * e4.getWidth();
    for (let e5 = t2; e5 < t2 + r2; e5++) {
      const t3 = a2[i3 + e5];
      o2[s2] = 0.2126 * t3.r + 0.7152 * t3.g + 0.0722 * t3.b, s2++;
    }
  }
  return o2;
}
function calculateAverageLuma$1(e4) {
  let t2 = 0;
  for (const i2 of e4)
    t2 += i2;
  return t2 / e4.length;
}
var setImmediateImpl = "function" == typeof setImmediate ? setImmediate : "undefined" != typeof process && "function" == typeof (null == process ? void 0 : process.nextTick) ? (e4) => process.nextTick(e4) : (e4) => setTimeout(e4, 0);
function buildPaletteSync$1(e4, { colorDistanceFormula: t2, paletteQuantization: i2, colors: r2 } = {}) {
  const n2 = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(t2), i2, r2);
  return e4.forEach((e5) => n2.sample(e5)), n2.quantizeSync();
}
async function buildPalette(e4, { colorDistanceFormula: t2, paletteQuantization: i2, colors: r2, onProgress: n2 } = {}) {
  return new Promise((a2, o2) => {
    const s2 = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(t2), i2, r2);
    let l2;
    e4.forEach((e5) => s2.sample(e5));
    const u2 = s2.quantize(), h2 = () => {
      try {
        const e5 = u2.next();
        e5.done ? a2(l2) : (e5.value.palette && (l2 = e5.value.palette), n2 && n2(e5.value.progress), setImmediateImpl(h2));
      } catch (e5) {
        o2(e5);
      }
    };
    setImmediateImpl(h2);
  });
}
function applyPaletteSync$1(e4, t2, { colorDistanceFormula: i2, imageQuantization: r2 } = {}) {
  return imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(i2), r2).quantizeSync(e4, t2);
}
async function applyPalette(e4, t2, { colorDistanceFormula: i2, imageQuantization: r2, onProgress: n2 } = {}) {
  return new Promise((a2, o2) => {
    let s2;
    const l2 = imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(i2), r2).quantize(e4, t2), u2 = () => {
      try {
        const e5 = l2.next();
        e5.done ? a2(s2) : (e5.value.pointContainer && (s2 = e5.value.pointContainer), n2 && n2(e5.value.progress), setImmediateImpl(u2));
      } catch (e5) {
        o2(e5);
      }
    };
    setImmediateImpl(u2);
  });
}
function colorDistanceFormulaToColorDistance$1(e4 = "euclidean-bt709") {
  switch (e4) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts$1();
    case "cie94-textiles":
      return new CIE94Textiles$1();
    case "ciede2000":
      return new CIEDE2000$1();
    case "color-metric":
      return new CMetric$1();
    case "euclidean":
      return new Euclidean$1();
    case "euclidean-bt709":
      return new EuclideanBT709$1();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha$1();
    case "manhattan":
      return new Manhattan$1();
    case "manhattan-bt709":
      return new ManhattanBT709$1();
    case "manhattan-nommyde":
      return new ManhattanNommyde$1();
    case "pngquant":
      return new PNGQuant$1();
    default:
      throw new Error(`Unknown colorDistanceFormula ${e4}`);
  }
}
function imageQuantizationToImageQuantizer$1(e4, t2 = "floyd-steinberg") {
  switch (t2) {
    case "nearest":
      return new NearestColor$1(e4);
    case "riemersma":
      return new ErrorDiffusionRiemersma$1(e4);
    case "floyd-steinberg":
      return new ErrorDiffusionArray$1(e4, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray$1(e4, 1);
    case "stucki":
      return new ErrorDiffusionArray$1(e4, 2);
    case "atkinson":
      return new ErrorDiffusionArray$1(e4, 3);
    case "jarvis":
      return new ErrorDiffusionArray$1(e4, 4);
    case "burkes":
      return new ErrorDiffusionArray$1(e4, 5);
    case "sierra":
      return new ErrorDiffusionArray$1(e4, 6);
    case "two-sierra":
      return new ErrorDiffusionArray$1(e4, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray$1(e4, 8);
    default:
      throw new Error(`Unknown imageQuantization ${t2}`);
  }
}
function paletteQuantizationToPaletteQuantizer$1(e4, t2 = "wuquant", i2 = 256) {
  switch (t2) {
    case "neuquant":
      return new NeuQuant$1(e4, i2);
    case "rgbquant":
      return new RGBQuant$1(e4, i2);
    case "wuquant":
      return new WuQuant$1(e4, i2);
    case "neuquant-float":
      return new NeuQuantFloat$1(e4, i2);
    default:
      throw new Error(`Unknown paletteQuantization ${t2}`);
  }
}
var imageQ = __toCommonJS2(src_exports);
var gifframe = {};
var BitmapImage$1 = bitmapimage;
var GifFrame$1 = class e2 extends BitmapImage$1 {
  constructor(...t2) {
    if (super(...t2), t2[0] instanceof e2) {
      const e4 = t2[0];
      this.xOffset = e4.xOffset, this.yOffset = e4.yOffset, this.disposalMethod = e4.disposalMethod, this.delayCentisecs = e4.delayCentisecs, this.interlaced = e4.interlaced;
    } else {
      const i2 = t2[t2.length - 1];
      let r2 = {};
      "object" != typeof i2 || i2 instanceof BitmapImage$1 || (r2 = i2), this.xOffset = r2.xOffset || 0, this.yOffset = r2.yOffset || 0, this.disposalMethod = void 0 !== r2.disposalMethod ? r2.disposalMethod : e2.DisposeToBackgroundColor, this.delayCentisecs = r2.delayCentisecs || 8, this.interlaced = r2.interlaced || false;
    }
  }
  getPalette() {
    const e4 = /* @__PURE__ */ new Set(), t2 = this.bitmap.data;
    let i2 = 0, r2 = false;
    for (; i2 < t2.length; ) {
      if (0 === t2[i2 + 3])
        r2 = true;
      else {
        const r3 = t2.readUInt32BE(i2, true) >> 8 & 16777215;
        e4.add(r3);
      }
      i2 += 4;
    }
    const n2 = new Array(e4.size), a2 = e4.values();
    for (i2 = 0; i2 < n2.length; ++i2)
      n2[i2] = a2.next().value;
    n2.sort((e5, t3) => e5 - t3);
    let o2 = n2.length;
    return r2 && ++o2, { colors: n2, usesTransparency: r2, indexCount: o2 };
  }
};
var hasRequiredGifutil;
var hasRequiredGifcodec;
function requireGifutil() {
  return hasRequiredGifutil || (hasRequiredGifutil = 1, function(e4) {
    const t2 = require$$0, i2 = imageQ, r2 = bitmapimage, { GifFrame: n2 } = gifframe, { GifError: a2 } = gif$1, { GifCodec: o2 } = requireGifcodec(), s2 = [".jpg", ".jpeg", ".png", ".bmp"], l2 = new o2();
    function u2(e5, t3, r3, n3, a3) {
      const o3 = Array.isArray(e5) ? e5 : [e5];
      if (a3) {
        if (["FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite"].indexOf(a3.ditherAlgorithm) < 0)
          throw new Error(`Invalid ditherAlgorithm '${a3.ditherAlgorithm}'`);
        void 0 === a3.serpentine && (a3.serpentine = true), void 0 === a3.minimumColorDistanceToDither && (a3.minimumColorDistanceToDither = 0), void 0 === a3.calculateErrorLikeGIMP && (a3.calculateErrorLikeGIMP = false);
      }
      const s3 = new i2.distance.Euclidean(), l3 = new i2.palette[t3](s3, r3, n3);
      let u3;
      u3 = a3 ? new i2.image.ErrorDiffusionArray(s3, i2.image.ErrorDiffusionArrayKernel[a3.ditherAlgorithm], a3.serpentine, a3.minimumColorDistanceToDither, a3.calculateErrorLikeGIMP) : new i2.image.NearestColor(s3);
      const h2 = [];
      o3.forEach((e6) => {
        const t4 = e6.bitmap.data, r4 = new ArrayBuffer(t4.length), n4 = new Uint32Array(r4);
        for (let e7 = 0, i3 = 0; e7 < t4.length; e7 += 4, ++i3)
          n4[i3] = t4.readUInt32LE(e7, true);
        const a4 = i2.utils.PointContainer.fromUint32Array(n4, e6.bitmap.width, e6.bitmap.height);
        l3.sample(a4), h2.push(a4);
      });
      const c2 = l3.quantizeSync();
      for (let e6 = 0; e6 < o3.length; ++e6) {
        const t4 = o3[e6].bitmap.data, i3 = u3.quantizeSync(h2[e6], c2).toUint32Array();
        for (let e7 = 0, r4 = 0; e7 < t4.length; e7 += 4, ++r4)
          t4.writeUInt32LE(i3[r4], e7);
      }
    }
    e4.cloneFrames = function(e5) {
      let t3 = [];
      return e5.forEach((e6) => {
        t3.push(new n2(e6));
      }), t3;
    }, e4.getColorInfo = function(e5, t3) {
      let i3 = false;
      const r3 = [];
      for (let t4 = 0; t4 < e5.length; ++t4) {
        let n4 = e5[t4].getPalette();
        if (n4.usesTransparency && (i3 = true), n4.indexCount > 256)
          throw new a2(`Frame ${t4} uses more than 256 color indexes`);
        r3.push(n4);
      }
      if (0 === t3)
        return { usesTransparency: i3, palettes: r3 };
      const n3 = /* @__PURE__ */ new Set();
      r3.forEach((e6) => {
        e6.colors.forEach((e7) => {
          n3.add(e7);
        });
      });
      let o3 = n3.size;
      if (i3 && ++o3, t3 && o3 > t3)
        return { usesTransparency: i3, palettes: r3 };
      const s3 = new Array(n3.size), l3 = n3.values();
      for (let e6 = 0; e6 < s3.length; ++e6)
        s3[e6] = l3.next().value;
      return s3.sort((e6, t4) => e6 - t4), { colors: s3, indexCount: o3, usesTransparency: i3, palettes: r3 };
    }, e4.copyAsJimp = function(t3, i3) {
      return e4.shareAsJimp(t3, new r2(i3));
    }, e4.getMaxDimensions = function(e5) {
      let t3 = 0, i3 = 0;
      return e5.forEach((e6) => {
        const r3 = e6.xOffset + e6.bitmap.width;
        r3 > t3 && (t3 = r3);
        const n3 = e6.yOffset + e6.bitmap.height;
        n3 > i3 && (i3 = n3);
      }), { maxWidth: t3, maxHeight: i3 };
    }, e4.quantizeDekker = function(e5, t3, i3) {
      u2(e5, "NeuQuantFloat", t3 = t3 || 256, 0, i3);
    }, e4.quantizeSorokin = function(e5, t3, i3, r3) {
      let n3;
      switch (t3 = t3 || 256, i3 = i3 || "min-pop") {
        case "min-pop":
          n3 = 2;
          break;
        case "top-pop":
          n3 = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${i3}'`);
      }
      u2(e5, "RGBQuant", t3, n3, r3);
    }, e4.quantizeWu = function(e5, t3, i3, r3) {
      if (t3 = t3 || 256, (i3 = i3 || 5) < 1 || i3 > 8)
        throw new Error("Invalid quantization quality");
      u2(e5, "WuQuant", t3, i3, r3);
    }, e4.read = function(e5, i3) {
      return i3 = i3 || l2, Buffer2.isBuffer(e5) ? i3.decodeGif(e5) : function(e6) {
        return new Promise((i4, r3) => {
          t2.readFile(e6, (e7, t3) => e7 ? r3(e7) : i4(t3));
        });
      }(e5).then((e6) => i3.decodeGif(e6));
    }, e4.shareAsJimp = function(e5, t3) {
      const i3 = new e5(t3.bitmap.width, t3.bitmap.height, 0);
      return i3.bitmap.data = t3.bitmap.data, i3;
    }, e4.write = function(e5, i3, r3, n3) {
      n3 = n3 || l2;
      const a3 = e5.match(/\.[a-zA-Z]+$/);
      if (null !== a3 && s2.includes(a3[0].toLowerCase()))
        throw new Error(`GIF '${e5}' has an unexpected suffix`);
      return n3.encodeGif(i3, r3).then((i4) => function(e6, i5) {
        return new Promise((r4, n4) => {
          t2.writeFile(e6, i5, (e7) => e7 ? n4(e7) : r4());
        });
      }(e5, i4.buffer).then(() => i4));
    };
  }(gifutil)), gifutil;
}
function requireGifcodec() {
  if (hasRequiredGifcodec)
    return gifcodec;
  hasRequiredGifcodec = 1;
  const e4 = omggif, { Gif: t2, GifError: i2 } = gif$1;
  function r2() {
    const e5 = requireGifutil();
    return r2 = function() {
      return e5;
    }, e5;
  }
  const { GifFrame: n2 } = gifframe;
  function a2(e5, t3) {
    const i3 = e5.indexOf(t3);
    return -1 === i3 ? null : i3;
  }
  function o2(e5, t3) {
    for (var i3, r3 = 0, n3 = e5.length - 1; r3 <= n3; )
      if (e5[i3 = Math.floor((r3 + n3) / 2)] > t3)
        n3 = i3 - 1;
      else {
        if (!(e5[i3] < t3))
          return i3;
        r3 = i3 + 1;
      }
    return null;
  }
  function s2(e5) {
    const t3 = e5.colors;
    e5.usesTransparency && t3.push(0);
    const i3 = t3.length;
    let r3 = 2;
    for (; i3 > r3; )
      r3 <<= 1;
    t3.length = r3, t3.fill(0, i3);
  }
  function l2(e5, t3) {
    let i3 = e5.bitmap.width * e5.bitmap.height;
    return i3 = Math.ceil(i3 * t3 / 8), i3 += Math.ceil(i3 / 255), 100 + i3 + 768;
  }
  function u2(e5) {
    let t3 = e5.indexCount, i3 = 0;
    for (--t3; t3; )
      ++i3, t3 >>= 1;
    return i3 > 0 ? i3 : 1;
  }
  function h2(e5, t3, r3, n3, l3) {
    if (r3.interlaced)
      throw new i2("writing interlaced GIFs is not supported");
    const u3 = function(e6, t4, r4) {
      const n4 = r4.colors, s3 = n4.length <= 8 ? a2 : o2, l4 = t4.bitmap.data, u4 = new Buffer2(l4.length / 4);
      let h4 = n4.length, c2 = 0, f2 = 0;
      for (; c2 < l4.length; ) {
        if (0 !== l4[c2 + 3]) {
          const e7 = l4.readUInt32BE(c2, true) >> 8 & 16777215;
          u4[f2] = s3(n4, e7);
        } else
          u4[f2] = h4;
        c2 += 4, ++f2;
      }
      if (r4.usesTransparency) {
        if (256 === h4)
          throw new i2(`Frame ${e6} already has 256 colorsand so can't use transparency`);
      } else
        h4 = null;
      return { buffer: u4, transparentIndex: h4 };
    }(t3, r3, n3), h3 = { delay: r3.delayCentisecs, disposal: r3.disposalMethod, transparent: u3.transparentIndex };
    l3 && (s2(n3), h3.palette = n3.colors);
    try {
      let t4, i3 = e5.getOutputBuffer(), n4 = e5.getOutputBufferPosition(), a3 = true;
      for (; a3; )
        if (t4 = e5.addFrame(r3.xOffset, r3.yOffset, r3.bitmap.width, r3.bitmap.height, u3.buffer, h3), a3 = false, t4 >= i3.length - 1) {
          const t5 = new Buffer2(1.5 * i3.length);
          i3.copy(t5), e5.setOutputBuffer(t5), e5.setOutputBufferPosition(n4), i3 = t5, a3 = true;
        }
      return i3;
    } catch (e6) {
      throw new i2(e6);
    }
  }
  return gifcodec.GifCodec = class {
    constructor(e5 = {}) {
      this._transparentRGB = null, "number" == typeof e5.transparentRGB && 0 !== e5.transparentRGB && (this._transparentRGBA = 256 * e5.transparentRGB), this._testInitialBufferSize = 0;
    }
    decodeGif(r3) {
      try {
        let n3;
        try {
          n3 = new e4.GifReader(r3);
        } catch (e5) {
          throw new i2(e5);
        }
        const a3 = n3.numFrames(), o3 = [], s3 = { width: n3.width, height: n3.height, loops: n3.loopCount(), usesTransparency: false };
        for (let e5 = 0; e5 < a3; ++e5) {
          const t3 = this._decodeFrame(n3, e5, s3.usesTransparency);
          o3.push(t3.frame), t3.usesTransparency && (s3.usesTransparency = true);
        }
        return Promise.resolve(new t2(r3, o3, s3));
      } catch (e5) {
        return Promise.reject(e5);
      }
    }
    encodeGif(e5, n3 = {}) {
      try {
        if (null === e5 || 0 === e5.length)
          throw new i2("there are no frames");
        const a3 = r2().getMaxDimensions(e5);
        return (n3 = Object.assign({}, n3)).width = a3.maxWidth, n3.height = a3.maxHeight, void 0 === n3.loops && (n3.loops = 0), n3.colorScope = n3.colorScope || t2.GlobalColorsPreferred, Promise.resolve(this._encodeGif(e5, n3));
      } catch (e6) {
        return Promise.reject(e6);
      }
    }
    _decodeFrame(e5, t3, r3) {
      let a3, o3;
      try {
        if (a3 = e5.frameInfo(t3), o3 = new Buffer2(e5.width * e5.height * 4), e5.decodeAndBlitFrameRGBA(t3, o3), a3.width !== e5.width || a3.height !== e5.height) {
          if (a3.y && (o3 = o3.slice(a3.y * e5.width * 4)), e5.width > a3.width)
            for (let t4 = 0; t4 < a3.height; ++t4)
              o3.copy(o3, t4 * a3.width * 4, 4 * (a3.x + t4 * e5.width), 4 * (a3.x + t4 * e5.width) + 4 * a3.width);
          o3 = o3.slice(0, a3.width * a3.height * 4);
        }
      } catch (e6) {
        throw new i2(e6);
      }
      let s3 = false;
      if (null === this._transparentRGBA) {
        if (!r3)
          for (let e6 = 3; e6 < o3.length; e6 += 4)
            0 === o3[e6] && (s3 = true, e6 = o3.length);
      } else
        for (let e6 = 3; e6 < o3.length; e6 += 4)
          0 === o3[e6] && (o3.writeUInt32BE(this._transparentRGBA, e6 - 3), s3 = true);
      return { frame: new n2(a3.width, a3.height, o3, { xOffset: a3.x, yOffset: a3.y, disposalMethod: a3.disposal, interlaced: a3.interlaced, delayCentisecs: a3.delay }), usesTransparency: s3 };
    }
    _encodeGif(n3, a3) {
      let o3;
      if (a3.colorScope === t2.LocalColorsOnly)
        o3 = r2().getColorInfo(n3, 0);
      else if (o3 = r2().getColorInfo(n3, 256), !o3.colors) {
        if (a3.colorScope === t2.GlobalColorsOnly)
          throw new i2("Too many color indexes for global color table");
        a3.colorScope = t2.LocalColorsOnly;
      }
      a3.usesTransparency = o3.usesTransparency;
      const l3 = o3.palettes;
      if (a3.colorScope === t2.LocalColorsOnly) {
        return function(r3, n4, a4, o4) {
          const s3 = { loop: n4.loops };
          let l4, u3 = new Buffer2(a4);
          try {
            l4 = new e4.GifWriter(u3, n4.width, n4.height, s3);
          } catch (e5) {
            throw new i2(e5);
          }
          for (let e5 = 0; e5 < r3.length; ++e5)
            u3 = h2(l4, e5, r3[e5], o4[e5], true);
          return new t2(u3.slice(0, l4.end()), r3, n4);
        }(n3, a3, 2e3, l3);
      }
      return function(r3, n4, a4, o4) {
        const l4 = { colors: o4.colors.slice(), usesTransparency: o4.usesTransparency };
        s2(l4);
        const u3 = { palette: l4.colors, loop: n4.loops };
        let c2, f2 = new Buffer2(a4);
        try {
          c2 = new e4.GifWriter(f2, n4.width, n4.height, u3);
        } catch (e5) {
          throw new i2(e5);
        }
        for (let e5 = 0; e5 < r3.length; ++e5)
          f2 = h2(c2, e5, r3[e5], o4, false);
        return new t2(f2.slice(0, c2.end()), r3, n4);
      }(n3, a3, 2e3, o3);
    }
    _getSizeEstimateGlobal(e5, t3) {
      if (this._testInitialBufferSize > 0)
        return this._testInitialBufferSize;
      let i3 = 968;
      const r3 = u2(e5);
      return t3.forEach((e6) => {
        i3 += l2(e6, r3);
      }), i3;
    }
    _getSizeEstimateLocal(e5, t3) {
      if (this._testInitialBufferSize > 0)
        return this._testInitialBufferSize;
      let i3 = 200;
      for (let r3 = 0; r3 < t3.length; ++r3) {
        const n3 = u2(e5[r3]);
        i3 += l2(t3[r3], n3);
      }
      return i3;
    }
  }, gifcodec;
}
GifFrame$1.DisposeToAnything = 0, GifFrame$1.DisposeNothing = 1, GifFrame$1.DisposeToBackgroundColor = 2, GifFrame$1.DisposeToPrevious = 3, gifframe.GifFrame = GifFrame$1;
var BitmapImage = bitmapimage;
var { Gif, GifError: GifError$1 } = gif$1;
var { GifCodec } = requireGifcodec();
var { GifFrame } = gifframe;
var GifUtil = requireGifutil();
var src = { BitmapImage, Gif, GifCodec, GifFrame, GifUtil, GifError: GifError$1 };
function gif() {
  return { mime: "image/gif", encode: async (e4) => {
    const t2 = new src.BitmapImage(e4);
    src.GifUtil.quantizeDekker(t2, 256);
    const i2 = new src.GifFrame(e4), r2 = new src.GifCodec();
    return (await r2.encodeGif([i2], {})).buffer;
  }, decode: (e4) => {
    const t2 = new omggif.GifReader(e4), i2 = Buffer2.alloc(t2.width * t2.height * 4);
    return t2.decodeAndBlitFrameRGBA(0, i2), { data: i2, width: t2.width, height: t2.height };
  } };
}
var encoder = { exports: {} };
!function(e4) {
  function t2(e5) {
    var t3, i2, r2, n2, a2, o2 = Math.floor, s2 = new Array(64), l2 = new Array(64), u2 = new Array(64), h2 = new Array(64), c2 = new Array(65535), f2 = new Array(65535), d = new Array(64), p2 = new Array(64), m = [], _2 = 0, g = 7, b2 = new Array(64), y2 = new Array(64), w = new Array(64), v2 = new Array(256), x2 = new Array(2048), E2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], k2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], A2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], I = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], M2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], T2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], P = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], B2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
    function C2(e6, t4) {
      for (var i3 = 0, r3 = 0, n3 = new Array(), a3 = 1; a3 <= 16; a3++) {
        for (var o3 = 1; o3 <= e6[a3]; o3++)
          n3[t4[r3]] = [], n3[t4[r3]][0] = i3, n3[t4[r3]][1] = a3, r3++, i3++;
        i3 *= 2;
      }
      return n3;
    }
    function R2(e6) {
      for (var t4 = e6[0], i3 = e6[1] - 1; i3 >= 0; )
        t4 & 1 << i3 && (_2 |= 1 << g), i3--, --g < 0 && (255 == _2 ? (z2(255), z2(0)) : z2(_2), g = 7, _2 = 0);
    }
    function z2(e6) {
      m.push(e6);
    }
    function F(e6) {
      z2(e6 >> 8 & 255), z2(255 & e6);
    }
    function N2(e6, t4, i3, r3, n3) {
      for (var a3, o3 = n3[0], s3 = n3[240], l3 = function(e7, t5) {
        var i4, r4, n4, a4, o4, s4, l4, u4, h4, c3, f3 = 0;
        for (h4 = 0; h4 < 8; ++h4) {
          i4 = e7[f3], r4 = e7[f3 + 1], n4 = e7[f3 + 2], a4 = e7[f3 + 3], o4 = e7[f3 + 4], s4 = e7[f3 + 5], l4 = e7[f3 + 6];
          var p3 = i4 + (u4 = e7[f3 + 7]), m3 = i4 - u4, _4 = r4 + l4, g3 = r4 - l4, b4 = n4 + s4, y4 = n4 - s4, w3 = a4 + o4, v3 = a4 - o4, x3 = p3 + w3, E3 = p3 - w3, k3 = _4 + b4, S3 = _4 - b4;
          e7[f3] = x3 + k3, e7[f3 + 4] = x3 - k3;
          var A3 = 0.707106781 * (S3 + E3);
          e7[f3 + 2] = E3 + A3, e7[f3 + 6] = E3 - A3;
          var I2 = 0.382683433 * ((x3 = v3 + y4) - (S3 = g3 + m3)), M3 = 0.5411961 * x3 + I2, T3 = 1.306562965 * S3 + I2, P2 = 0.707106781 * (k3 = y4 + g3), B3 = m3 + P2, C3 = m3 - P2;
          e7[f3 + 5] = C3 + M3, e7[f3 + 3] = C3 - M3, e7[f3 + 1] = B3 + T3, e7[f3 + 7] = B3 - T3, f3 += 8;
        }
        for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
          i4 = e7[f3], r4 = e7[f3 + 8], n4 = e7[f3 + 16], a4 = e7[f3 + 24], o4 = e7[f3 + 32], s4 = e7[f3 + 40], l4 = e7[f3 + 48];
          var R3 = i4 + (u4 = e7[f3 + 56]), z3 = i4 - u4, F2 = r4 + l4, N3 = r4 - l4, O3 = n4 + s4, D = n4 - s4, $ = a4 + o4, L2 = a4 - o4, U = R3 + $, Z = R3 - $, j = F2 + O3, G = F2 - O3;
          e7[f3] = U + j, e7[f3 + 32] = U - j;
          var H = 0.707106781 * (G + Z);
          e7[f3 + 16] = Z + H, e7[f3 + 48] = Z - H;
          var Q = 0.382683433 * ((U = L2 + D) - (G = N3 + z3)), W = 0.5411961 * U + Q, q = 1.306562965 * G + Q, V = 0.707106781 * (j = D + N3), Y2 = z3 + V, K = z3 - V;
          e7[f3 + 40] = K + W, e7[f3 + 24] = K - W, e7[f3 + 8] = Y2 + q, e7[f3 + 56] = Y2 - q, f3++;
        }
        for (h4 = 0; h4 < 64; ++h4)
          c3 = e7[h4] * t5[h4], d[h4] = c3 > 0 ? c3 + 0.5 | 0 : c3 - 0.5 | 0;
        return d;
      }(e6, t4), u3 = 0; u3 < 64; ++u3)
        p2[E2[u3]] = l3[u3];
      var h3 = p2[0] - i3;
      i3 = p2[0], 0 == h3 ? R2(r3[0]) : (R2(r3[f2[a3 = 32767 + h3]]), R2(c2[a3]));
      for (var m2 = 63; m2 > 0 && 0 == p2[m2]; m2--)
        ;
      if (0 == m2)
        return R2(o3), i3;
      for (var _3, g2 = 1; g2 <= m2; ) {
        for (var b3 = g2; 0 == p2[g2] && g2 <= m2; ++g2)
          ;
        var y3 = g2 - b3;
        if (y3 >= 16) {
          _3 = y3 >> 4;
          for (var w2 = 1; w2 <= _3; ++w2)
            R2(s3);
          y3 &= 15;
        }
        a3 = 32767 + p2[g2], R2(n3[(y3 << 4) + f2[a3]]), R2(c2[a3]), g2++;
      }
      return 63 != m2 && R2(o3), i3;
    }
    function O2(e6) {
      if (e6 <= 0 && (e6 = 1), e6 > 100 && (e6 = 100), a2 != e6) {
        (function(e7) {
          for (var t4 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], i3 = 0; i3 < 64; i3++) {
            var r3 = o2((t4[i3] * e7 + 50) / 100);
            r3 < 1 ? r3 = 1 : r3 > 255 && (r3 = 255), s2[E2[i3]] = r3;
          }
          for (var n3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
            var c3 = o2((n3[a3] * e7 + 50) / 100);
            c3 < 1 ? c3 = 1 : c3 > 255 && (c3 = 255), l2[E2[a3]] = c3;
          }
          for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d2 = 0, p3 = 0; p3 < 8; p3++)
            for (var m2 = 0; m2 < 8; m2++)
              u2[d2] = 1 / (s2[E2[d2]] * f3[p3] * f3[m2] * 8), h2[d2] = 1 / (l2[E2[d2]] * f3[p3] * f3[m2] * 8), d2++;
        })(e6 < 50 ? Math.floor(5e3 / e6) : Math.floor(200 - 2 * e6)), a2 = e6;
      }
    }
    this.encode = function(e6, a3) {
      var o3;
      new Date().getTime(), a3 && O2(a3), m = new Array(), _2 = 0, g = 7, F(65496), F(65504), F(16), z2(74), z2(70), z2(73), z2(70), z2(0), z2(1), z2(1), z2(0), F(1), F(1), z2(0), z2(0), void 0 !== (o3 = e6.comments) && o3.constructor === Array && o3.forEach((e7) => {
        if ("string" == typeof e7) {
          F(65534);
          var t4, i3 = e7.length;
          for (F(i3 + 2), t4 = 0; t4 < i3; t4++)
            z2(e7.charCodeAt(t4));
        }
      }), function(e7) {
        if (e7) {
          F(65505), 69 === e7[0] && 120 === e7[1] && 105 === e7[2] && 102 === e7[3] ? F(e7.length + 2) : (F(e7.length + 5 + 2), z2(69), z2(120), z2(105), z2(102), z2(0));
          for (var t4 = 0; t4 < e7.length; t4++)
            z2(e7[t4]);
        }
      }(e6.exifBuffer), function() {
        F(65499), F(132), z2(0);
        for (var e7 = 0; e7 < 64; e7++)
          z2(s2[e7]);
        z2(1);
        for (var t4 = 0; t4 < 64; t4++)
          z2(l2[t4]);
      }(), function(e7, t4) {
        F(65472), F(17), z2(8), F(t4), F(e7), z2(3), z2(1), z2(17), z2(0), z2(2), z2(17), z2(1), z2(3), z2(17), z2(1);
      }(e6.width, e6.height), function() {
        F(65476), F(418), z2(0);
        for (var e7 = 0; e7 < 16; e7++)
          z2(k2[e7 + 1]);
        for (var t4 = 0; t4 <= 11; t4++)
          z2(S2[t4]);
        z2(16);
        for (var i3 = 0; i3 < 16; i3++)
          z2(A2[i3 + 1]);
        for (var r3 = 0; r3 <= 161; r3++)
          z2(I[r3]);
        z2(1);
        for (var n3 = 0; n3 < 16; n3++)
          z2(M2[n3 + 1]);
        for (var a4 = 0; a4 <= 11; a4++)
          z2(T2[a4]);
        z2(17);
        for (var o4 = 0; o4 < 16; o4++)
          z2(P[o4 + 1]);
        for (var s3 = 0; s3 <= 161; s3++)
          z2(B2[s3]);
      }(), F(65498), F(12), z2(3), z2(1), z2(0), z2(2), z2(17), z2(3), z2(17), z2(0), z2(63), z2(0);
      var c3 = 0, f3 = 0, d2 = 0;
      _2 = 0, g = 7, this.encode.displayName = "_encode_";
      for (var p3, v3, E3, C3, D, $, L2, U, Z, j = e6.data, G = e6.width, H = e6.height, Q = 4 * G, W = 0; W < H; ) {
        for (p3 = 0; p3 < Q; ) {
          for ($ = D = Q * W + p3, L2 = -1, U = 0, Z = 0; Z < 64; Z++)
            $ = D + (U = Z >> 3) * Q + (L2 = 4 * (7 & Z)), W + U >= H && ($ -= Q * (W + 1 + U - H)), p3 + L2 >= Q && ($ -= p3 + L2 - Q + 4), v3 = j[$++], E3 = j[$++], C3 = j[$++], b2[Z] = (x2[v3] + x2[E3 + 256 | 0] + x2[C3 + 512 | 0] >> 16) - 128, y2[Z] = (x2[v3 + 768 | 0] + x2[E3 + 1024 | 0] + x2[C3 + 1280 | 0] >> 16) - 128, w[Z] = (x2[v3 + 1280 | 0] + x2[E3 + 1536 | 0] + x2[C3 + 1792 | 0] >> 16) - 128;
          c3 = N2(b2, u2, c3, t3, r2), f3 = N2(y2, h2, f3, i2, n2), d2 = N2(w, h2, d2, i2, n2), p3 += 32;
        }
        W += 8;
      }
      if (g >= 0) {
        var q = [];
        q[1] = g + 1, q[0] = (1 << g + 1) - 1, R2(q);
      }
      return F(65497), Buffer2.from(m);
    }, new Date().getTime(), e5 || (e5 = 50), function() {
      for (var e6 = String.fromCharCode, t4 = 0; t4 < 256; t4++)
        v2[t4] = e6(t4);
    }(), t3 = C2(k2, S2), i2 = C2(M2, T2), r2 = C2(A2, I), n2 = C2(P, B2), function() {
      for (var e6 = 1, t4 = 2, i3 = 1; i3 <= 15; i3++) {
        for (var r3 = e6; r3 < t4; r3++)
          f2[32767 + r3] = i3, c2[32767 + r3] = [], c2[32767 + r3][1] = i3, c2[32767 + r3][0] = r3;
        for (var n3 = -(t4 - 1); n3 <= -e6; n3++)
          f2[32767 + n3] = i3, c2[32767 + n3] = [], c2[32767 + n3][1] = i3, c2[32767 + n3][0] = t4 - 1 + n3;
        e6 <<= 1, t4 <<= 1;
      }
    }(), function() {
      for (var e6 = 0; e6 < 256; e6++)
        x2[e6] = 19595 * e6, x2[e6 + 256 | 0] = 38470 * e6, x2[e6 + 512 | 0] = 7471 * e6 + 32768, x2[e6 + 768 | 0] = -11059 * e6, x2[e6 + 1024 | 0] = -21709 * e6, x2[e6 + 1280 | 0] = 32768 * e6 + 8421375, x2[e6 + 1536 | 0] = -27439 * e6, x2[e6 + 1792 | 0] = -5329 * e6;
    }(), O2(e5), new Date().getTime();
  }
  encoder.exports = function(e5, i2) {
    void 0 === i2 && (i2 = 50);
    var r2 = new t2(i2), n2 = r2.encode(e5, i2);
    return { data: n2, width: e5.width, height: e5.height };
  };
}();
var encoderExports = encoder.exports;
var decoder = { exports: {} };
var module2;
var JpegImage;
module2 = decoder, JpegImage = function() {
  var e4 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t2 = 4017, i2 = 799, r2 = 3406, n2 = 2276, a2 = 1567, o2 = 3784, s2 = 5793, l2 = 2896;
  function u2() {
  }
  function h2(e5, t3) {
    for (var i3, r3, n3 = 0, a3 = [], o3 = 16; o3 > 0 && !e5[o3 - 1]; )
      o3--;
    a3.push({ children: [], index: 0 });
    var s3, l3 = a3[0];
    for (i3 = 0; i3 < o3; i3++) {
      for (r3 = 0; r3 < e5[i3]; r3++) {
        for ((l3 = a3.pop()).children[l3.index] = t3[n3]; l3.index > 0; ) {
          if (0 === a3.length)
            throw new Error("Could not recreate Huffman Table");
          l3 = a3.pop();
        }
        for (l3.index++, a3.push(l3); a3.length <= i3; )
          a3.push(s3 = { children: [], index: 0 }), l3.children[l3.index] = s3.children, l3 = s3;
        n3++;
      }
      i3 + 1 < o3 && (a3.push(s3 = { children: [], index: 0 }), l3.children[l3.index] = s3.children, l3 = s3);
    }
    return a3[0].children;
  }
  function c2(t3, i3, r3, n3, a3, o3, s3, l3, u3, h3) {
    r3.precision, r3.samplesPerLine, r3.scanLines;
    var c3 = r3.mcusPerLine, f3 = r3.progressive;
    r3.maxH, r3.maxV;
    var d2 = i3, p3 = 0, m2 = 0;
    function _3() {
      if (m2 > 0)
        return m2--, p3 >> m2 & 1;
      if (255 == (p3 = t3[i3++])) {
        var e5 = t3[i3++];
        if (e5)
          throw new Error("unexpected marker: " + (p3 << 8 | e5).toString(16));
      }
      return m2 = 7, p3 >>> 7;
    }
    function g(e5) {
      for (var t4, i4 = e5; null !== (t4 = _3()); ) {
        if ("number" == typeof (i4 = i4[t4]))
          return i4;
        if ("object" != typeof i4)
          throw new Error("invalid huffman sequence");
      }
      return null;
    }
    function b2(e5) {
      for (var t4 = 0; e5 > 0; ) {
        var i4 = _3();
        if (null === i4)
          return;
        t4 = t4 << 1 | i4, e5--;
      }
      return t4;
    }
    function y2(e5) {
      var t4 = b2(e5);
      return t4 >= 1 << e5 - 1 ? t4 : t4 + (-1 << e5) + 1;
    }
    var w, v2 = 0, x2 = 0;
    function E2(e5, t4, i4, r4, n4) {
      var a4 = i4 % c3, o4 = (i4 / c3 | 0) * e5.v + r4, s4 = a4 * e5.h + n4;
      void 0 === e5.blocks[o4] && h3.tolerantDecoding || t4(e5, e5.blocks[o4][s4]);
    }
    function k2(e5, t4, i4) {
      var r4 = i4 / e5.blocksPerLine | 0, n4 = i4 % e5.blocksPerLine;
      void 0 === e5.blocks[r4] && h3.tolerantDecoding || t4(e5, e5.blocks[r4][n4]);
    }
    var S2, A2, I, M2, T2, P, B2 = n3.length;
    P = f3 ? 0 === o3 ? 0 === l3 ? function(e5, t4) {
      var i4 = g(e5.huffmanTableDC), r4 = 0 === i4 ? 0 : y2(i4) << u3;
      t4[0] = e5.pred += r4;
    } : function(e5, t4) {
      t4[0] |= _3() << u3;
    } : 0 === l3 ? function(t4, i4) {
      if (v2 > 0)
        v2--;
      else
        for (var r4 = o3, n4 = s3; r4 <= n4; ) {
          var a4 = g(t4.huffmanTableAC), l4 = 15 & a4, h4 = a4 >> 4;
          if (0 !== l4)
            i4[e4[r4 += h4]] = y2(l4) * (1 << u3), r4++;
          else {
            if (h4 < 15) {
              v2 = b2(h4) + (1 << h4) - 1;
              break;
            }
            r4 += 16;
          }
        }
    } : function(t4, i4) {
      for (var r4 = o3, n4 = s3, a4 = 0; r4 <= n4; ) {
        var l4 = e4[r4], h4 = i4[l4] < 0 ? -1 : 1;
        switch (x2) {
          case 0:
            var c4 = g(t4.huffmanTableAC), f4 = 15 & c4;
            if (a4 = c4 >> 4, 0 === f4)
              a4 < 15 ? (v2 = b2(a4) + (1 << a4), x2 = 4) : (a4 = 16, x2 = 1);
            else {
              if (1 !== f4)
                throw new Error("invalid ACn encoding");
              w = y2(f4), x2 = a4 ? 2 : 3;
            }
            continue;
          case 1:
          case 2:
            i4[l4] ? i4[l4] += (_3() << u3) * h4 : 0 == --a4 && (x2 = 2 == x2 ? 3 : 0);
            break;
          case 3:
            i4[l4] ? i4[l4] += (_3() << u3) * h4 : (i4[l4] = w << u3, x2 = 0);
            break;
          case 4:
            i4[l4] && (i4[l4] += (_3() << u3) * h4);
        }
        r4++;
      }
      4 === x2 && 0 == --v2 && (x2 = 0);
    } : function(t4, i4) {
      var r4 = g(t4.huffmanTableDC), n4 = 0 === r4 ? 0 : y2(r4);
      i4[0] = t4.pred += n4;
      for (var a4 = 1; a4 < 64; ) {
        var o4 = g(t4.huffmanTableAC), s4 = 15 & o4, l4 = o4 >> 4;
        if (0 !== s4)
          i4[e4[a4 += l4]] = y2(s4), a4++;
        else {
          if (l4 < 15)
            break;
          a4 += 16;
        }
      }
    };
    var C2, R2, z2, F, N2 = 0;
    for (R2 = 1 == B2 ? n3[0].blocksPerLine * n3[0].blocksPerColumn : c3 * r3.mcusPerColumn, a3 || (a3 = R2); N2 < R2; ) {
      for (A2 = 0; A2 < B2; A2++)
        n3[A2].pred = 0;
      if (v2 = 0, 1 == B2)
        for (S2 = n3[0], T2 = 0; T2 < a3; T2++)
          k2(S2, P, N2), N2++;
      else
        for (T2 = 0; T2 < a3; T2++) {
          for (A2 = 0; A2 < B2; A2++)
            for (z2 = (S2 = n3[A2]).h, F = S2.v, I = 0; I < F; I++)
              for (M2 = 0; M2 < z2; M2++)
                E2(S2, P, N2, I, M2);
          if (++N2 === R2)
            break;
        }
      if (N2 === R2)
        do {
          if (255 === t3[i3] && 0 !== t3[i3 + 1])
            break;
          i3 += 1;
        } while (i3 < t3.length - 2);
      if (m2 = 0, (C2 = t3[i3] << 8 | t3[i3 + 1]) < 65280)
        throw new Error("marker was not found");
      if (!(C2 >= 65488 && C2 <= 65495))
        break;
      i3 += 2;
    }
    return i3 - d2;
  }
  function f2(e5, u3) {
    var h3, c3, f3 = [], d2 = u3.blocksPerLine, p3 = u3.blocksPerColumn, m2 = d2 << 3, g = new Int32Array(64), b2 = new Uint8Array(64);
    function y2(e6, h4, c4) {
      var f4, d3, p4, m3, _3, g2, b3, y3, w2, v3, x3 = u3.quantizationTable, E3 = c4;
      for (v3 = 0; v3 < 64; v3++)
        E3[v3] = e6[v3] * x3[v3];
      for (v3 = 0; v3 < 8; ++v3) {
        var k3 = 8 * v3;
        0 != E3[1 + k3] || 0 != E3[2 + k3] || 0 != E3[3 + k3] || 0 != E3[4 + k3] || 0 != E3[5 + k3] || 0 != E3[6 + k3] || 0 != E3[7 + k3] ? (f4 = s2 * E3[0 + k3] + 128 >> 8, d3 = s2 * E3[4 + k3] + 128 >> 8, p4 = E3[2 + k3], m3 = E3[6 + k3], _3 = l2 * (E3[1 + k3] - E3[7 + k3]) + 128 >> 8, y3 = l2 * (E3[1 + k3] + E3[7 + k3]) + 128 >> 8, g2 = E3[3 + k3] << 4, b3 = E3[5 + k3] << 4, w2 = f4 - d3 + 1 >> 1, f4 = f4 + d3 + 1 >> 1, d3 = w2, w2 = p4 * o2 + m3 * a2 + 128 >> 8, p4 = p4 * a2 - m3 * o2 + 128 >> 8, m3 = w2, w2 = _3 - b3 + 1 >> 1, _3 = _3 + b3 + 1 >> 1, b3 = w2, w2 = y3 + g2 + 1 >> 1, g2 = y3 - g2 + 1 >> 1, y3 = w2, w2 = f4 - m3 + 1 >> 1, f4 = f4 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p4 + 1 >> 1, d3 = d3 + p4 + 1 >> 1, p4 = w2, w2 = _3 * n2 + y3 * r2 + 2048 >> 12, _3 = _3 * r2 - y3 * n2 + 2048 >> 12, y3 = w2, w2 = g2 * i2 + b3 * t2 + 2048 >> 12, g2 = g2 * t2 - b3 * i2 + 2048 >> 12, b3 = w2, E3[0 + k3] = f4 + y3, E3[7 + k3] = f4 - y3, E3[1 + k3] = d3 + b3, E3[6 + k3] = d3 - b3, E3[2 + k3] = p4 + g2, E3[5 + k3] = p4 - g2, E3[3 + k3] = m3 + _3, E3[4 + k3] = m3 - _3) : (w2 = s2 * E3[0 + k3] + 512 >> 10, E3[0 + k3] = w2, E3[1 + k3] = w2, E3[2 + k3] = w2, E3[3 + k3] = w2, E3[4 + k3] = w2, E3[5 + k3] = w2, E3[6 + k3] = w2, E3[7 + k3] = w2);
      }
      for (v3 = 0; v3 < 8; ++v3) {
        var S3 = v3;
        0 != E3[8 + S3] || 0 != E3[16 + S3] || 0 != E3[24 + S3] || 0 != E3[32 + S3] || 0 != E3[40 + S3] || 0 != E3[48 + S3] || 0 != E3[56 + S3] ? (f4 = s2 * E3[0 + S3] + 2048 >> 12, d3 = s2 * E3[32 + S3] + 2048 >> 12, p4 = E3[16 + S3], m3 = E3[48 + S3], _3 = l2 * (E3[8 + S3] - E3[56 + S3]) + 2048 >> 12, y3 = l2 * (E3[8 + S3] + E3[56 + S3]) + 2048 >> 12, g2 = E3[24 + S3], b3 = E3[40 + S3], w2 = f4 - d3 + 1 >> 1, f4 = f4 + d3 + 1 >> 1, d3 = w2, w2 = p4 * o2 + m3 * a2 + 2048 >> 12, p4 = p4 * a2 - m3 * o2 + 2048 >> 12, m3 = w2, w2 = _3 - b3 + 1 >> 1, _3 = _3 + b3 + 1 >> 1, b3 = w2, w2 = y3 + g2 + 1 >> 1, g2 = y3 - g2 + 1 >> 1, y3 = w2, w2 = f4 - m3 + 1 >> 1, f4 = f4 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p4 + 1 >> 1, d3 = d3 + p4 + 1 >> 1, p4 = w2, w2 = _3 * n2 + y3 * r2 + 2048 >> 12, _3 = _3 * r2 - y3 * n2 + 2048 >> 12, y3 = w2, w2 = g2 * i2 + b3 * t2 + 2048 >> 12, g2 = g2 * t2 - b3 * i2 + 2048 >> 12, b3 = w2, E3[0 + S3] = f4 + y3, E3[56 + S3] = f4 - y3, E3[8 + S3] = d3 + b3, E3[48 + S3] = d3 - b3, E3[16 + S3] = p4 + g2, E3[40 + S3] = p4 - g2, E3[24 + S3] = m3 + _3, E3[32 + S3] = m3 - _3) : (w2 = s2 * c4[v3 + 0] + 8192 >> 14, E3[0 + S3] = w2, E3[8 + S3] = w2, E3[16 + S3] = w2, E3[24 + S3] = w2, E3[32 + S3] = w2, E3[40 + S3] = w2, E3[48 + S3] = w2, E3[56 + S3] = w2);
      }
      for (v3 = 0; v3 < 64; ++v3) {
        var A2 = 128 + (E3[v3] + 8 >> 4);
        h4[v3] = A2 < 0 ? 0 : A2 > 255 ? 255 : A2;
      }
    }
    _2(m2 * p3 * 8);
    for (var w = 0; w < p3; w++) {
      var v2 = w << 3;
      for (h3 = 0; h3 < 8; h3++)
        f3.push(new Uint8Array(m2));
      for (var x2 = 0; x2 < d2; x2++) {
        y2(u3.blocks[w][x2], b2, g);
        var E2 = 0, k2 = x2 << 3;
        for (c3 = 0; c3 < 8; c3++) {
          var S2 = f3[v2 + c3];
          for (h3 = 0; h3 < 8; h3++)
            S2[k2 + h3] = b2[E2++];
        }
      }
    }
    return f3;
  }
  function d(e5) {
    return e5 < 0 ? 0 : e5 > 255 ? 255 : e5;
  }
  u2.prototype = { load: function(e5) {
    var t3 = new XMLHttpRequest();
    t3.open("GET", e5, true), t3.responseType = "arraybuffer", t3.onload = function() {
      var e6 = new Uint8Array(t3.response || t3.mozResponseArrayBuffer);
      this.parse(e6), this.onload && this.onload();
    }.bind(this), t3.send(null);
  }, parse: function(t3) {
    var i3 = 1e3 * this.opts.maxResolutionInMP * 1e3, r3 = 0;
    function n3() {
      var e5 = t3[r3] << 8 | t3[r3 + 1];
      return r3 += 2, e5;
    }
    function a3(e5) {
      var t4, i4, r4 = 1, n4 = 1;
      for (i4 in e5.components)
        e5.components.hasOwnProperty(i4) && (r4 < (t4 = e5.components[i4]).h && (r4 = t4.h), n4 < t4.v && (n4 = t4.v));
      var a4 = Math.ceil(e5.samplesPerLine / 8 / r4), o4 = Math.ceil(e5.scanLines / 8 / n4);
      for (i4 in e5.components)
        if (e5.components.hasOwnProperty(i4)) {
          t4 = e5.components[i4];
          var s4 = Math.ceil(Math.ceil(e5.samplesPerLine / 8) * t4.h / r4), l4 = Math.ceil(Math.ceil(e5.scanLines / 8) * t4.v / n4), u4 = a4 * t4.h, h3 = o4 * t4.v, c3 = [];
          _2(h3 * u4 * 256);
          for (var f3 = 0; f3 < h3; f3++) {
            for (var d3 = [], p4 = 0; p4 < u4; p4++)
              d3.push(new Int32Array(64));
            c3.push(d3);
          }
          t4.blocksPerLine = s4, t4.blocksPerColumn = l4, t4.blocks = c3;
        }
      e5.maxH = r4, e5.maxV = n4, e5.mcusPerLine = a4, e5.mcusPerColumn = o4;
    }
    t3.length;
    var o3, s3, l3, u3, d2 = null, p3 = null, m2 = [], g = [], b2 = [], y2 = [], w = n3(), v2 = -1;
    if (this.comments = [], 65496 != w)
      throw new Error("SOI not found");
    for (w = n3(); 65497 != w; ) {
      switch (w) {
        case 65280:
          break;
        case 65504:
        case 65505:
        case 65506:
        case 65507:
        case 65508:
        case 65509:
        case 65510:
        case 65511:
        case 65512:
        case 65513:
        case 65514:
        case 65515:
        case 65516:
        case 65517:
        case 65518:
        case 65519:
        case 65534:
          var x2 = (l3 = void 0, u3 = void 0, l3 = n3(), u3 = t3.subarray(r3, r3 + l3 - 2), r3 += u3.length, u3);
          if (65534 === w) {
            var E2 = String.fromCharCode.apply(null, x2);
            this.comments.push(E2);
          }
          65504 === w && 74 === x2[0] && 70 === x2[1] && 73 === x2[2] && 70 === x2[3] && 0 === x2[4] && (d2 = { version: { major: x2[5], minor: x2[6] }, densityUnits: x2[7], xDensity: x2[8] << 8 | x2[9], yDensity: x2[10] << 8 | x2[11], thumbWidth: x2[12], thumbHeight: x2[13], thumbData: x2.subarray(14, 14 + 3 * x2[12] * x2[13]) }), 65505 === w && 69 === x2[0] && 120 === x2[1] && 105 === x2[2] && 102 === x2[3] && 0 === x2[4] && (this.exifBuffer = x2.subarray(5, x2.length)), 65518 === w && 65 === x2[0] && 100 === x2[1] && 111 === x2[2] && 98 === x2[3] && 101 === x2[4] && 0 === x2[5] && (p3 = { version: x2[6], flags0: x2[7] << 8 | x2[8], flags1: x2[9] << 8 | x2[10], transformCode: x2[11] });
          break;
        case 65499:
          for (var k2 = n3() + r3 - 2; r3 < k2; ) {
            var S2 = t3[r3++];
            _2(256);
            var A2 = new Int32Array(64);
            if (S2 >> 4) {
              if (S2 >> 4 != 1)
                throw new Error("DQT: invalid table spec");
              for (q = 0; q < 64; q++)
                A2[e4[q]] = n3();
            } else
              for (q = 0; q < 64; q++)
                A2[e4[q]] = t3[r3++];
            m2[15 & S2] = A2;
          }
          break;
        case 65472:
        case 65473:
        case 65474:
          n3(), (o3 = {}).extended = 65473 === w, o3.progressive = 65474 === w, o3.precision = t3[r3++], o3.scanLines = n3(), o3.samplesPerLine = n3(), o3.components = {}, o3.componentsOrder = [];
          var I = o3.scanLines * o3.samplesPerLine;
          if (I > i3) {
            var M2 = Math.ceil((I - i3) / 1e6);
            throw new Error(`maxResolutionInMP limit exceeded by ${M2}MP`);
          }
          var T2, P = t3[r3++];
          for (Q = 0; Q < P; Q++) {
            T2 = t3[r3];
            var B2 = t3[r3 + 1] >> 4, C2 = 15 & t3[r3 + 1], R2 = t3[r3 + 2];
            if (B2 <= 0 || C2 <= 0)
              throw new Error("Invalid sampling factor, expected values above 0");
            o3.componentsOrder.push(T2), o3.components[T2] = { h: B2, v: C2, quantizationIdx: R2 }, r3 += 3;
          }
          a3(o3), g.push(o3);
          break;
        case 65476:
          var z2 = n3();
          for (Q = 2; Q < z2; ) {
            var F = t3[r3++], N2 = new Uint8Array(16), O2 = 0;
            for (q = 0; q < 16; q++, r3++)
              O2 += N2[q] = t3[r3];
            _2(16 + O2);
            var D = new Uint8Array(O2);
            for (q = 0; q < O2; q++, r3++)
              D[q] = t3[r3];
            Q += 17 + O2, (F >> 4 ? b2 : y2)[15 & F] = h2(N2, D);
          }
          break;
        case 65501:
          n3(), s3 = n3();
          break;
        case 65500:
          n3(), n3();
          break;
        case 65498:
          n3();
          var $ = t3[r3++], L2 = [];
          for (Q = 0; Q < $; Q++) {
            V = o3.components[t3[r3++]];
            var U = t3[r3++];
            V.huffmanTableDC = y2[U >> 4], V.huffmanTableAC = b2[15 & U], L2.push(V);
          }
          var Z = t3[r3++], j = t3[r3++], G = t3[r3++], H = c2(t3, r3, o3, L2, s3, Z, j, G >> 4, 15 & G, this.opts);
          r3 += H;
          break;
        case 65535:
          255 !== t3[r3] && r3--;
          break;
        default:
          if (255 == t3[r3 - 3] && t3[r3 - 2] >= 192 && t3[r3 - 2] <= 254) {
            r3 -= 3;
            break;
          }
          if (224 === w || 225 == w) {
            if (-1 !== v2)
              throw new Error(`first unknown JPEG marker at offset ${v2.toString(16)}, second unknown JPEG marker ${w.toString(16)} at offset ${(r3 - 1).toString(16)}`);
            v2 = r3 - 1;
            const e5 = n3();
            if (255 === t3[r3 + e5 - 2]) {
              r3 += e5 - 2;
              break;
            }
          }
          throw new Error("unknown JPEG marker " + w.toString(16));
      }
      w = n3();
    }
    if (1 != g.length)
      throw new Error("only single frame JPEGs supported");
    for (var Q = 0; Q < g.length; Q++) {
      var W = g[Q].components;
      for (var q in W)
        W[q].quantizationTable = m2[W[q].quantizationIdx], delete W[q].quantizationIdx;
    }
    for (this.width = o3.samplesPerLine, this.height = o3.scanLines, this.jfif = d2, this.adobe = p3, this.components = [], Q = 0; Q < o3.componentsOrder.length; Q++) {
      var V = o3.components[o3.componentsOrder[Q]];
      this.components.push({ lines: f2(0, V), scaleX: V.h / o3.maxH, scaleY: V.v / o3.maxV });
    }
  }, getData: function(e5, t3) {
    var i3, r3, n3, a3, o3, s3, l3, u3, h3, c3, f3, p3, m2, g, b2, y2, w, v2, x2, E2, k2, S2 = this.width / e5, A2 = this.height / t3, I = 0, M2 = e5 * t3 * this.components.length;
    _2(M2);
    var T2 = new Uint8Array(M2);
    switch (this.components.length) {
      case 1:
        for (i3 = this.components[0], c3 = 0; c3 < t3; c3++)
          for (o3 = i3.lines[0 | c3 * i3.scaleY * A2], h3 = 0; h3 < e5; h3++)
            f3 = o3[0 | h3 * i3.scaleX * S2], T2[I++] = f3;
        break;
      case 2:
        for (i3 = this.components[0], r3 = this.components[1], c3 = 0; c3 < t3; c3++)
          for (o3 = i3.lines[0 | c3 * i3.scaleY * A2], s3 = r3.lines[0 | c3 * r3.scaleY * A2], h3 = 0; h3 < e5; h3++)
            f3 = o3[0 | h3 * i3.scaleX * S2], T2[I++] = f3, f3 = s3[0 | h3 * r3.scaleX * S2], T2[I++] = f3;
        break;
      case 3:
        for (k2 = true, this.adobe && this.adobe.transformCode ? k2 = true : void 0 !== this.opts.colorTransform && (k2 = !!this.opts.colorTransform), i3 = this.components[0], r3 = this.components[1], n3 = this.components[2], c3 = 0; c3 < t3; c3++)
          for (o3 = i3.lines[0 | c3 * i3.scaleY * A2], s3 = r3.lines[0 | c3 * r3.scaleY * A2], l3 = n3.lines[0 | c3 * n3.scaleY * A2], h3 = 0; h3 < e5; h3++)
            k2 ? (f3 = o3[0 | h3 * i3.scaleX * S2], p3 = s3[0 | h3 * r3.scaleX * S2], v2 = d(f3 + 1.402 * ((m2 = l3[0 | h3 * n3.scaleX * S2]) - 128)), x2 = d(f3 - 0.3441363 * (p3 - 128) - 0.71413636 * (m2 - 128)), E2 = d(f3 + 1.772 * (p3 - 128))) : (v2 = o3[0 | h3 * i3.scaleX * S2], x2 = s3[0 | h3 * r3.scaleX * S2], E2 = l3[0 | h3 * n3.scaleX * S2]), T2[I++] = v2, T2[I++] = x2, T2[I++] = E2;
        break;
      case 4:
        if (!this.adobe)
          throw new Error("Unsupported color mode (4 components)");
        for (k2 = false, this.adobe && this.adobe.transformCode ? k2 = true : void 0 !== this.opts.colorTransform && (k2 = !!this.opts.colorTransform), i3 = this.components[0], r3 = this.components[1], n3 = this.components[2], a3 = this.components[3], c3 = 0; c3 < t3; c3++)
          for (o3 = i3.lines[0 | c3 * i3.scaleY * A2], s3 = r3.lines[0 | c3 * r3.scaleY * A2], l3 = n3.lines[0 | c3 * n3.scaleY * A2], u3 = a3.lines[0 | c3 * a3.scaleY * A2], h3 = 0; h3 < e5; h3++)
            k2 ? (f3 = o3[0 | h3 * i3.scaleX * S2], p3 = s3[0 | h3 * r3.scaleX * S2], m2 = l3[0 | h3 * n3.scaleX * S2], g = u3[0 | h3 * a3.scaleX * S2], b2 = 255 - d(f3 + 1.402 * (m2 - 128)), y2 = 255 - d(f3 - 0.3441363 * (p3 - 128) - 0.71413636 * (m2 - 128)), w = 255 - d(f3 + 1.772 * (p3 - 128))) : (b2 = o3[0 | h3 * i3.scaleX * S2], y2 = s3[0 | h3 * r3.scaleX * S2], w = l3[0 | h3 * n3.scaleX * S2], g = u3[0 | h3 * a3.scaleX * S2]), T2[I++] = 255 - b2, T2[I++] = 255 - y2, T2[I++] = 255 - w, T2[I++] = 255 - g;
        break;
      default:
        throw new Error("Unsupported color mode");
    }
    return T2;
  }, copyToImageData: function(e5, t3) {
    var i3, r3, n3, a3, o3, s3, l3, u3, h3, c3 = e5.width, f3 = e5.height, p3 = e5.data, m2 = this.getData(c3, f3), _3 = 0, g = 0;
    switch (this.components.length) {
      case 1:
        for (r3 = 0; r3 < f3; r3++)
          for (i3 = 0; i3 < c3; i3++)
            n3 = m2[_3++], p3[g++] = n3, p3[g++] = n3, p3[g++] = n3, t3 && (p3[g++] = 255);
        break;
      case 3:
        for (r3 = 0; r3 < f3; r3++)
          for (i3 = 0; i3 < c3; i3++)
            l3 = m2[_3++], u3 = m2[_3++], h3 = m2[_3++], p3[g++] = l3, p3[g++] = u3, p3[g++] = h3, t3 && (p3[g++] = 255);
        break;
      case 4:
        for (r3 = 0; r3 < f3; r3++)
          for (i3 = 0; i3 < c3; i3++)
            o3 = m2[_3++], s3 = m2[_3++], n3 = m2[_3++], l3 = 255 - d(o3 * (1 - (a3 = m2[_3++]) / 255) + a3), u3 = 255 - d(s3 * (1 - a3 / 255) + a3), h3 = 255 - d(n3 * (1 - a3 / 255) + a3), p3[g++] = l3, p3[g++] = u3, p3[g++] = h3, t3 && (p3[g++] = 255);
        break;
      default:
        throw new Error("Unsupported color mode");
    }
  } };
  var p2 = 0, m = 0;
  function _2(e5 = 0) {
    var t3 = p2 + e5;
    if (t3 > m) {
      var i3 = Math.ceil((t3 - m) / 1024 / 1024);
      throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${i3}MB`);
    }
    p2 = t3;
  }
  return u2.resetMaxMemoryUsage = function(e5) {
    p2 = 0, m = e5;
  }, u2.getBytesAllocated = function() {
    return p2;
  }, u2.requestMemoryAllocation = _2, u2;
}(), module2.exports = function(e4, t2 = {}) {
  var i2 = { colorTransform: void 0, useTArray: false, formatAsRGBA: true, tolerantDecoding: true, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...t2 }, r2 = new Uint8Array(e4), n2 = new JpegImage();
  n2.opts = i2, JpegImage.resetMaxMemoryUsage(1024 * i2.maxMemoryUsageInMB * 1024), n2.parse(r2);
  var a2 = i2.formatAsRGBA ? 4 : 3, o2 = n2.width * n2.height * a2;
  try {
    JpegImage.requestMemoryAllocation(o2);
    var s2 = { width: n2.width, height: n2.height, exifBuffer: n2.exifBuffer, data: i2.useTArray ? new Uint8Array(o2) : Buffer2.alloc(o2) };
    n2.comments.length > 0 && (s2.comments = n2.comments);
  } catch (e5) {
    if (e5 instanceof RangeError)
      throw new Error("Could not allocate enough memory for the image. Required: " + o2);
    if (e5 instanceof ReferenceError && "Buffer is not defined" === e5.message)
      throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
    throw e5;
  }
  return n2.copyToImageData(s2, i2.formatAsRGBA), s2;
};
var decoderExports = decoder.exports;
var encode = encoderExports;
var decode = decoderExports;
var jpegJs = { encode, decode };
var JPEG = getDefaultExportFromCjs(jpegJs);
function jpeg$2() {
  return { mime: "image/jpeg", encode: (e4, { quality: t2 = 100 } = {}) => JPEG.encode(e4, t2).data, decode: (e4, t2) => JPEG.decode(e4, t2) };
}
function commonjsRequire(e4) {
  throw new Error('Could not dynamically require "' + e4 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var browser$1 = { exports: {} };
browser$1.exports = function() {
  function e4(t2, i2, r2) {
    function n2(o3, s2) {
      if (!i2[o3]) {
        if (!t2[o3]) {
          var l2 = "function" == typeof commonjsRequire && commonjsRequire;
          if (!s2 && l2)
            return l2(o3, true);
          if (a2)
            return a2(o3, true);
          var u2 = new Error("Cannot find module '" + o3 + "'");
          throw u2.code = "MODULE_NOT_FOUND", u2;
        }
        var h2 = i2[o3] = { exports: {} };
        t2[o3][0].call(h2.exports, function(e5) {
          return n2(t2[o3][1][e5] || e5);
        }, h2, h2.exports, e4, t2, i2, r2);
      }
      return i2[o3].exports;
    }
    for (var a2 = "function" == typeof commonjsRequire && commonjsRequire, o2 = 0; o2 < r2.length; o2++)
      n2(r2[o2]);
    return n2;
  }
  return e4;
}()({ 1: [function(e4, t2, i2) {
  (function(t3) {
    (function() {
      let r2 = e4("./interlace"), n2 = [function() {
      }, function(e5, t4, i3, r3) {
        if (r3 === t4.length)
          throw new Error("Ran out of data");
        let n3 = t4[r3];
        e5[i3] = n3, e5[i3 + 1] = n3, e5[i3 + 2] = n3, e5[i3 + 3] = 255;
      }, function(e5, t4, i3, r3) {
        if (r3 + 1 >= t4.length)
          throw new Error("Ran out of data");
        let n3 = t4[r3];
        e5[i3] = n3, e5[i3 + 1] = n3, e5[i3 + 2] = n3, e5[i3 + 3] = t4[r3 + 1];
      }, function(e5, t4, i3, r3) {
        if (r3 + 2 >= t4.length)
          throw new Error("Ran out of data");
        e5[i3] = t4[r3], e5[i3 + 1] = t4[r3 + 1], e5[i3 + 2] = t4[r3 + 2], e5[i3 + 3] = 255;
      }, function(e5, t4, i3, r3) {
        if (r3 + 3 >= t4.length)
          throw new Error("Ran out of data");
        e5[i3] = t4[r3], e5[i3 + 1] = t4[r3 + 1], e5[i3 + 2] = t4[r3 + 2], e5[i3 + 3] = t4[r3 + 3];
      }], a2 = [function() {
      }, function(e5, t4, i3, r3) {
        let n3 = t4[0];
        e5[i3] = n3, e5[i3 + 1] = n3, e5[i3 + 2] = n3, e5[i3 + 3] = r3;
      }, function(e5, t4, i3) {
        let r3 = t4[0];
        e5[i3] = r3, e5[i3 + 1] = r3, e5[i3 + 2] = r3, e5[i3 + 3] = t4[1];
      }, function(e5, t4, i3, r3) {
        e5[i3] = t4[0], e5[i3 + 1] = t4[1], e5[i3 + 2] = t4[2], e5[i3 + 3] = r3;
      }, function(e5, t4, i3) {
        e5[i3] = t4[0], e5[i3 + 1] = t4[1], e5[i3 + 2] = t4[2], e5[i3 + 3] = t4[3];
      }];
      function o2(e5, t4) {
        let i3 = [], r3 = 0;
        function n3() {
          if (r3 === e5.length)
            throw new Error("Ran out of data");
          let n4, a3, o3, s3, l3, u2, h2, c2, f2 = e5[r3];
          switch (r3++, t4) {
            default:
              throw new Error("unrecognised depth");
            case 16:
              h2 = e5[r3], r3++, i3.push((f2 << 8) + h2);
              break;
            case 4:
              h2 = 15 & f2, c2 = f2 >> 4, i3.push(c2, h2);
              break;
            case 2:
              l3 = 3 & f2, u2 = f2 >> 2 & 3, h2 = f2 >> 4 & 3, c2 = f2 >> 6 & 3, i3.push(c2, h2, u2, l3);
              break;
            case 1:
              n4 = 1 & f2, a3 = f2 >> 1 & 1, o3 = f2 >> 2 & 1, s3 = f2 >> 3 & 1, l3 = f2 >> 4 & 1, u2 = f2 >> 5 & 1, h2 = f2 >> 6 & 1, c2 = f2 >> 7 & 1, i3.push(c2, h2, u2, l3, s3, o3, a3, n4);
          }
        }
        return { get: function(e6) {
          for (; i3.length < e6; )
            n3();
          let t5 = i3.slice(0, e6);
          return i3 = i3.slice(e6), t5;
        }, resetAfterLine: function() {
          i3.length = 0;
        }, end: function() {
          if (r3 !== e5.length)
            throw new Error("extra data found");
        } };
      }
      function s2(e5, t4, i3, r3, a3, o3) {
        let s3 = e5.width, l3 = e5.height, u2 = e5.index;
        for (let e6 = 0; e6 < l3; e6++)
          for (let l4 = 0; l4 < s3; l4++) {
            let s4 = i3(l4, e6, u2);
            n2[r3](t4, a3, s4, o3), o3 += r3;
          }
        return o3;
      }
      function l2(e5, t4, i3, r3, n3, o3) {
        let s3 = e5.width, l3 = e5.height, u2 = e5.index;
        for (let e6 = 0; e6 < l3; e6++) {
          for (let l4 = 0; l4 < s3; l4++) {
            let s4 = n3.get(r3), h2 = i3(l4, e6, u2);
            a2[r3](t4, s4, h2, o3);
          }
          n3.resetAfterLine();
        }
      }
      i2.dataToBitMap = function(e5, i3) {
        let n3, a3, u2 = i3.width, h2 = i3.height, c2 = i3.depth, f2 = i3.bpp, d = i3.interlace;
        8 !== c2 && (n3 = o2(e5, c2)), a3 = c2 <= 8 ? t3.alloc(u2 * h2 * 4) : new Uint16Array(u2 * h2 * 4);
        let p2, m, _2 = Math.pow(2, c2) - 1, g = 0;
        if (d)
          p2 = r2.getImagePasses(u2, h2), m = r2.getInterlaceIterator(u2, h2);
        else {
          let e6 = 0;
          m = function() {
            let t4 = e6;
            return e6 += 4, t4;
          }, p2 = [{ width: u2, height: h2 }];
        }
        for (let t4 = 0; t4 < p2.length; t4++)
          8 === c2 ? g = s2(p2[t4], a3, m, f2, e5, g) : l2(p2[t4], a3, m, f2, n3, _2);
        if (8 === c2) {
          if (g !== e5.length)
            throw new Error("extra data found");
        } else
          n3.end();
        return a3;
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./interlace": 11, buffer: 32 }], 2: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("./constants");
      t2.exports = function(e5, t3, n2, a2) {
        let o2 = -1 !== [r2.COLORTYPE_COLOR_ALPHA, r2.COLORTYPE_ALPHA].indexOf(a2.colorType);
        if (a2.colorType === a2.inputColorType) {
          let t4 = function() {
            let e6 = new ArrayBuffer(2);
            return new DataView(e6).setInt16(0, 256, true), 256 !== new Int16Array(e6)[0];
          }();
          if (8 === a2.bitDepth || 16 === a2.bitDepth && t4)
            return e5;
        }
        let s2 = 16 !== a2.bitDepth ? e5 : new Uint16Array(e5.buffer), l2 = 255, u2 = r2.COLORTYPE_TO_BPP_MAP[a2.inputColorType];
        4 !== u2 || a2.inputHasAlpha || (u2 = 3);
        let h2 = r2.COLORTYPE_TO_BPP_MAP[a2.colorType];
        16 === a2.bitDepth && (l2 = 65535, h2 *= 2);
        let c2 = i3.alloc(t3 * n2 * h2), f2 = 0, d = 0, p2 = a2.bgColor || {};
        function m() {
          let e6, t4, i4, n3 = l2;
          switch (a2.inputColorType) {
            case r2.COLORTYPE_COLOR_ALPHA:
              n3 = s2[f2 + 3], e6 = s2[f2], t4 = s2[f2 + 1], i4 = s2[f2 + 2];
              break;
            case r2.COLORTYPE_COLOR:
              e6 = s2[f2], t4 = s2[f2 + 1], i4 = s2[f2 + 2];
              break;
            case r2.COLORTYPE_ALPHA:
              n3 = s2[f2 + 1], e6 = s2[f2], t4 = e6, i4 = e6;
              break;
            case r2.COLORTYPE_GRAYSCALE:
              e6 = s2[f2], t4 = e6, i4 = e6;
              break;
            default:
              throw new Error("input color type:" + a2.inputColorType + " is not supported at present");
          }
          return a2.inputHasAlpha && (o2 || (n3 /= l2, e6 = Math.min(Math.max(Math.round((1 - n3) * p2.red + n3 * e6), 0), l2), t4 = Math.min(Math.max(Math.round((1 - n3) * p2.green + n3 * t4), 0), l2), i4 = Math.min(Math.max(Math.round((1 - n3) * p2.blue + n3 * i4), 0), l2))), { red: e6, green: t4, blue: i4, alpha: n3 };
        }
        void 0 === p2.red && (p2.red = l2), void 0 === p2.green && (p2.green = l2), void 0 === p2.blue && (p2.blue = l2);
        for (let e6 = 0; e6 < n2; e6++)
          for (let e7 = 0; e7 < t3; e7++) {
            let e8 = m();
            switch (a2.colorType) {
              case r2.COLORTYPE_COLOR_ALPHA:
              case r2.COLORTYPE_COLOR:
                8 === a2.bitDepth ? (c2[d] = e8.red, c2[d + 1] = e8.green, c2[d + 2] = e8.blue, o2 && (c2[d + 3] = e8.alpha)) : (c2.writeUInt16BE(e8.red, d), c2.writeUInt16BE(e8.green, d + 2), c2.writeUInt16BE(e8.blue, d + 4), o2 && c2.writeUInt16BE(e8.alpha, d + 6));
                break;
              case r2.COLORTYPE_ALPHA:
              case r2.COLORTYPE_GRAYSCALE: {
                let t4 = (e8.red + e8.green + e8.blue) / 3;
                8 === a2.bitDepth ? (c2[d] = t4, o2 && (c2[d + 1] = e8.alpha)) : (c2.writeUInt16BE(t4, d), o2 && c2.writeUInt16BE(e8.alpha, d + 2));
                break;
              }
              default:
                throw new Error("unrecognised color Type " + a2.colorType);
            }
            f2 += u2, d += h2;
          }
        return c2;
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./constants": 4, buffer: 32 }], 3: [function(e4, t2, i2) {
  (function(i3, r2) {
    (function() {
      let n2 = e4("util"), a2 = e4("stream"), o2 = t2.exports = function() {
        a2.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = false, this._encoding = "utf8", this.writable = true;
      };
      n2.inherits(o2, a2), o2.prototype.read = function(e5, t3) {
        this._reads.push({ length: Math.abs(e5), allowLess: e5 < 0, func: t3 }), i3.nextTick(function() {
          this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = false, this.emit("drain"));
        }.bind(this));
      }, o2.prototype.write = function(e5, t3) {
        if (!this.writable)
          return this.emit("error", new Error("Stream not writable")), false;
        let i4;
        return i4 = r2.isBuffer(e5) ? e5 : r2.from(e5, t3 || this._encoding), this._buffers.push(i4), this._buffered += i4.length, this._process(), this._reads && 0 === this._reads.length && (this._paused = true), this.writable && !this._paused;
      }, o2.prototype.end = function(e5, t3) {
        e5 && this.write(e5, t3), this.writable = false, this._buffers && (0 === this._buffers.length ? this._end() : (this._buffers.push(null), this._process()));
      }, o2.prototype.destroySoon = o2.prototype.end, o2.prototype._end = function() {
        this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
      }, o2.prototype.destroy = function() {
        this._buffers && (this.writable = false, this._reads = null, this._buffers = null, this.emit("close"));
      }, o2.prototype._processReadAllowingLess = function(e5) {
        this._reads.shift();
        let t3 = this._buffers[0];
        t3.length > e5.length ? (this._buffered -= e5.length, this._buffers[0] = t3.slice(e5.length), e5.func.call(this, t3.slice(0, e5.length))) : (this._buffered -= t3.length, this._buffers.shift(), e5.func.call(this, t3));
      }, o2.prototype._processRead = function(e5) {
        this._reads.shift();
        let t3 = 0, i4 = 0, n3 = r2.alloc(e5.length);
        for (; t3 < e5.length; ) {
          let r3 = this._buffers[i4++], a3 = Math.min(r3.length, e5.length - t3);
          r3.copy(n3, t3, 0, a3), t3 += a3, a3 !== r3.length && (this._buffers[--i4] = r3.slice(a3));
        }
        i4 > 0 && this._buffers.splice(0, i4), this._buffered -= e5.length, e5.func.call(this, n3);
      }, o2.prototype._process = function() {
        try {
          for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
            let e5 = this._reads[0];
            if (e5.allowLess)
              this._processReadAllowingLess(e5);
            else {
              if (!(this._buffered >= e5.length))
                break;
              this._processRead(e5);
            }
          }
          this._buffers && !this.writable && this._end();
        } catch (e5) {
          this.emit("error", e5);
        }
      };
    }).call(this);
  }).call(this, e4("_process"), e4("buffer").Buffer);
}, { _process: 63, buffer: 32, stream: 65, util: 84 }], 4: [function(e4, t2, i2) {
  t2.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
}, {}], 5: [function(e4, t2, i2) {
  let r2 = [];
  !function() {
    for (let e5 = 0; e5 < 256; e5++) {
      let t3 = e5;
      for (let e6 = 0; e6 < 8; e6++)
        1 & t3 ? t3 = 3988292384 ^ t3 >>> 1 : t3 >>>= 1;
      r2[e5] = t3;
    }
  }();
  let n2 = t2.exports = function() {
    this._crc = -1;
  };
  n2.prototype.write = function(e5) {
    for (let t3 = 0; t3 < e5.length; t3++)
      this._crc = r2[255 & (this._crc ^ e5[t3])] ^ this._crc >>> 8;
    return true;
  }, n2.prototype.crc32 = function() {
    return ~this._crc;
  }, n2.crc32 = function(e5) {
    let t3 = -1;
    for (let i3 = 0; i3 < e5.length; i3++)
      t3 = r2[255 & (t3 ^ e5[i3])] ^ t3 >>> 8;
    return ~t3;
  };
}, {}], 6: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("./paeth-predictor");
      function n2(e5, t3, i4, r3, n3) {
        for (let a3 = 0; a3 < i4; a3++)
          r3[n3 + a3] = e5[t3 + a3];
      }
      function a2(e5, t3, i4) {
        let r3 = 0, n3 = t3 + i4;
        for (let i5 = t3; i5 < n3; i5++)
          r3 += Math.abs(e5[i5]);
        return r3;
      }
      function o2(e5, t3, i4, r3, n3, a3) {
        for (let o3 = 0; o3 < i4; o3++) {
          let i5 = o3 >= a3 ? e5[t3 + o3 - a3] : 0, s3 = e5[t3 + o3] - i5;
          r3[n3 + o3] = s3;
        }
      }
      function s2(e5, t3, i4, r3) {
        let n3 = 0;
        for (let a3 = 0; a3 < i4; a3++) {
          let i5 = a3 >= r3 ? e5[t3 + a3 - r3] : 0, o3 = e5[t3 + a3] - i5;
          n3 += Math.abs(o3);
        }
        return n3;
      }
      function l2(e5, t3, i4, r3, n3) {
        for (let a3 = 0; a3 < i4; a3++) {
          let o3 = t3 > 0 ? e5[t3 + a3 - i4] : 0, s3 = e5[t3 + a3] - o3;
          r3[n3 + a3] = s3;
        }
      }
      function u2(e5, t3, i4) {
        let r3 = 0, n3 = t3 + i4;
        for (let a3 = t3; a3 < n3; a3++) {
          let n4 = t3 > 0 ? e5[a3 - i4] : 0, o3 = e5[a3] - n4;
          r3 += Math.abs(o3);
        }
        return r3;
      }
      function h2(e5, t3, i4, r3, n3, a3) {
        for (let o3 = 0; o3 < i4; o3++) {
          let s3 = o3 >= a3 ? e5[t3 + o3 - a3] : 0, l3 = t3 > 0 ? e5[t3 + o3 - i4] : 0, u3 = e5[t3 + o3] - (s3 + l3 >> 1);
          r3[n3 + o3] = u3;
        }
      }
      function c2(e5, t3, i4, r3) {
        let n3 = 0;
        for (let a3 = 0; a3 < i4; a3++) {
          let o3 = a3 >= r3 ? e5[t3 + a3 - r3] : 0, s3 = t3 > 0 ? e5[t3 + a3 - i4] : 0, l3 = e5[t3 + a3] - (o3 + s3 >> 1);
          n3 += Math.abs(l3);
        }
        return n3;
      }
      function f2(e5, t3, i4, n3, a3, o3) {
        for (let s3 = 0; s3 < i4; s3++) {
          let l3 = s3 >= o3 ? e5[t3 + s3 - o3] : 0, u3 = t3 > 0 ? e5[t3 + s3 - i4] : 0, h3 = t3 > 0 && s3 >= o3 ? e5[t3 + s3 - (i4 + o3)] : 0, c3 = e5[t3 + s3] - r2(l3, u3, h3);
          n3[a3 + s3] = c3;
        }
      }
      function d(e5, t3, i4, n3) {
        let a3 = 0;
        for (let o3 = 0; o3 < i4; o3++) {
          let s3 = o3 >= n3 ? e5[t3 + o3 - n3] : 0, l3 = t3 > 0 ? e5[t3 + o3 - i4] : 0, u3 = t3 > 0 && o3 >= n3 ? e5[t3 + o3 - (i4 + n3)] : 0, h3 = e5[t3 + o3] - r2(s3, l3, u3);
          a3 += Math.abs(h3);
        }
        return a3;
      }
      let p2 = { 0: n2, 1: o2, 2: l2, 3: h2, 4: f2 }, m = { 0: a2, 1: s2, 2: u2, 3: c2, 4: d };
      t2.exports = function(e5, t3, r3, n3, a3) {
        let o3;
        if ("filterType" in n3 && -1 !== n3.filterType) {
          if ("number" != typeof n3.filterType)
            throw new Error("unrecognised filter types");
          o3 = [n3.filterType];
        } else
          o3 = [0, 1, 2, 3, 4];
        16 === n3.bitDepth && (a3 *= 2);
        let s3 = t3 * a3, l3 = 0, u3 = 0, h3 = i3.alloc((s3 + 1) * r3), c3 = o3[0];
        for (let t4 = 0; t4 < r3; t4++) {
          if (o3.length > 1) {
            let t5 = 1 / 0;
            for (let i4 = 0; i4 < o3.length; i4++) {
              let r4 = m[o3[i4]](e5, u3, s3, a3);
              r4 < t5 && (c3 = o3[i4], t5 = r4);
            }
          }
          h3[l3] = c3, l3++, p2[c3](e5, u3, s3, h3, l3, a3), l3 += s3, u3 += s3;
        }
        return h3;
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./paeth-predictor": 15, buffer: 32 }], 7: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("util"), n2 = e4("./chunkstream"), a2 = e4("./filter-parse"), o2 = t2.exports = function(e5) {
        n2.call(this);
        let t3 = [], r3 = this;
        this._filter = new a2(e5, { read: this.read.bind(this), write: function(e6) {
          t3.push(e6);
        }, complete: function() {
          r3.emit("complete", i3.concat(t3));
        } }), this._filter.start();
      };
      r2.inherits(o2, n2);
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./chunkstream": 3, "./filter-parse": 9, buffer: 32, util: 84 }], 8: [function(e4, t2, i2) {
  (function(t3) {
    (function() {
      let r2 = e4("./sync-reader"), n2 = e4("./filter-parse");
      i2.process = function(e5, i3) {
        let a2 = [], o2 = new r2(e5);
        return new n2(i3, { read: o2.read.bind(o2), write: function(e6) {
          a2.push(e6);
        }, complete: function() {
        } }).start(), o2.process(), t3.concat(a2);
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./filter-parse": 9, "./sync-reader": 22, buffer: 32 }], 9: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("./interlace"), n2 = e4("./paeth-predictor");
      function a2(e5, t3, i4) {
        let r3 = e5 * t3;
        return 8 !== i4 && (r3 = Math.ceil(r3 / (8 / i4))), r3;
      }
      let o2 = t2.exports = function(e5, t3) {
        let i4 = e5.width, n3 = e5.height, o3 = e5.interlace, s2 = e5.bpp, l2 = e5.depth;
        if (this.read = t3.read, this.write = t3.write, this.complete = t3.complete, this._imageIndex = 0, this._images = [], o3) {
          let e6 = r2.getImagePasses(i4, n3);
          for (let t4 = 0; t4 < e6.length; t4++)
            this._images.push({ byteWidth: a2(e6[t4].width, s2, l2), height: e6[t4].height, lineIndex: 0 });
        } else
          this._images.push({ byteWidth: a2(i4, s2, l2), height: n3, lineIndex: 0 });
        this._xComparison = 8 === l2 ? s2 : 16 === l2 ? 2 * s2 : 1;
      };
      o2.prototype.start = function() {
        this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
      }, o2.prototype._unFilterType1 = function(e5, t3, i4) {
        let r3 = this._xComparison, n3 = r3 - 1;
        for (let a3 = 0; a3 < i4; a3++) {
          let i5 = e5[1 + a3], o3 = a3 > n3 ? t3[a3 - r3] : 0;
          t3[a3] = i5 + o3;
        }
      }, o2.prototype._unFilterType2 = function(e5, t3, i4) {
        let r3 = this._lastLine;
        for (let n3 = 0; n3 < i4; n3++) {
          let i5 = e5[1 + n3], a3 = r3 ? r3[n3] : 0;
          t3[n3] = i5 + a3;
        }
      }, o2.prototype._unFilterType3 = function(e5, t3, i4) {
        let r3 = this._xComparison, n3 = r3 - 1, a3 = this._lastLine;
        for (let o3 = 0; o3 < i4; o3++) {
          let i5 = e5[1 + o3], s2 = a3 ? a3[o3] : 0, l2 = o3 > n3 ? t3[o3 - r3] : 0, u2 = Math.floor((l2 + s2) / 2);
          t3[o3] = i5 + u2;
        }
      }, o2.prototype._unFilterType4 = function(e5, t3, i4) {
        let r3 = this._xComparison, a3 = r3 - 1, o3 = this._lastLine;
        for (let s2 = 0; s2 < i4; s2++) {
          let i5 = e5[1 + s2], l2 = o3 ? o3[s2] : 0, u2 = s2 > a3 ? t3[s2 - r3] : 0, h2 = s2 > a3 && o3 ? o3[s2 - r3] : 0, c2 = n2(u2, l2, h2);
          t3[s2] = i5 + c2;
        }
      }, o2.prototype._reverseFilterLine = function(e5) {
        let t3, r3 = e5[0], n3 = this._images[this._imageIndex], a3 = n3.byteWidth;
        if (0 === r3)
          t3 = e5.slice(1, a3 + 1);
        else
          switch (t3 = i3.alloc(a3), r3) {
            case 1:
              this._unFilterType1(e5, t3, a3);
              break;
            case 2:
              this._unFilterType2(e5, t3, a3);
              break;
            case 3:
              this._unFilterType3(e5, t3, a3);
              break;
            case 4:
              this._unFilterType4(e5, t3, a3);
              break;
            default:
              throw new Error("Unrecognised filter type - " + r3);
          }
        this.write(t3), n3.lineIndex++, n3.lineIndex >= n3.height ? (this._lastLine = null, this._imageIndex++, n3 = this._images[this._imageIndex]) : this._lastLine = t3, n3 ? this.read(n3.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./interlace": 11, "./paeth-predictor": 15, buffer: 32 }], 10: [function(e4, t2, i2) {
  (function(e5) {
    (function() {
      function i3(e6, t3, i4, r3, n3) {
        let a2 = 0;
        for (let o2 = 0; o2 < r3; o2++)
          for (let r4 = 0; r4 < i4; r4++) {
            let i5 = n3[e6[a2]];
            if (!i5)
              throw new Error("index " + e6[a2] + " not in palette");
            for (let e7 = 0; e7 < 4; e7++)
              t3[a2 + e7] = i5[e7];
            a2 += 4;
          }
      }
      function r2(e6, t3, i4, r3, n3) {
        let a2 = 0;
        for (let o2 = 0; o2 < r3; o2++)
          for (let r4 = 0; r4 < i4; r4++) {
            let i5 = false;
            if (1 === n3.length ? n3[0] === e6[a2] && (i5 = true) : n3[0] === e6[a2] && n3[1] === e6[a2 + 1] && n3[2] === e6[a2 + 2] && (i5 = true), i5)
              for (let e7 = 0; e7 < 4; e7++)
                t3[a2 + e7] = 0;
            a2 += 4;
          }
      }
      function n2(e6, t3, i4, r3, n3) {
        let a2 = 255, o2 = Math.pow(2, n3) - 1, s2 = 0;
        for (let n4 = 0; n4 < r3; n4++)
          for (let r4 = 0; r4 < i4; r4++) {
            for (let i5 = 0; i5 < 4; i5++)
              t3[s2 + i5] = Math.floor(e6[s2 + i5] * a2 / o2 + 0.5);
            s2 += 4;
          }
      }
      t2.exports = function(t3, a2, o2 = false) {
        let s2 = a2.depth, l2 = a2.width, u2 = a2.height, h2 = a2.colorType, c2 = a2.transColor, f2 = a2.palette, d = t3;
        return 3 === h2 ? i3(t3, d, l2, u2, f2) : (c2 && r2(t3, d, l2, u2, c2), 8 === s2 || o2 || (16 === s2 && (d = e5.alloc(l2 * u2 * 4)), n2(t3, d, l2, u2, s2))), d;
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { buffer: 32 }], 11: [function(e4, t2, i2) {
  let r2 = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
  i2.getImagePasses = function(e5, t3) {
    let i3 = [], n2 = e5 % 8, a2 = t3 % 8, o2 = (e5 - n2) / 8, s2 = (t3 - a2) / 8;
    for (let e6 = 0; e6 < r2.length; e6++) {
      let t4 = r2[e6], l2 = o2 * t4.x.length, u2 = s2 * t4.y.length;
      for (let e7 = 0; e7 < t4.x.length && t4.x[e7] < n2; e7++)
        l2++;
      for (let e7 = 0; e7 < t4.y.length && t4.y[e7] < a2; e7++)
        u2++;
      l2 > 0 && u2 > 0 && i3.push({ width: l2, height: u2, index: e6 });
    }
    return i3;
  }, i2.getInterlaceIterator = function(e5) {
    return function(t3, i3, n2) {
      let a2 = t3 % r2[n2].x.length, o2 = (t3 - a2) / r2[n2].x.length * 8 + r2[n2].x[a2], s2 = i3 % r2[n2].y.length;
      return 4 * o2 + ((i3 - s2) / r2[n2].y.length * 8 + r2[n2].y[s2]) * e5 * 4;
    };
  };
}, {}], 12: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("util"), n2 = e4("stream"), a2 = e4("./constants"), o2 = e4("./packer"), s2 = t2.exports = function(e5) {
        n2.call(this);
        let t3 = e5 || {};
        this._packer = new o2(t3), this._deflate = this._packer.createDeflate(), this.readable = true;
      };
      r2.inherits(s2, n2), s2.prototype.pack = function(e5, t3, r3, n3) {
        this.emit("data", i3.from(a2.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(t3, r3)), n3 && this.emit("data", this._packer.packGAMA(n3));
        let o3 = this._packer.filterData(e5, t3, r3);
        this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(e6) {
          this.emit("data", this._packer.packIDAT(e6));
        }.bind(this)), this._deflate.on("end", function() {
          this.emit("data", this._packer.packIEND()), this.emit("end");
        }.bind(this)), this._deflate.end(o3);
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./constants": 4, "./packer": 14, buffer: 32, stream: 65, util: 84 }], 13: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = true, n2 = e4("zlib");
      n2.deflateSync || (r2 = false);
      let a2 = e4("./constants"), o2 = e4("./packer");
      t2.exports = function(e5, t3) {
        if (!r2)
          throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        let s2 = new o2(t3 || {}), l2 = [];
        l2.push(i3.from(a2.PNG_SIGNATURE)), l2.push(s2.packIHDR(e5.width, e5.height)), e5.gamma && l2.push(s2.packGAMA(e5.gamma));
        let u2 = s2.filterData(e5.data, e5.width, e5.height), h2 = n2.deflateSync(u2, s2.getDeflateOptions());
        if (u2 = null, !h2 || !h2.length)
          throw new Error("bad png - invalid compressed data response");
        return l2.push(s2.packIDAT(h2)), l2.push(s2.packIEND()), i3.concat(l2);
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./constants": 4, "./packer": 14, buffer: 32, zlib: 31 }], 14: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("./constants"), n2 = e4("./crc"), a2 = e4("./bitpacker"), o2 = e4("./filter-pack"), s2 = e4("zlib"), l2 = t2.exports = function(e5) {
        if (this._options = e5, e5.deflateChunkSize = e5.deflateChunkSize || 32768, e5.deflateLevel = null != e5.deflateLevel ? e5.deflateLevel : 9, e5.deflateStrategy = null != e5.deflateStrategy ? e5.deflateStrategy : 3, e5.inputHasAlpha = null == e5.inputHasAlpha || e5.inputHasAlpha, e5.deflateFactory = e5.deflateFactory || s2.createDeflate, e5.bitDepth = e5.bitDepth || 8, e5.colorType = "number" == typeof e5.colorType ? e5.colorType : r2.COLORTYPE_COLOR_ALPHA, e5.inputColorType = "number" == typeof e5.inputColorType ? e5.inputColorType : r2.COLORTYPE_COLOR_ALPHA, -1 === [r2.COLORTYPE_GRAYSCALE, r2.COLORTYPE_COLOR, r2.COLORTYPE_COLOR_ALPHA, r2.COLORTYPE_ALPHA].indexOf(e5.colorType))
          throw new Error("option color type:" + e5.colorType + " is not supported at present");
        if (-1 === [r2.COLORTYPE_GRAYSCALE, r2.COLORTYPE_COLOR, r2.COLORTYPE_COLOR_ALPHA, r2.COLORTYPE_ALPHA].indexOf(e5.inputColorType))
          throw new Error("option input color type:" + e5.inputColorType + " is not supported at present");
        if (8 !== e5.bitDepth && 16 !== e5.bitDepth)
          throw new Error("option bit depth:" + e5.bitDepth + " is not supported at present");
      };
      l2.prototype.getDeflateOptions = function() {
        return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
      }, l2.prototype.createDeflate = function() {
        return this._options.deflateFactory(this.getDeflateOptions());
      }, l2.prototype.filterData = function(e5, t3, i4) {
        let n3 = a2(e5, t3, i4, this._options), s3 = r2.COLORTYPE_TO_BPP_MAP[this._options.colorType];
        return o2(n3, t3, i4, this._options, s3);
      }, l2.prototype._packChunk = function(e5, t3) {
        let r3 = t3 ? t3.length : 0, a3 = i3.alloc(r3 + 12);
        return a3.writeUInt32BE(r3, 0), a3.writeUInt32BE(e5, 4), t3 && t3.copy(a3, 8), a3.writeInt32BE(n2.crc32(a3.slice(4, a3.length - 4)), a3.length - 4), a3;
      }, l2.prototype.packGAMA = function(e5) {
        let t3 = i3.alloc(4);
        return t3.writeUInt32BE(Math.floor(e5 * r2.GAMMA_DIVISION), 0), this._packChunk(r2.TYPE_gAMA, t3);
      }, l2.prototype.packIHDR = function(e5, t3) {
        let n3 = i3.alloc(13);
        return n3.writeUInt32BE(e5, 0), n3.writeUInt32BE(t3, 4), n3[8] = this._options.bitDepth, n3[9] = this._options.colorType, n3[10] = 0, n3[11] = 0, n3[12] = 0, this._packChunk(r2.TYPE_IHDR, n3);
      }, l2.prototype.packIDAT = function(e5) {
        return this._packChunk(r2.TYPE_IDAT, e5);
      }, l2.prototype.packIEND = function() {
        return this._packChunk(r2.TYPE_IEND, null);
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 32, zlib: 31 }], 15: [function(e4, t2, i2) {
  t2.exports = function(e5, t3, i3) {
    let r2 = e5 + t3 - i3, n2 = Math.abs(r2 - e5), a2 = Math.abs(r2 - t3), o2 = Math.abs(r2 - i3);
    return n2 <= a2 && n2 <= o2 ? e5 : a2 <= o2 ? t3 : i3;
  };
}, {}], 16: [function(e4, t2, i2) {
  let r2 = e4("util"), n2 = e4("zlib"), a2 = e4("./chunkstream"), o2 = e4("./filter-parse-async"), s2 = e4("./parser"), l2 = e4("./bitmapper"), u2 = e4("./format-normaliser"), h2 = t2.exports = function(e5) {
    a2.call(this), this._parser = new s2(e5, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = e5, this.writable = true, this._parser.start();
  };
  r2.inherits(h2, a2), h2.prototype._handleError = function(e5) {
    this.emit("error", e5), this.writable = false, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
    })), this.errord = true;
  }, h2.prototype._inflateData = function(e5) {
    if (!this._inflate)
      if (this._bitmapInfo.interlace)
        this._inflate = n2.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
      else {
        let e6 = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, t3 = Math.max(e6, n2.Z_MIN_CHUNK);
        this._inflate = n2.createInflate({ chunkSize: t3 });
        let i3 = e6, r3 = this.emit.bind(this, "error");
        this._inflate.on("error", function(e7) {
          i3 && r3(e7);
        }), this._filter.on("complete", this._complete.bind(this));
        let a3 = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(e7) {
          i3 && (e7.length > i3 && (e7 = e7.slice(0, i3)), i3 -= e7.length, a3(e7));
        }), this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    this._inflate.write(e5);
  }, h2.prototype._handleMetaData = function(e5) {
    this._metaData = e5, this._bitmapInfo = Object.create(e5), this._filter = new o2(this._bitmapInfo);
  }, h2.prototype._handleTransColor = function(e5) {
    this._bitmapInfo.transColor = e5;
  }, h2.prototype._handlePalette = function(e5) {
    this._bitmapInfo.palette = e5;
  }, h2.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  }, h2.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  }, h2.prototype._finished = function() {
    this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
  }, h2.prototype._complete = function(e5) {
    if (this.errord)
      return;
    let t3;
    try {
      let i3 = l2.dataToBitMap(e5, this._bitmapInfo);
      t3 = u2(i3, this._bitmapInfo, this._options.skipRescale), i3 = null;
    } catch (e6) {
      return void this._handleError(e6);
    }
    this.emit("parsed", t3);
  };
}, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 84, zlib: 31 }], 17: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = true, n2 = e4("zlib"), a2 = e4("./sync-inflate");
      n2.deflateSync || (r2 = false);
      let o2 = e4("./sync-reader"), s2 = e4("./filter-parse-sync"), l2 = e4("./parser"), u2 = e4("./bitmapper"), h2 = e4("./format-normaliser");
      t2.exports = function(e5, t3) {
        if (!r2)
          throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
        let c2, f2, d;
        function p2(e6) {
          c2 = e6;
        }
        function m(e6) {
          f2 = e6;
        }
        function _2(e6) {
          f2.transColor = e6;
        }
        function g(e6) {
          f2.palette = e6;
        }
        function b2() {
          f2.alpha = true;
        }
        function y2(e6) {
          d = e6;
        }
        let w = [];
        function v2(e6) {
          w.push(e6);
        }
        let x2 = new o2(e5);
        if (new l2(t3, { read: x2.read.bind(x2), error: p2, metadata: m, gamma: y2, palette: g, transColor: _2, inflateData: v2, simpleTransparency: b2 }).start(), x2.process(), c2)
          throw c2;
        let E2, k2 = i3.concat(w);
        if (w.length = 0, f2.interlace)
          E2 = n2.inflateSync(k2);
        else {
          let e6 = (1 + (f2.width * f2.bpp * f2.depth + 7 >> 3)) * f2.height;
          E2 = a2(k2, { chunkSize: e6, maxLength: e6 });
        }
        if (k2 = null, !E2 || !E2.length)
          throw new Error("bad png - invalid inflate data response");
        let S2 = s2.process(E2, f2);
        k2 = null;
        let A2 = u2.dataToBitMap(S2, f2);
        S2 = null;
        let I = h2(A2, f2, t3.skipRescale);
        return f2.data = I, f2.gamma = d || 0, f2;
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 32, zlib: 31 }], 18: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      let r2 = e4("./constants"), n2 = e4("./crc"), a2 = t2.exports = function(e5, t3) {
        this._options = e5, e5.checkCRC = false !== e5.checkCRC, this._hasIHDR = false, this._hasIEND = false, this._emittedHeadersFinished = false, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[r2.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[r2.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[r2.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[r2.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[r2.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[r2.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = t3.read, this.error = t3.error, this.metadata = t3.metadata, this.gamma = t3.gamma, this.transColor = t3.transColor, this.palette = t3.palette, this.parsed = t3.parsed, this.inflateData = t3.inflateData, this.finished = t3.finished, this.simpleTransparency = t3.simpleTransparency, this.headersFinished = t3.headersFinished || function() {
        };
      };
      a2.prototype.start = function() {
        this.read(r2.PNG_SIGNATURE.length, this._parseSignature.bind(this));
      }, a2.prototype._parseSignature = function(e5) {
        let t3 = r2.PNG_SIGNATURE;
        for (let i4 = 0; i4 < t3.length; i4++)
          if (e5[i4] !== t3[i4])
            return void this.error(new Error("Invalid file signature"));
        this.read(8, this._parseChunkBegin.bind(this));
      }, a2.prototype._parseChunkBegin = function(e5) {
        let t3 = e5.readUInt32BE(0), a3 = e5.readUInt32BE(4), o2 = "";
        for (let t4 = 4; t4 < 8; t4++)
          o2 += String.fromCharCode(e5[t4]);
        let s2 = Boolean(32 & e5[4]);
        if (this._hasIHDR || a3 === r2.TYPE_IHDR) {
          if (this._crc = new n2(), this._crc.write(i3.from(o2)), this._chunks[a3])
            return this._chunks[a3](t3);
          s2 ? this.read(t3 + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + o2));
        } else
          this.error(new Error("Expected IHDR on beggining"));
      }, a2.prototype._skipChunk = function() {
        this.read(8, this._parseChunkBegin.bind(this));
      }, a2.prototype._handleChunkEnd = function() {
        this.read(4, this._parseChunkEnd.bind(this));
      }, a2.prototype._parseChunkEnd = function(e5) {
        let t3 = e5.readInt32BE(0), i4 = this._crc.crc32();
        this._options.checkCRC && i4 !== t3 ? this.error(new Error("Crc error - " + t3 + " - " + i4)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
      }, a2.prototype._handleIHDR = function(e5) {
        this.read(e5, this._parseIHDR.bind(this));
      }, a2.prototype._parseIHDR = function(e5) {
        this._crc.write(e5);
        let t3 = e5.readUInt32BE(0), i4 = e5.readUInt32BE(4), n3 = e5[8], a3 = e5[9], o2 = e5[10], s2 = e5[11], l2 = e5[12];
        if (8 !== n3 && 4 !== n3 && 2 !== n3 && 1 !== n3 && 16 !== n3)
          return void this.error(new Error("Unsupported bit depth " + n3));
        if (!(a3 in r2.COLORTYPE_TO_BPP_MAP))
          return void this.error(new Error("Unsupported color type"));
        if (0 !== o2)
          return void this.error(new Error("Unsupported compression method"));
        if (0 !== s2)
          return void this.error(new Error("Unsupported filter method"));
        if (0 !== l2 && 1 !== l2)
          return void this.error(new Error("Unsupported interlace method"));
        this._colorType = a3;
        let u2 = r2.COLORTYPE_TO_BPP_MAP[this._colorType];
        this._hasIHDR = true, this.metadata({ width: t3, height: i4, depth: n3, interlace: Boolean(l2), palette: Boolean(a3 & r2.COLORTYPE_PALETTE), color: Boolean(a3 & r2.COLORTYPE_COLOR), alpha: Boolean(a3 & r2.COLORTYPE_ALPHA), bpp: u2, colorType: a3 }), this._handleChunkEnd();
      }, a2.prototype._handlePLTE = function(e5) {
        this.read(e5, this._parsePLTE.bind(this));
      }, a2.prototype._parsePLTE = function(e5) {
        this._crc.write(e5);
        let t3 = Math.floor(e5.length / 3);
        for (let i4 = 0; i4 < t3; i4++)
          this._palette.push([e5[3 * i4], e5[3 * i4 + 1], e5[3 * i4 + 2], 255]);
        this.palette(this._palette), this._handleChunkEnd();
      }, a2.prototype._handleTRNS = function(e5) {
        this.simpleTransparency(), this.read(e5, this._parseTRNS.bind(this));
      }, a2.prototype._parseTRNS = function(e5) {
        if (this._crc.write(e5), this._colorType === r2.COLORTYPE_PALETTE_COLOR) {
          if (0 === this._palette.length)
            return void this.error(new Error("Transparency chunk must be after palette"));
          if (e5.length > this._palette.length)
            return void this.error(new Error("More transparent colors than palette size"));
          for (let t3 = 0; t3 < e5.length; t3++)
            this._palette[t3][3] = e5[t3];
          this.palette(this._palette);
        }
        this._colorType === r2.COLORTYPE_GRAYSCALE && this.transColor([e5.readUInt16BE(0)]), this._colorType === r2.COLORTYPE_COLOR && this.transColor([e5.readUInt16BE(0), e5.readUInt16BE(2), e5.readUInt16BE(4)]), this._handleChunkEnd();
      }, a2.prototype._handleGAMA = function(e5) {
        this.read(e5, this._parseGAMA.bind(this));
      }, a2.prototype._parseGAMA = function(e5) {
        this._crc.write(e5), this.gamma(e5.readUInt32BE(0) / r2.GAMMA_DIVISION), this._handleChunkEnd();
      }, a2.prototype._handleIDAT = function(e5) {
        this._emittedHeadersFinished || (this._emittedHeadersFinished = true, this.headersFinished()), this.read(-e5, this._parseIDAT.bind(this, e5));
      }, a2.prototype._parseIDAT = function(e5, t3) {
        if (this._crc.write(t3), this._colorType === r2.COLORTYPE_PALETTE_COLOR && 0 === this._palette.length)
          throw new Error("Expected palette not found");
        this.inflateData(t3);
        let i4 = e5 - t3.length;
        i4 > 0 ? this._handleIDAT(i4) : this._handleChunkEnd();
      }, a2.prototype._handleIEND = function(e5) {
        this.read(e5, this._parseIEND.bind(this));
      }, a2.prototype._parseIEND = function(e5) {
        this._crc.write(e5), this._hasIEND = true, this._handleChunkEnd(), this.finished && this.finished();
      };
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "./constants": 4, "./crc": 5, buffer: 32 }], 19: [function(e4, t2, i2) {
  let r2 = e4("./parser-sync"), n2 = e4("./packer-sync");
  i2.read = function(e5, t3) {
    return r2(e5, t3 || {});
  }, i2.write = function(e5, t3) {
    return n2(e5, t3);
  };
}, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(e4, t2, i2) {
  (function(t3, r2) {
    (function() {
      let n2 = e4("util"), a2 = e4("stream"), o2 = e4("./parser-async"), s2 = e4("./packer-async"), l2 = e4("./png-sync"), u2 = i2.PNG = function(e5) {
        a2.call(this), e5 = e5 || {}, this.width = 0 | e5.width, this.height = 0 | e5.height, this.data = this.width > 0 && this.height > 0 ? r2.alloc(4 * this.width * this.height) : null, e5.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = true, this._parser = new o2(e5), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(e6) {
          this.data = e6, this.emit("parsed", e6);
        }.bind(this)), this._packer = new s2(e5), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
      };
      n2.inherits(u2, a2), u2.sync = l2, u2.prototype.pack = function() {
        return this.data && this.data.length ? (t3.nextTick(function() {
          this._packer.pack(this.data, this.width, this.height, this.gamma);
        }.bind(this)), this) : (this.emit("error", "No data provided"), this);
      }, u2.prototype.parse = function(e5, t4) {
        if (t4) {
          let e6, i3;
          e6 = function(e7) {
            this.removeListener("error", i3), this.data = e7, t4(null, this);
          }.bind(this), i3 = function(i4) {
            this.removeListener("parsed", e6), t4(i4, null);
          }.bind(this), this.once("parsed", e6), this.once("error", i3);
        }
        return this.end(e5), this;
      }, u2.prototype.write = function(e5) {
        return this._parser.write(e5), true;
      }, u2.prototype.end = function(e5) {
        this._parser.end(e5);
      }, u2.prototype._metadata = function(e5) {
        this.width = e5.width, this.height = e5.height, this.emit("metadata", e5);
      }, u2.prototype._gamma = function(e5) {
        this.gamma = e5;
      }, u2.prototype._handleClose = function() {
        this._parser.writable || this._packer.readable || this.emit("close");
      }, u2.bitblt = function(e5, t4, i3, r3, n3, a3, o3, s3) {
        if (r3 |= 0, n3 |= 0, a3 |= 0, o3 |= 0, s3 |= 0, (i3 |= 0) > e5.width || r3 > e5.height || i3 + n3 > e5.width || r3 + a3 > e5.height)
          throw new Error("bitblt reading outside image");
        if (o3 > t4.width || s3 > t4.height || o3 + n3 > t4.width || s3 + a3 > t4.height)
          throw new Error("bitblt writing outside image");
        for (let l3 = 0; l3 < a3; l3++)
          e5.data.copy(t4.data, (s3 + l3) * t4.width + o3 << 2, (r3 + l3) * e5.width + i3 << 2, (r3 + l3) * e5.width + i3 + n3 << 2);
      }, u2.prototype.bitblt = function(e5, t4, i3, r3, n3, a3, o3) {
        return u2.bitblt(this, e5, t4, i3, r3, n3, a3, o3), this;
      }, u2.adjustGamma = function(e5) {
        if (e5.gamma) {
          for (let t4 = 0; t4 < e5.height; t4++)
            for (let i3 = 0; i3 < e5.width; i3++) {
              let r3 = e5.width * t4 + i3 << 2;
              for (let t5 = 0; t5 < 3; t5++) {
                let i4 = e5.data[r3 + t5] / 255;
                i4 = Math.pow(i4, 1 / 2.2 / e5.gamma), e5.data[r3 + t5] = Math.round(255 * i4);
              }
            }
          e5.gamma = 0;
        }
      }, u2.prototype.adjustGamma = function() {
        u2.adjustGamma(this);
      };
    }).call(this);
  }).call(this, e4("_process"), e4("buffer").Buffer);
}, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 63, buffer: 32, stream: 65, util: 84 }], 21: [function(e4, t2, i2) {
  (function(r2, n2) {
    (function() {
      let r3 = e4("assert").ok, a2 = e4("zlib"), o2 = e4("util"), s2 = e4("buffer").kMaxLength;
      function l2(e5) {
        if (!(this instanceof l2))
          return new l2(e5);
        e5 && e5.chunkSize < a2.Z_MIN_CHUNK && (e5.chunkSize = a2.Z_MIN_CHUNK), a2.Inflate.call(this, e5), this._offset = void 0 === this._offset ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, e5 && null != e5.maxLength && (this._maxLength = e5.maxLength);
      }
      function u2(e5) {
        return new l2(e5);
      }
      function h2(e5, t3) {
        e5._handle && (e5._handle.close(), e5._handle = null);
      }
      function c2(e5, t3) {
        if ("string" == typeof t3 && (t3 = n2.from(t3)), !(t3 instanceof n2))
          throw new TypeError("Not a string or buffer");
        let i3 = e5._finishFlushFlag;
        return null == i3 && (i3 = a2.Z_FINISH), e5._processChunk(t3, i3);
      }
      function f2(e5, t3) {
        return c2(new l2(t3), e5);
      }
      l2.prototype._processChunk = function(e5, t3, i3) {
        if ("function" == typeof i3)
          return a2.Inflate._processChunk.call(this, e5, t3, i3);
        let o3, l3, u3 = this, c3 = e5 && e5.length, f3 = this._chunkSize - this._offset, d = this._maxLength, p2 = 0, m = [], _2 = 0;
        function g(e6, t4) {
          if (u3._hadError)
            return;
          let i4 = f3 - t4;
          if (r3(i4 >= 0, "have should not go down"), i4 > 0) {
            let e7 = u3._buffer.slice(u3._offset, u3._offset + i4);
            if (u3._offset += i4, e7.length > d && (e7 = e7.slice(0, d)), m.push(e7), _2 += e7.length, d -= e7.length, 0 === d)
              return false;
          }
          return (0 === t4 || u3._offset >= u3._chunkSize) && (f3 = u3._chunkSize, u3._offset = 0, u3._buffer = n2.allocUnsafe(u3._chunkSize)), 0 === t4 && (p2 += c3 - e6, c3 = e6, true);
        }
        this.on("error", function(e6) {
          o3 = e6;
        }), r3(this._handle, "zlib binding closed");
        do {
          l3 = this._handle.writeSync(t3, e5, p2, c3, this._buffer, this._offset, f3), l3 = l3 || this._writeState;
        } while (!this._hadError && g(l3[0], l3[1]));
        if (this._hadError)
          throw o3;
        if (_2 >= s2)
          throw h2(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + s2.toString(16) + " bytes");
        let b2 = n2.concat(m, _2);
        return h2(this), b2;
      }, o2.inherits(l2, a2.Inflate), t2.exports = i2 = f2, i2.Inflate = l2, i2.createInflate = u2, i2.inflateSync = f2;
    }).call(this);
  }).call(this, e4("_process"), e4("buffer").Buffer);
}, { _process: 63, assert: 23, buffer: 32, util: 84, zlib: 31 }], 22: [function(e4, t2, i2) {
  let r2 = t2.exports = function(e5) {
    this._buffer = e5, this._reads = [];
  };
  r2.prototype.read = function(e5, t3) {
    this._reads.push({ length: Math.abs(e5), allowLess: e5 < 0, func: t3 });
  }, r2.prototype.process = function() {
    for (; this._reads.length > 0 && this._buffer.length; ) {
      let e5 = this._reads[0];
      if (!this._buffer.length || !(this._buffer.length >= e5.length || e5.allowLess))
        break;
      {
        this._reads.shift();
        let t3 = this._buffer;
        this._buffer = t3.slice(e5.length), e5.func.call(this, t3.slice(0, e5.length));
      }
    }
    if (this._reads.length > 0)
      throw new Error("There are some read requests waitng on finished stream");
    if (this._buffer.length > 0)
      throw new Error("unrecognised content at end of stream");
  };
}, {}], 23: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      var r2 = e4("object-assign");
      function n2(e5, t3) {
        if (e5 === t3)
          return 0;
        for (var i4 = e5.length, r3 = t3.length, n3 = 0, a3 = Math.min(i4, r3); n3 < a3; ++n3)
          if (e5[n3] !== t3[n3]) {
            i4 = e5[n3], r3 = t3[n3];
            break;
          }
        return i4 < r3 ? -1 : r3 < i4 ? 1 : 0;
      }
      function a2(e5) {
        return i3.Buffer && "function" == typeof i3.Buffer.isBuffer ? i3.Buffer.isBuffer(e5) : !(null == e5 || !e5._isBuffer);
      }
      var o2 = e4("util/"), s2 = Object.prototype.hasOwnProperty, l2 = Array.prototype.slice, u2 = "foo" === function() {
      }.name;
      function h2(e5) {
        return Object.prototype.toString.call(e5);
      }
      function c2(e5) {
        return !a2(e5) && "function" == typeof i3.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e5) : !!e5 && (e5 instanceof DataView || !!(e5.buffer && e5.buffer instanceof ArrayBuffer)));
      }
      var f2 = t2.exports = y2, d = /\s*function\s+([^\(\s]*)\s*/;
      function p2(e5) {
        if (o2.isFunction(e5)) {
          if (u2)
            return e5.name;
          var t3 = e5.toString().match(d);
          return t3 && t3[1];
        }
      }
      function m(e5, t3) {
        return "string" == typeof e5 ? e5.length < t3 ? e5 : e5.slice(0, t3) : e5;
      }
      function _2(e5) {
        if (u2 || !o2.isFunction(e5))
          return o2.inspect(e5);
        var t3 = p2(e5);
        return "[Function" + (t3 ? ": " + t3 : "") + "]";
      }
      function g(e5) {
        return m(_2(e5.actual), 128) + " " + e5.operator + " " + m(_2(e5.expected), 128);
      }
      function b2(e5, t3, i4, r3, n3) {
        throw new f2.AssertionError({ message: i4, actual: e5, expected: t3, operator: r3, stackStartFunction: n3 });
      }
      function y2(e5, t3) {
        e5 || b2(e5, true, t3, "==", f2.ok);
      }
      function w(e5, t3, i4, r3) {
        if (e5 === t3)
          return true;
        if (a2(e5) && a2(t3))
          return 0 === n2(e5, t3);
        if (o2.isDate(e5) && o2.isDate(t3))
          return e5.getTime() === t3.getTime();
        if (o2.isRegExp(e5) && o2.isRegExp(t3))
          return e5.source === t3.source && e5.global === t3.global && e5.multiline === t3.multiline && e5.lastIndex === t3.lastIndex && e5.ignoreCase === t3.ignoreCase;
        if (null !== e5 && "object" == typeof e5 || null !== t3 && "object" == typeof t3) {
          if (c2(e5) && c2(t3) && h2(e5) === h2(t3) && !(e5 instanceof Float32Array || e5 instanceof Float64Array))
            return 0 === n2(new Uint8Array(e5.buffer), new Uint8Array(t3.buffer));
          if (a2(e5) !== a2(t3))
            return false;
          var s3 = (r3 = r3 || { actual: [], expected: [] }).actual.indexOf(e5);
          return -1 !== s3 && s3 === r3.expected.indexOf(t3) || (r3.actual.push(e5), r3.expected.push(t3), x2(e5, t3, i4, r3));
        }
        return i4 ? e5 === t3 : e5 == t3;
      }
      function v2(e5) {
        return "[object Arguments]" == Object.prototype.toString.call(e5);
      }
      function x2(e5, t3, i4, r3) {
        if (null == e5 || null == t3)
          return false;
        if (o2.isPrimitive(e5) || o2.isPrimitive(t3))
          return e5 === t3;
        if (i4 && Object.getPrototypeOf(e5) !== Object.getPrototypeOf(t3))
          return false;
        var n3 = v2(e5), a3 = v2(t3);
        if (n3 && !a3 || !n3 && a3)
          return false;
        if (n3)
          return w(e5 = l2.call(e5), t3 = l2.call(t3), i4);
        var s3, u3, h3 = M2(e5), c3 = M2(t3);
        if (h3.length !== c3.length)
          return false;
        for (h3.sort(), c3.sort(), u3 = h3.length - 1; u3 >= 0; u3--)
          if (h3[u3] !== c3[u3])
            return false;
        for (u3 = h3.length - 1; u3 >= 0; u3--)
          if (!w(e5[s3 = h3[u3]], t3[s3], i4, r3))
            return false;
        return true;
      }
      function E2(e5, t3, i4) {
        w(e5, t3, true) && b2(e5, t3, i4, "notDeepStrictEqual", E2);
      }
      function k2(e5, t3) {
        if (!e5 || !t3)
          return false;
        if ("[object RegExp]" == Object.prototype.toString.call(t3))
          return t3.test(e5);
        try {
          if (e5 instanceof t3)
            return true;
        } catch (e6) {
        }
        return !Error.isPrototypeOf(t3) && true === t3.call({}, e5);
      }
      function S2(e5) {
        var t3;
        try {
          e5();
        } catch (e6) {
          t3 = e6;
        }
        return t3;
      }
      function A2(e5, t3, i4, r3) {
        var n3;
        if ("function" != typeof t3)
          throw new TypeError('"block" argument must be a function');
        "string" == typeof i4 && (r3 = i4, i4 = null), n3 = S2(t3), r3 = (i4 && i4.name ? " (" + i4.name + ")." : ".") + (r3 ? " " + r3 : "."), e5 && !n3 && b2(n3, i4, "Missing expected exception" + r3);
        var a3 = "string" == typeof r3, s3 = !e5 && n3 && !i4;
        if ((!e5 && o2.isError(n3) && a3 && k2(n3, i4) || s3) && b2(n3, i4, "Got unwanted exception" + r3), e5 && n3 && i4 && !k2(n3, i4) || !e5 && n3)
          throw n3;
      }
      function I(e5, t3) {
        e5 || b2(e5, true, t3, "==", I);
      }
      f2.AssertionError = function(e5) {
        this.name = "AssertionError", this.actual = e5.actual, this.expected = e5.expected, this.operator = e5.operator, e5.message ? (this.message = e5.message, this.generatedMessage = false) : (this.message = g(this), this.generatedMessage = true);
        var t3 = e5.stackStartFunction || b2;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, t3);
        else {
          var i4 = new Error();
          if (i4.stack) {
            var r3 = i4.stack, n3 = p2(t3), a3 = r3.indexOf("\n" + n3);
            if (a3 >= 0) {
              var o3 = r3.indexOf("\n", a3 + 1);
              r3 = r3.substring(o3 + 1);
            }
            this.stack = r3;
          }
        }
      }, o2.inherits(f2.AssertionError, Error), f2.fail = b2, f2.ok = y2, f2.equal = function(e5, t3, i4) {
        e5 != t3 && b2(e5, t3, i4, "==", f2.equal);
      }, f2.notEqual = function(e5, t3, i4) {
        e5 == t3 && b2(e5, t3, i4, "!=", f2.notEqual);
      }, f2.deepEqual = function(e5, t3, i4) {
        w(e5, t3, false) || b2(e5, t3, i4, "deepEqual", f2.deepEqual);
      }, f2.deepStrictEqual = function(e5, t3, i4) {
        w(e5, t3, true) || b2(e5, t3, i4, "deepStrictEqual", f2.deepStrictEqual);
      }, f2.notDeepEqual = function(e5, t3, i4) {
        w(e5, t3, false) && b2(e5, t3, i4, "notDeepEqual", f2.notDeepEqual);
      }, f2.notDeepStrictEqual = E2, f2.strictEqual = function(e5, t3, i4) {
        e5 !== t3 && b2(e5, t3, i4, "===", f2.strictEqual);
      }, f2.notStrictEqual = function(e5, t3, i4) {
        e5 === t3 && b2(e5, t3, i4, "!==", f2.notStrictEqual);
      }, f2.throws = function(e5, t3, i4) {
        A2(true, e5, t3, i4);
      }, f2.doesNotThrow = function(e5, t3, i4) {
        A2(false, e5, t3, i4);
      }, f2.ifError = function(e5) {
        if (e5)
          throw e5;
      }, f2.strict = r2(I, f2, { equal: f2.strictEqual, deepEqual: f2.deepStrictEqual, notEqual: f2.notStrictEqual, notDeepEqual: f2.notDeepStrictEqual }), f2.strict.strict = f2.strict;
      var M2 = Object.keys || function(e5) {
        var t3 = [];
        for (var i4 in e5)
          s2.call(e5, i4) && t3.push(i4);
        return t3;
      };
    }).call(this);
  }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, { "object-assign": 51, "util/": 26 }], 24: [function(e4, t2, i2) {
  "function" == typeof Object.create ? t2.exports = function(e5, t3) {
    e5.super_ = t3, e5.prototype = Object.create(t3.prototype, { constructor: { value: e5, enumerable: false, writable: true, configurable: true } });
  } : t2.exports = function(e5, t3) {
    e5.super_ = t3;
    var i3 = function() {
    };
    i3.prototype = t3.prototype, e5.prototype = new i3(), e5.prototype.constructor = e5;
  };
}, {}], 25: [function(e4, t2, i2) {
  t2.exports = function(e5) {
    return e5 && "object" == typeof e5 && "function" == typeof e5.copy && "function" == typeof e5.fill && "function" == typeof e5.readUInt8;
  };
}, {}], 26: [function(e4, t2, i2) {
  (function(t3, r2) {
    (function() {
      var n2 = /%[sdj%]/g;
      i2.format = function(e5) {
        if (!x2(e5)) {
          for (var t4 = [], i3 = 0; i3 < arguments.length; i3++)
            t4.push(s2(arguments[i3]));
          return t4.join(" ");
        }
        i3 = 1;
        for (var r3 = arguments, a3 = r3.length, o3 = String(e5).replace(n2, function(e6) {
          if ("%%" === e6)
            return "%";
          if (i3 >= a3)
            return e6;
          switch (e6) {
            case "%s":
              return String(r3[i3++]);
            case "%d":
              return Number(r3[i3++]);
            case "%j":
              try {
                return JSON.stringify(r3[i3++]);
              } catch (e7) {
                return "[Circular]";
              }
            default:
              return e6;
          }
        }), l3 = r3[i3]; i3 < a3; l3 = r3[++i3])
          y2(l3) || !A2(l3) ? o3 += " " + l3 : o3 += " " + s2(l3);
        return o3;
      }, i2.deprecate = function(e5, n3) {
        if (k2(r2.process))
          return function() {
            return i2.deprecate(e5, n3).apply(this, arguments);
          };
        if (true === t3.noDeprecation)
          return e5;
        var a3 = false;
        function o3() {
          if (!a3) {
            if (t3.throwDeprecation)
              throw new Error(n3);
            t3.traceDeprecation ? console.trace(n3) : console.error(n3), a3 = true;
          }
          return e5.apply(this, arguments);
        }
        return o3;
      };
      var a2, o2 = {};
      function s2(e5, t4) {
        var r3 = { seen: [], stylize: u2 };
        return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), b2(t4) ? r3.showHidden = t4 : t4 && i2._extend(r3, t4), k2(r3.showHidden) && (r3.showHidden = false), k2(r3.depth) && (r3.depth = 2), k2(r3.colors) && (r3.colors = false), k2(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = l2), c2(r3, e5, r3.depth);
      }
      function l2(e5, t4) {
        var i3 = s2.styles[t4];
        return i3 ? "\x1B[" + s2.colors[i3][0] + "m" + e5 + "\x1B[" + s2.colors[i3][1] + "m" : e5;
      }
      function u2(e5, t4) {
        return e5;
      }
      function h2(e5) {
        var t4 = {};
        return e5.forEach(function(e6, i3) {
          t4[e6] = true;
        }), t4;
      }
      function c2(e5, t4, r3) {
        if (e5.customInspect && t4 && T2(t4.inspect) && t4.inspect !== i2.inspect && (!t4.constructor || t4.constructor.prototype !== t4)) {
          var n3 = t4.inspect(r3, e5);
          return x2(n3) || (n3 = c2(e5, n3, r3)), n3;
        }
        var a3 = f2(e5, t4);
        if (a3)
          return a3;
        var o3 = Object.keys(t4), s3 = h2(o3);
        if (e5.showHidden && (o3 = Object.getOwnPropertyNames(t4)), M2(t4) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
          return d(t4);
        if (0 === o3.length) {
          if (T2(t4)) {
            var l3 = t4.name ? ": " + t4.name : "";
            return e5.stylize("[Function" + l3 + "]", "special");
          }
          if (S2(t4))
            return e5.stylize(RegExp.prototype.toString.call(t4), "regexp");
          if (I(t4))
            return e5.stylize(Date.prototype.toString.call(t4), "date");
          if (M2(t4))
            return d(t4);
        }
        var u3, b3 = "", y3 = false, w2 = ["{", "}"];
        return g(t4) && (y3 = true, w2 = ["[", "]"]), T2(t4) && (b3 = " [Function" + (t4.name ? ": " + t4.name : "") + "]"), S2(t4) && (b3 = " " + RegExp.prototype.toString.call(t4)), I(t4) && (b3 = " " + Date.prototype.toUTCString.call(t4)), M2(t4) && (b3 = " " + d(t4)), 0 !== o3.length || y3 && 0 != t4.length ? r3 < 0 ? S2(t4) ? e5.stylize(RegExp.prototype.toString.call(t4), "regexp") : e5.stylize("[Object]", "special") : (e5.seen.push(t4), u3 = y3 ? p2(e5, t4, r3, s3, o3) : o3.map(function(i3) {
          return m(e5, t4, r3, s3, i3, y3);
        }), e5.seen.pop(), _2(u3, b3, w2)) : w2[0] + b3 + w2[1];
      }
      function f2(e5, t4) {
        if (k2(t4))
          return e5.stylize("undefined", "undefined");
        if (x2(t4)) {
          var i3 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e5.stylize(i3, "string");
        }
        return v2(t4) ? e5.stylize("" + t4, "number") : b2(t4) ? e5.stylize("" + t4, "boolean") : y2(t4) ? e5.stylize("null", "null") : void 0;
      }
      function d(e5) {
        return "[" + Error.prototype.toString.call(e5) + "]";
      }
      function p2(e5, t4, i3, r3, n3) {
        for (var a3 = [], o3 = 0, s3 = t4.length; o3 < s3; ++o3)
          F(t4, String(o3)) ? a3.push(m(e5, t4, i3, r3, String(o3), true)) : a3.push("");
        return n3.forEach(function(n4) {
          n4.match(/^\d+$/) || a3.push(m(e5, t4, i3, r3, n4, true));
        }), a3;
      }
      function m(e5, t4, i3, r3, n3, a3) {
        var o3, s3, l3;
        if ((l3 = Object.getOwnPropertyDescriptor(t4, n3) || { value: t4[n3] }).get ? s3 = l3.set ? e5.stylize("[Getter/Setter]", "special") : e5.stylize("[Getter]", "special") : l3.set && (s3 = e5.stylize("[Setter]", "special")), F(r3, n3) || (o3 = "[" + n3 + "]"), s3 || (e5.seen.indexOf(l3.value) < 0 ? (s3 = y2(i3) ? c2(e5, l3.value, null) : c2(e5, l3.value, i3 - 1)).indexOf("\n") > -1 && (s3 = a3 ? s3.split("\n").map(function(e6) {
          return "  " + e6;
        }).join("\n").substr(2) : "\n" + s3.split("\n").map(function(e6) {
          return "   " + e6;
        }).join("\n")) : s3 = e5.stylize("[Circular]", "special")), k2(o3)) {
          if (a3 && n3.match(/^\d+$/))
            return s3;
          (o3 = JSON.stringify("" + n3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o3 = o3.substr(1, o3.length - 2), o3 = e5.stylize(o3, "name")) : (o3 = o3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o3 = e5.stylize(o3, "string"));
        }
        return o3 + ": " + s3;
      }
      function _2(e5, t4, i3) {
        return e5.reduce(function(e6, t5) {
          return t5.indexOf("\n"), e6 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? i3[0] + ("" === t4 ? "" : t4 + "\n ") + " " + e5.join(",\n  ") + " " + i3[1] : i3[0] + t4 + " " + e5.join(", ") + " " + i3[1];
      }
      function g(e5) {
        return Array.isArray(e5);
      }
      function b2(e5) {
        return "boolean" == typeof e5;
      }
      function y2(e5) {
        return null === e5;
      }
      function w(e5) {
        return null == e5;
      }
      function v2(e5) {
        return "number" == typeof e5;
      }
      function x2(e5) {
        return "string" == typeof e5;
      }
      function E2(e5) {
        return "symbol" == typeof e5;
      }
      function k2(e5) {
        return void 0 === e5;
      }
      function S2(e5) {
        return A2(e5) && "[object RegExp]" === B2(e5);
      }
      function A2(e5) {
        return "object" == typeof e5 && null !== e5;
      }
      function I(e5) {
        return A2(e5) && "[object Date]" === B2(e5);
      }
      function M2(e5) {
        return A2(e5) && ("[object Error]" === B2(e5) || e5 instanceof Error);
      }
      function T2(e5) {
        return "function" == typeof e5;
      }
      function P(e5) {
        return null === e5 || "boolean" == typeof e5 || "number" == typeof e5 || "string" == typeof e5 || "symbol" == typeof e5 || void 0 === e5;
      }
      function B2(e5) {
        return Object.prototype.toString.call(e5);
      }
      function C2(e5) {
        return e5 < 10 ? "0" + e5.toString(10) : e5.toString(10);
      }
      i2.debuglog = function(e5) {
        if (k2(a2) && (a2 = t3.env.NODE_DEBUG || ""), e5 = e5.toUpperCase(), !o2[e5])
          if (new RegExp("\\b" + e5 + "\\b", "i").test(a2)) {
            var r3 = t3.pid;
            o2[e5] = function() {
              var t4 = i2.format.apply(i2, arguments);
              console.error("%s %d: %s", e5, r3, t4);
            };
          } else
            o2[e5] = function() {
            };
        return o2[e5];
      }, i2.inspect = s2, s2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, s2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.isArray = g, i2.isBoolean = b2, i2.isNull = y2, i2.isNullOrUndefined = w, i2.isNumber = v2, i2.isString = x2, i2.isSymbol = E2, i2.isUndefined = k2, i2.isRegExp = S2, i2.isObject = A2, i2.isDate = I, i2.isError = M2, i2.isFunction = T2, i2.isPrimitive = P, i2.isBuffer = e4("./support/isBuffer");
      var R2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function z2() {
        var e5 = new Date(), t4 = [C2(e5.getHours()), C2(e5.getMinutes()), C2(e5.getSeconds())].join(":");
        return [e5.getDate(), R2[e5.getMonth()], t4].join(" ");
      }
      function F(e5, t4) {
        return Object.prototype.hasOwnProperty.call(e5, t4);
      }
      i2.log = function() {
        console.log("%s - %s", z2(), i2.format.apply(i2, arguments));
      }, i2.inherits = e4("inherits"), i2._extend = function(e5, t4) {
        if (!t4 || !A2(t4))
          return e5;
        for (var i3 = Object.keys(t4), r3 = i3.length; r3--; )
          e5[i3[r3]] = t4[i3[r3]];
        return e5;
      };
    }).call(this);
  }).call(this, e4("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, { "./support/isBuffer": 25, _process: 63, inherits: 24 }], 27: [function(e4, t2, i2) {
  (function(e5) {
    (function() {
      var i3 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], r2 = "undefined" == typeof globalThis ? e5 : globalThis;
      t2.exports = function() {
        for (var e6 = [], t3 = 0; t3 < i3.length; t3++)
          "function" == typeof r2[i3[t3]] && (e6[e6.length] = i3[t3]);
        return e6;
      };
    }).call(this);
  }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, {}], 28: [function(e4, t2, i2) {
  i2.byteLength = h2, i2.toByteArray = f2, i2.fromByteArray = m;
  for (var r2 = [], n2 = [], a2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s2 = 0, l2 = o2.length; s2 < l2; ++s2)
    r2[s2] = o2[s2], n2[o2.charCodeAt(s2)] = s2;
  function u2(e5) {
    var t3 = e5.length;
    if (t3 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var i3 = e5.indexOf("=");
    return -1 === i3 && (i3 = t3), [i3, i3 === t3 ? 0 : 4 - i3 % 4];
  }
  function h2(e5) {
    var t3 = u2(e5), i3 = t3[0], r3 = t3[1];
    return 3 * (i3 + r3) / 4 - r3;
  }
  function c2(e5, t3, i3) {
    return 3 * (t3 + i3) / 4 - i3;
  }
  function f2(e5) {
    var t3, i3, r3 = u2(e5), o3 = r3[0], s3 = r3[1], l3 = new a2(c2(e5, o3, s3)), h3 = 0, f3 = s3 > 0 ? o3 - 4 : o3;
    for (i3 = 0; i3 < f3; i3 += 4)
      t3 = n2[e5.charCodeAt(i3)] << 18 | n2[e5.charCodeAt(i3 + 1)] << 12 | n2[e5.charCodeAt(i3 + 2)] << 6 | n2[e5.charCodeAt(i3 + 3)], l3[h3++] = t3 >> 16 & 255, l3[h3++] = t3 >> 8 & 255, l3[h3++] = 255 & t3;
    return 2 === s3 && (t3 = n2[e5.charCodeAt(i3)] << 2 | n2[e5.charCodeAt(i3 + 1)] >> 4, l3[h3++] = 255 & t3), 1 === s3 && (t3 = n2[e5.charCodeAt(i3)] << 10 | n2[e5.charCodeAt(i3 + 1)] << 4 | n2[e5.charCodeAt(i3 + 2)] >> 2, l3[h3++] = t3 >> 8 & 255, l3[h3++] = 255 & t3), l3;
  }
  function d(e5) {
    return r2[e5 >> 18 & 63] + r2[e5 >> 12 & 63] + r2[e5 >> 6 & 63] + r2[63 & e5];
  }
  function p2(e5, t3, i3) {
    for (var r3, n3 = [], a3 = t3; a3 < i3; a3 += 3)
      r3 = (e5[a3] << 16 & 16711680) + (e5[a3 + 1] << 8 & 65280) + (255 & e5[a3 + 2]), n3.push(d(r3));
    return n3.join("");
  }
  function m(e5) {
    for (var t3, i3 = e5.length, n3 = i3 % 3, a3 = [], o3 = 16383, s3 = 0, l3 = i3 - n3; s3 < l3; s3 += o3)
      a3.push(p2(e5, s3, s3 + o3 > l3 ? l3 : s3 + o3));
    return 1 === n3 ? (t3 = e5[i3 - 1], a3.push(r2[t3 >> 2] + r2[t3 << 4 & 63] + "==")) : 2 === n3 && (t3 = (e5[i3 - 2] << 8) + e5[i3 - 1], a3.push(r2[t3 >> 10] + r2[t3 >> 4 & 63] + r2[t3 << 2 & 63] + "=")), a3.join("");
  }
  n2["-".charCodeAt(0)] = 62, n2["_".charCodeAt(0)] = 63;
}, {}], 29: [function(e4, t2, i2) {
}, {}], 30: [function(e4, t2, i2) {
  (function(t3, r2) {
    (function() {
      var n2 = e4("assert"), a2 = e4("pako/lib/zlib/zstream"), o2 = e4("pako/lib/zlib/deflate.js"), s2 = e4("pako/lib/zlib/inflate.js"), l2 = e4("pako/lib/zlib/constants");
      for (var u2 in l2)
        i2[u2] = l2[u2];
      i2.NONE = 0, i2.DEFLATE = 1, i2.INFLATE = 2, i2.GZIP = 3, i2.GUNZIP = 4, i2.DEFLATERAW = 5, i2.INFLATERAW = 6, i2.UNZIP = 7;
      var h2 = 31, c2 = 139;
      function f2(e5) {
        if ("number" != typeof e5 || e5 < i2.DEFLATE || e5 > i2.UNZIP)
          throw new TypeError("Bad argument");
        this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = false, this.level = 0, this.memLevel = 0, this.mode = e5, this.strategy = 0, this.windowBits = 0, this.write_in_progress = false, this.pending_close = false, this.gzip_id_bytes_read = 0;
      }
      f2.prototype.close = function() {
        this.write_in_progress ? this.pending_close = true : (this.pending_close = false, n2(this.init_done, "close before init"), n2(this.mode <= i2.UNZIP), this.mode === i2.DEFLATE || this.mode === i2.GZIP || this.mode === i2.DEFLATERAW ? o2.deflateEnd(this.strm) : this.mode !== i2.INFLATE && this.mode !== i2.GUNZIP && this.mode !== i2.INFLATERAW && this.mode !== i2.UNZIP || s2.inflateEnd(this.strm), this.mode = i2.NONE, this.dictionary = null);
      }, f2.prototype.write = function(e5, t4, i3, r3, n3, a3, o3) {
        return this._write(true, e5, t4, i3, r3, n3, a3, o3);
      }, f2.prototype.writeSync = function(e5, t4, i3, r3, n3, a3, o3) {
        return this._write(false, e5, t4, i3, r3, n3, a3, o3);
      }, f2.prototype._write = function(e5, a3, o3, s3, l3, u3, h3, c3) {
        if (n2.equal(arguments.length, 8), n2(this.init_done, "write before init"), n2(this.mode !== i2.NONE, "already finalized"), n2.equal(false, this.write_in_progress, "write already in progress"), n2.equal(false, this.pending_close, "close is pending"), this.write_in_progress = true, n2.equal(false, void 0 === a3, "must provide flush value"), this.write_in_progress = true, a3 !== i2.Z_NO_FLUSH && a3 !== i2.Z_PARTIAL_FLUSH && a3 !== i2.Z_SYNC_FLUSH && a3 !== i2.Z_FULL_FLUSH && a3 !== i2.Z_FINISH && a3 !== i2.Z_BLOCK)
          throw new Error("Invalid flush value");
        if (null == o3 && (o3 = r2.alloc(0), l3 = 0, s3 = 0), this.strm.avail_in = l3, this.strm.input = o3, this.strm.next_in = s3, this.strm.avail_out = c3, this.strm.output = u3, this.strm.next_out = h3, this.flush = a3, !e5)
          return this._process(), this._checkError() ? this._afterSync() : void 0;
        var f3 = this;
        return t3.nextTick(function() {
          f3._process(), f3._after();
        }), this;
      }, f2.prototype._afterSync = function() {
        var e5 = this.strm.avail_out, t4 = this.strm.avail_in;
        return this.write_in_progress = false, [t4, e5];
      }, f2.prototype._process = function() {
        var e5 = null;
        switch (this.mode) {
          case i2.DEFLATE:
          case i2.GZIP:
          case i2.DEFLATERAW:
            this.err = o2.deflate(this.strm, this.flush);
            break;
          case i2.UNZIP:
            switch (this.strm.avail_in > 0 && (e5 = this.strm.next_in), this.gzip_id_bytes_read) {
              case 0:
                if (null === e5)
                  break;
                if (this.strm.input[e5] !== h2) {
                  this.mode = i2.INFLATE;
                  break;
                }
                if (this.gzip_id_bytes_read = 1, e5++, 1 === this.strm.avail_in)
                  break;
              case 1:
                if (null === e5)
                  break;
                this.strm.input[e5] === c2 ? (this.gzip_id_bytes_read = 2, this.mode = i2.GUNZIP) : this.mode = i2.INFLATE;
                break;
              default:
                throw new Error("invalid number of gzip magic number bytes read");
            }
          case i2.INFLATE:
          case i2.GUNZIP:
          case i2.INFLATERAW:
            for (this.err = s2.inflate(this.strm, this.flush), this.err === i2.Z_NEED_DICT && this.dictionary && (this.err = s2.inflateSetDictionary(this.strm, this.dictionary), this.err === i2.Z_OK ? this.err = s2.inflate(this.strm, this.flush) : this.err === i2.Z_DATA_ERROR && (this.err = i2.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === i2.GUNZIP && this.err === i2.Z_STREAM_END && 0 !== this.strm.next_in[0]; )
              this.reset(), this.err = s2.inflate(this.strm, this.flush);
            break;
          default:
            throw new Error("Unknown mode " + this.mode);
        }
      }, f2.prototype._checkError = function() {
        switch (this.err) {
          case i2.Z_OK:
          case i2.Z_BUF_ERROR:
            if (0 !== this.strm.avail_out && this.flush === i2.Z_FINISH)
              return this._error("unexpected end of file"), false;
            break;
          case i2.Z_STREAM_END:
            break;
          case i2.Z_NEED_DICT:
            return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), false;
          default:
            return this._error("Zlib error"), false;
        }
        return true;
      }, f2.prototype._after = function() {
        if (this._checkError()) {
          var e5 = this.strm.avail_out, t4 = this.strm.avail_in;
          this.write_in_progress = false, this.callback(t4, e5), this.pending_close && this.close();
        }
      }, f2.prototype._error = function(e5) {
        this.strm.msg && (e5 = this.strm.msg), this.onerror(e5, this.err), this.write_in_progress = false, this.pending_close && this.close();
      }, f2.prototype.init = function(e5, t4, r3, a3, o3) {
        n2(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), n2(e5 >= 8 && e5 <= 15, "invalid windowBits"), n2(t4 >= -1 && t4 <= 9, "invalid compression level"), n2(r3 >= 1 && r3 <= 9, "invalid memlevel"), n2(a3 === i2.Z_FILTERED || a3 === i2.Z_HUFFMAN_ONLY || a3 === i2.Z_RLE || a3 === i2.Z_FIXED || a3 === i2.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(t4, e5, r3, a3, o3), this._setDictionary();
      }, f2.prototype.params = function() {
        throw new Error("deflateParams Not supported");
      }, f2.prototype.reset = function() {
        this._reset(), this._setDictionary();
      }, f2.prototype._init = function(e5, t4, r3, n3, l3) {
        switch (this.level = e5, this.windowBits = t4, this.memLevel = r3, this.strategy = n3, this.flush = i2.Z_NO_FLUSH, this.err = i2.Z_OK, this.mode !== i2.GZIP && this.mode !== i2.GUNZIP || (this.windowBits += 16), this.mode === i2.UNZIP && (this.windowBits += 32), this.mode !== i2.DEFLATERAW && this.mode !== i2.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new a2(), this.mode) {
          case i2.DEFLATE:
          case i2.GZIP:
          case i2.DEFLATERAW:
            this.err = o2.deflateInit2(this.strm, this.level, i2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
            break;
          case i2.INFLATE:
          case i2.GUNZIP:
          case i2.INFLATERAW:
          case i2.UNZIP:
            this.err = s2.inflateInit2(this.strm, this.windowBits);
            break;
          default:
            throw new Error("Unknown mode " + this.mode);
        }
        this.err !== i2.Z_OK && this._error("Init error"), this.dictionary = l3, this.write_in_progress = false, this.init_done = true;
      }, f2.prototype._setDictionary = function() {
        if (null != this.dictionary) {
          switch (this.err = i2.Z_OK, this.mode) {
            case i2.DEFLATE:
            case i2.DEFLATERAW:
              this.err = o2.deflateSetDictionary(this.strm, this.dictionary);
          }
          this.err !== i2.Z_OK && this._error("Failed to set dictionary");
        }
      }, f2.prototype._reset = function() {
        switch (this.err = i2.Z_OK, this.mode) {
          case i2.DEFLATE:
          case i2.DEFLATERAW:
          case i2.GZIP:
            this.err = o2.deflateReset(this.strm);
            break;
          case i2.INFLATE:
          case i2.INFLATERAW:
          case i2.GUNZIP:
            this.err = s2.inflateReset(this.strm);
        }
        this.err !== i2.Z_OK && this._error("Failed to reset stream");
      }, i2.Zlib = f2;
    }).call(this);
  }).call(this, e4("_process"), e4("buffer").Buffer);
}, { _process: 63, assert: 23, buffer: 32, "pako/lib/zlib/constants": 54, "pako/lib/zlib/deflate.js": 56, "pako/lib/zlib/inflate.js": 58, "pako/lib/zlib/zstream": 62 }], 31: [function(e4, t2, i2) {
  (function(t3) {
    (function() {
      var r2 = e4("buffer").Buffer, n2 = e4("stream").Transform, a2 = e4("./binding"), o2 = e4("util"), s2 = e4("assert").ok, l2 = e4("buffer").kMaxLength, u2 = "Cannot create final Buffer. It would be larger than 0x" + l2.toString(16) + " bytes";
      a2.Z_MIN_WINDOWBITS = 8, a2.Z_MAX_WINDOWBITS = 15, a2.Z_DEFAULT_WINDOWBITS = 15, a2.Z_MIN_CHUNK = 64, a2.Z_MAX_CHUNK = 1 / 0, a2.Z_DEFAULT_CHUNK = 16384, a2.Z_MIN_MEMLEVEL = 1, a2.Z_MAX_MEMLEVEL = 9, a2.Z_DEFAULT_MEMLEVEL = 8, a2.Z_MIN_LEVEL = -1, a2.Z_MAX_LEVEL = 9, a2.Z_DEFAULT_LEVEL = a2.Z_DEFAULT_COMPRESSION;
      for (var h2 = Object.keys(a2), c2 = 0; c2 < h2.length; c2++) {
        var f2 = h2[c2];
        f2.match(/^Z/) && Object.defineProperty(i2, f2, { enumerable: true, value: a2[f2], writable: false });
      }
      for (var d = { Z_OK: a2.Z_OK, Z_STREAM_END: a2.Z_STREAM_END, Z_NEED_DICT: a2.Z_NEED_DICT, Z_ERRNO: a2.Z_ERRNO, Z_STREAM_ERROR: a2.Z_STREAM_ERROR, Z_DATA_ERROR: a2.Z_DATA_ERROR, Z_MEM_ERROR: a2.Z_MEM_ERROR, Z_BUF_ERROR: a2.Z_BUF_ERROR, Z_VERSION_ERROR: a2.Z_VERSION_ERROR }, p2 = Object.keys(d), m = 0; m < p2.length; m++) {
        var _2 = p2[m];
        d[d[_2]] = _2;
      }
      function g(e5, t4, i3) {
        var n3 = [], a3 = 0;
        function o3() {
          for (var t5; null !== (t5 = e5.read()); )
            n3.push(t5), a3 += t5.length;
          e5.once("readable", o3);
        }
        function s3(t5) {
          e5.removeListener("end", h3), e5.removeListener("readable", o3), i3(t5);
        }
        function h3() {
          var t5, o4 = null;
          a3 >= l2 ? o4 = new RangeError(u2) : t5 = r2.concat(n3, a3), n3 = [], e5.close(), i3(o4, t5);
        }
        e5.on("error", s3), e5.on("end", h3), e5.end(t4), o3();
      }
      function b2(e5, t4) {
        if ("string" == typeof t4 && (t4 = r2.from(t4)), !r2.isBuffer(t4))
          throw new TypeError("Not a string or buffer");
        var i3 = e5._finishFlushFlag;
        return e5._processChunk(t4, i3);
      }
      function y2(e5) {
        if (!(this instanceof y2))
          return new y2(e5);
        I.call(this, e5, a2.DEFLATE);
      }
      function w(e5) {
        if (!(this instanceof w))
          return new w(e5);
        I.call(this, e5, a2.INFLATE);
      }
      function v2(e5) {
        if (!(this instanceof v2))
          return new v2(e5);
        I.call(this, e5, a2.GZIP);
      }
      function x2(e5) {
        if (!(this instanceof x2))
          return new x2(e5);
        I.call(this, e5, a2.GUNZIP);
      }
      function E2(e5) {
        if (!(this instanceof E2))
          return new E2(e5);
        I.call(this, e5, a2.DEFLATERAW);
      }
      function k2(e5) {
        if (!(this instanceof k2))
          return new k2(e5);
        I.call(this, e5, a2.INFLATERAW);
      }
      function S2(e5) {
        if (!(this instanceof S2))
          return new S2(e5);
        I.call(this, e5, a2.UNZIP);
      }
      function A2(e5) {
        return e5 === a2.Z_NO_FLUSH || e5 === a2.Z_PARTIAL_FLUSH || e5 === a2.Z_SYNC_FLUSH || e5 === a2.Z_FULL_FLUSH || e5 === a2.Z_FINISH || e5 === a2.Z_BLOCK;
      }
      function I(e5, t4) {
        var o3 = this;
        if (this._opts = e5 = e5 || {}, this._chunkSize = e5.chunkSize || i2.Z_DEFAULT_CHUNK, n2.call(this, e5), e5.flush && !A2(e5.flush))
          throw new Error("Invalid flush flag: " + e5.flush);
        if (e5.finishFlush && !A2(e5.finishFlush))
          throw new Error("Invalid flush flag: " + e5.finishFlush);
        if (this._flushFlag = e5.flush || a2.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== e5.finishFlush ? e5.finishFlush : a2.Z_FINISH, e5.chunkSize && (e5.chunkSize < i2.Z_MIN_CHUNK || e5.chunkSize > i2.Z_MAX_CHUNK))
          throw new Error("Invalid chunk size: " + e5.chunkSize);
        if (e5.windowBits && (e5.windowBits < i2.Z_MIN_WINDOWBITS || e5.windowBits > i2.Z_MAX_WINDOWBITS))
          throw new Error("Invalid windowBits: " + e5.windowBits);
        if (e5.level && (e5.level < i2.Z_MIN_LEVEL || e5.level > i2.Z_MAX_LEVEL))
          throw new Error("Invalid compression level: " + e5.level);
        if (e5.memLevel && (e5.memLevel < i2.Z_MIN_MEMLEVEL || e5.memLevel > i2.Z_MAX_MEMLEVEL))
          throw new Error("Invalid memLevel: " + e5.memLevel);
        if (e5.strategy && e5.strategy != i2.Z_FILTERED && e5.strategy != i2.Z_HUFFMAN_ONLY && e5.strategy != i2.Z_RLE && e5.strategy != i2.Z_FIXED && e5.strategy != i2.Z_DEFAULT_STRATEGY)
          throw new Error("Invalid strategy: " + e5.strategy);
        if (e5.dictionary && !r2.isBuffer(e5.dictionary))
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        this._handle = new a2.Zlib(t4);
        var s3 = this;
        this._hadError = false, this._handle.onerror = function(e6, t5) {
          M2(s3), s3._hadError = true;
          var r3 = new Error(e6);
          r3.errno = t5, r3.code = i2.codes[t5], s3.emit("error", r3);
        };
        var l3 = i2.Z_DEFAULT_COMPRESSION;
        "number" == typeof e5.level && (l3 = e5.level);
        var u3 = i2.Z_DEFAULT_STRATEGY;
        "number" == typeof e5.strategy && (u3 = e5.strategy), this._handle.init(e5.windowBits || i2.Z_DEFAULT_WINDOWBITS, l3, e5.memLevel || i2.Z_DEFAULT_MEMLEVEL, u3, e5.dictionary), this._buffer = r2.allocUnsafe(this._chunkSize), this._offset = 0, this._level = l3, this._strategy = u3, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
          return !o3._handle;
        }, configurable: true, enumerable: true });
      }
      function M2(e5, i3) {
        i3 && t3.nextTick(i3), e5._handle && (e5._handle.close(), e5._handle = null);
      }
      function T2(e5) {
        e5.emit("close");
      }
      Object.defineProperty(i2, "codes", { enumerable: true, value: Object.freeze(d), writable: false }), i2.Deflate = y2, i2.Inflate = w, i2.Gzip = v2, i2.Gunzip = x2, i2.DeflateRaw = E2, i2.InflateRaw = k2, i2.Unzip = S2, i2.createDeflate = function(e5) {
        return new y2(e5);
      }, i2.createInflate = function(e5) {
        return new w(e5);
      }, i2.createDeflateRaw = function(e5) {
        return new E2(e5);
      }, i2.createInflateRaw = function(e5) {
        return new k2(e5);
      }, i2.createGzip = function(e5) {
        return new v2(e5);
      }, i2.createGunzip = function(e5) {
        return new x2(e5);
      }, i2.createUnzip = function(e5) {
        return new S2(e5);
      }, i2.deflate = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new y2(t4), e5, i3);
      }, i2.deflateSync = function(e5, t4) {
        return b2(new y2(t4), e5);
      }, i2.gzip = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new v2(t4), e5, i3);
      }, i2.gzipSync = function(e5, t4) {
        return b2(new v2(t4), e5);
      }, i2.deflateRaw = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new E2(t4), e5, i3);
      }, i2.deflateRawSync = function(e5, t4) {
        return b2(new E2(t4), e5);
      }, i2.unzip = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new S2(t4), e5, i3);
      }, i2.unzipSync = function(e5, t4) {
        return b2(new S2(t4), e5);
      }, i2.inflate = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new w(t4), e5, i3);
      }, i2.inflateSync = function(e5, t4) {
        return b2(new w(t4), e5);
      }, i2.gunzip = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new x2(t4), e5, i3);
      }, i2.gunzipSync = function(e5, t4) {
        return b2(new x2(t4), e5);
      }, i2.inflateRaw = function(e5, t4, i3) {
        return "function" == typeof t4 && (i3 = t4, t4 = {}), g(new k2(t4), e5, i3);
      }, i2.inflateRawSync = function(e5, t4) {
        return b2(new k2(t4), e5);
      }, o2.inherits(I, n2), I.prototype.params = function(e5, r3, n3) {
        if (e5 < i2.Z_MIN_LEVEL || e5 > i2.Z_MAX_LEVEL)
          throw new RangeError("Invalid compression level: " + e5);
        if (r3 != i2.Z_FILTERED && r3 != i2.Z_HUFFMAN_ONLY && r3 != i2.Z_RLE && r3 != i2.Z_FIXED && r3 != i2.Z_DEFAULT_STRATEGY)
          throw new TypeError("Invalid strategy: " + r3);
        if (this._level !== e5 || this._strategy !== r3) {
          var o3 = this;
          this.flush(a2.Z_SYNC_FLUSH, function() {
            s2(o3._handle, "zlib binding closed"), o3._handle.params(e5, r3), o3._hadError || (o3._level = e5, o3._strategy = r3, n3 && n3());
          });
        } else
          t3.nextTick(n3);
      }, I.prototype.reset = function() {
        return s2(this._handle, "zlib binding closed"), this._handle.reset();
      }, I.prototype._flush = function(e5) {
        this._transform(r2.alloc(0), "", e5);
      }, I.prototype.flush = function(e5, i3) {
        var n3 = this, o3 = this._writableState;
        ("function" == typeof e5 || void 0 === e5 && !i3) && (i3 = e5, e5 = a2.Z_FULL_FLUSH), o3.ended ? i3 && t3.nextTick(i3) : o3.ending ? i3 && this.once("end", i3) : o3.needDrain ? i3 && this.once("drain", function() {
          return n3.flush(e5, i3);
        }) : (this._flushFlag = e5, this.write(r2.alloc(0), "", i3));
      }, I.prototype.close = function(e5) {
        M2(this, e5), t3.nextTick(T2, this);
      }, I.prototype._transform = function(e5, t4, i3) {
        var n3, o3 = this._writableState, s3 = (o3.ending || o3.ended) && (!e5 || o3.length === e5.length);
        return null === e5 || r2.isBuffer(e5) ? this._handle ? (s3 ? n3 = this._finishFlushFlag : (n3 = this._flushFlag, e5.length >= o3.length && (this._flushFlag = this._opts.flush || a2.Z_NO_FLUSH)), void this._processChunk(e5, n3, i3)) : i3(new Error("zlib binding closed")) : i3(new Error("invalid input"));
      }, I.prototype._processChunk = function(e5, t4, i3) {
        var n3 = e5 && e5.length, a3 = this._chunkSize - this._offset, o3 = 0, h3 = this, c3 = "function" == typeof i3;
        if (!c3) {
          var f3, d2 = [], p3 = 0;
          this.on("error", function(e6) {
            f3 = e6;
          }), s2(this._handle, "zlib binding closed");
          do {
            var m2 = this._handle.writeSync(t4, e5, o3, n3, this._buffer, this._offset, a3);
          } while (!this._hadError && b3(m2[0], m2[1]));
          if (this._hadError)
            throw f3;
          if (p3 >= l2)
            throw M2(this), new RangeError(u2);
          var _3 = r2.concat(d2, p3);
          return M2(this), _3;
        }
        s2(this._handle, "zlib binding closed");
        var g2 = this._handle.write(t4, e5, o3, n3, this._buffer, this._offset, a3);
        function b3(l3, u3) {
          if (this && (this.buffer = null, this.callback = null), !h3._hadError) {
            var f4 = a3 - u3;
            if (s2(f4 >= 0, "have should not go down"), f4 > 0) {
              var m3 = h3._buffer.slice(h3._offset, h3._offset + f4);
              h3._offset += f4, c3 ? h3.push(m3) : (d2.push(m3), p3 += m3.length);
            }
            if ((0 === u3 || h3._offset >= h3._chunkSize) && (a3 = h3._chunkSize, h3._offset = 0, h3._buffer = r2.allocUnsafe(h3._chunkSize)), 0 === u3) {
              if (o3 += n3 - l3, n3 = l3, !c3)
                return true;
              var _4 = h3._handle.write(t4, e5, o3, n3, h3._buffer, h3._offset, h3._chunkSize);
              return _4.callback = b3, void (_4.buffer = e5);
            }
            if (!c3)
              return false;
            i3();
          }
        }
        g2.buffer = e5, g2.callback = b3;
      }, o2.inherits(y2, I), o2.inherits(w, I), o2.inherits(v2, I), o2.inherits(x2, I), o2.inherits(E2, I), o2.inherits(k2, I), o2.inherits(S2, I);
    }).call(this);
  }).call(this, e4("_process"));
}, { "./binding": 30, _process: 63, assert: 23, buffer: 32, stream: 65, util: 84 }], 32: [function(e4, t2, i2) {
  (function(t3) {
    (function() {
      var t4 = e4("base64-js"), r2 = e4("ieee754");
      i2.Buffer = s2, i2.SlowBuffer = g, i2.INSPECT_MAX_BYTES = 50;
      var n2 = 2147483647;
      function a2() {
        try {
          var e5 = new Uint8Array(1);
          return e5.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
            return 42;
          } }, 42 === e5.foo();
        } catch (e6) {
          return false;
        }
      }
      function o2(e5) {
        if (e5 > n2)
          throw new RangeError('The value "' + e5 + '" is invalid for option "size"');
        var t5 = new Uint8Array(e5);
        return t5.__proto__ = s2.prototype, t5;
      }
      function s2(e5, t5, i3) {
        if ("number" == typeof e5) {
          if ("string" == typeof t5)
            throw new TypeError('The "string" argument must be of type string. Received type number');
          return c2(e5);
        }
        return l2(e5, t5, i3);
      }
      function l2(e5, t5, i3) {
        if ("string" == typeof e5)
          return f2(e5, t5);
        if (ArrayBuffer.isView(e5))
          return d(e5);
        if (null == e5)
          throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e5);
        if (Y2(e5, ArrayBuffer) || e5 && Y2(e5.buffer, ArrayBuffer))
          return p2(e5, t5, i3);
        if ("number" == typeof e5)
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        var r3 = e5.valueOf && e5.valueOf();
        if (null != r3 && r3 !== e5)
          return s2.from(r3, t5, i3);
        var n3 = m(e5);
        if (n3)
          return n3;
        if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e5[Symbol.toPrimitive])
          return s2.from(e5[Symbol.toPrimitive]("string"), t5, i3);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e5);
      }
      function u2(e5) {
        if ("number" != typeof e5)
          throw new TypeError('"size" argument must be of type number');
        if (e5 < 0)
          throw new RangeError('The value "' + e5 + '" is invalid for option "size"');
      }
      function h2(e5, t5, i3) {
        return u2(e5), e5 <= 0 ? o2(e5) : void 0 !== t5 ? "string" == typeof i3 ? o2(e5).fill(t5, i3) : o2(e5).fill(t5) : o2(e5);
      }
      function c2(e5) {
        return u2(e5), o2(e5 < 0 ? 0 : 0 | _2(e5));
      }
      function f2(e5, t5) {
        if ("string" == typeof t5 && "" !== t5 || (t5 = "utf8"), !s2.isEncoding(t5))
          throw new TypeError("Unknown encoding: " + t5);
        var i3 = 0 | b2(e5, t5), r3 = o2(i3), n3 = r3.write(e5, t5);
        return n3 !== i3 && (r3 = r3.slice(0, n3)), r3;
      }
      function d(e5) {
        for (var t5 = e5.length < 0 ? 0 : 0 | _2(e5.length), i3 = o2(t5), r3 = 0; r3 < t5; r3 += 1)
          i3[r3] = 255 & e5[r3];
        return i3;
      }
      function p2(e5, t5, i3) {
        if (t5 < 0 || e5.byteLength < t5)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (e5.byteLength < t5 + (i3 || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        var r3;
        return (r3 = void 0 === t5 && void 0 === i3 ? new Uint8Array(e5) : void 0 === i3 ? new Uint8Array(e5, t5) : new Uint8Array(e5, t5, i3)).__proto__ = s2.prototype, r3;
      }
      function m(e5) {
        if (s2.isBuffer(e5)) {
          var t5 = 0 | _2(e5.length), i3 = o2(t5);
          return 0 === i3.length || e5.copy(i3, 0, 0, t5), i3;
        }
        return void 0 !== e5.length ? "number" != typeof e5.length || K(e5.length) ? o2(0) : d(e5) : "Buffer" === e5.type && Array.isArray(e5.data) ? d(e5.data) : void 0;
      }
      function _2(e5) {
        if (e5 >= n2)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n2.toString(16) + " bytes");
        return 0 | e5;
      }
      function g(e5) {
        return +e5 != e5 && (e5 = 0), s2.alloc(+e5);
      }
      function b2(e5, t5) {
        if (s2.isBuffer(e5))
          return e5.length;
        if (ArrayBuffer.isView(e5) || Y2(e5, ArrayBuffer))
          return e5.byteLength;
        if ("string" != typeof e5)
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e5);
        var i3 = e5.length, r3 = arguments.length > 2 && true === arguments[2];
        if (!r3 && 0 === i3)
          return 0;
        for (var n3 = false; ; )
          switch (t5) {
            case "ascii":
            case "latin1":
            case "binary":
              return i3;
            case "utf8":
            case "utf-8":
              return H(e5).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * i3;
            case "hex":
              return i3 >>> 1;
            case "base64":
              return q(e5).length;
            default:
              if (n3)
                return r3 ? -1 : H(e5).length;
              t5 = ("" + t5).toLowerCase(), n3 = true;
          }
      }
      function y2(e5, t5, i3) {
        var r3 = false;
        if ((void 0 === t5 || t5 < 0) && (t5 = 0), t5 > this.length)
          return "";
        if ((void 0 === i3 || i3 > this.length) && (i3 = this.length), i3 <= 0)
          return "";
        if ((i3 >>>= 0) <= (t5 >>>= 0))
          return "";
        for (e5 || (e5 = "utf8"); ; )
          switch (e5) {
            case "hex":
              return F(this, t5, i3);
            case "utf8":
            case "utf-8":
              return P(this, t5, i3);
            case "ascii":
              return R2(this, t5, i3);
            case "latin1":
            case "binary":
              return z2(this, t5, i3);
            case "base64":
              return T2(this, t5, i3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return N2(this, t5, i3);
            default:
              if (r3)
                throw new TypeError("Unknown encoding: " + e5);
              e5 = (e5 + "").toLowerCase(), r3 = true;
          }
      }
      function w(e5, t5, i3) {
        var r3 = e5[t5];
        e5[t5] = e5[i3], e5[i3] = r3;
      }
      function v2(e5, t5, i3, r3, n3) {
        if (0 === e5.length)
          return -1;
        if ("string" == typeof i3 ? (r3 = i3, i3 = 0) : i3 > 2147483647 ? i3 = 2147483647 : i3 < -2147483648 && (i3 = -2147483648), K(i3 = +i3) && (i3 = n3 ? 0 : e5.length - 1), i3 < 0 && (i3 = e5.length + i3), i3 >= e5.length) {
          if (n3)
            return -1;
          i3 = e5.length - 1;
        } else if (i3 < 0) {
          if (!n3)
            return -1;
          i3 = 0;
        }
        if ("string" == typeof t5 && (t5 = s2.from(t5, r3)), s2.isBuffer(t5))
          return 0 === t5.length ? -1 : x2(e5, t5, i3, r3, n3);
        if ("number" == typeof t5)
          return t5 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n3 ? Uint8Array.prototype.indexOf.call(e5, t5, i3) : Uint8Array.prototype.lastIndexOf.call(e5, t5, i3) : x2(e5, [t5], i3, r3, n3);
        throw new TypeError("val must be string, number or Buffer");
      }
      function x2(e5, t5, i3, r3, n3) {
        var a3, o3 = 1, s3 = e5.length, l3 = t5.length;
        if (void 0 !== r3 && ("ucs2" === (r3 = String(r3).toLowerCase()) || "ucs-2" === r3 || "utf16le" === r3 || "utf-16le" === r3)) {
          if (e5.length < 2 || t5.length < 2)
            return -1;
          o3 = 2, s3 /= 2, l3 /= 2, i3 /= 2;
        }
        function u3(e6, t6) {
          return 1 === o3 ? e6[t6] : e6.readUInt16BE(t6 * o3);
        }
        if (n3) {
          var h3 = -1;
          for (a3 = i3; a3 < s3; a3++)
            if (u3(e5, a3) === u3(t5, -1 === h3 ? 0 : a3 - h3)) {
              if (-1 === h3 && (h3 = a3), a3 - h3 + 1 === l3)
                return h3 * o3;
            } else
              -1 !== h3 && (a3 -= a3 - h3), h3 = -1;
        } else
          for (i3 + l3 > s3 && (i3 = s3 - l3), a3 = i3; a3 >= 0; a3--) {
            for (var c3 = true, f3 = 0; f3 < l3; f3++)
              if (u3(e5, a3 + f3) !== u3(t5, f3)) {
                c3 = false;
                break;
              }
            if (c3)
              return a3;
          }
        return -1;
      }
      function E2(e5, t5, i3, r3) {
        i3 = Number(i3) || 0;
        var n3 = e5.length - i3;
        r3 ? (r3 = Number(r3)) > n3 && (r3 = n3) : r3 = n3;
        var a3 = t5.length;
        r3 > a3 / 2 && (r3 = a3 / 2);
        for (var o3 = 0; o3 < r3; ++o3) {
          var s3 = parseInt(t5.substr(2 * o3, 2), 16);
          if (K(s3))
            return o3;
          e5[i3 + o3] = s3;
        }
        return o3;
      }
      function k2(e5, t5, i3, r3) {
        return V(H(t5, e5.length - i3), e5, i3, r3);
      }
      function S2(e5, t5, i3, r3) {
        return V(Q(t5), e5, i3, r3);
      }
      function A2(e5, t5, i3, r3) {
        return S2(e5, t5, i3, r3);
      }
      function I(e5, t5, i3, r3) {
        return V(q(t5), e5, i3, r3);
      }
      function M2(e5, t5, i3, r3) {
        return V(W(t5, e5.length - i3), e5, i3, r3);
      }
      function T2(e5, i3, r3) {
        return 0 === i3 && r3 === e5.length ? t4.fromByteArray(e5) : t4.fromByteArray(e5.slice(i3, r3));
      }
      function P(e5, t5, i3) {
        i3 = Math.min(e5.length, i3);
        for (var r3 = [], n3 = t5; n3 < i3; ) {
          var a3, o3, s3, l3, u3 = e5[n3], h3 = null, c3 = u3 > 239 ? 4 : u3 > 223 ? 3 : u3 > 191 ? 2 : 1;
          if (n3 + c3 <= i3)
            switch (c3) {
              case 1:
                u3 < 128 && (h3 = u3);
                break;
              case 2:
                128 == (192 & (a3 = e5[n3 + 1])) && (l3 = (31 & u3) << 6 | 63 & a3) > 127 && (h3 = l3);
                break;
              case 3:
                a3 = e5[n3 + 1], o3 = e5[n3 + 2], 128 == (192 & a3) && 128 == (192 & o3) && (l3 = (15 & u3) << 12 | (63 & a3) << 6 | 63 & o3) > 2047 && (l3 < 55296 || l3 > 57343) && (h3 = l3);
                break;
              case 4:
                a3 = e5[n3 + 1], o3 = e5[n3 + 2], s3 = e5[n3 + 3], 128 == (192 & a3) && 128 == (192 & o3) && 128 == (192 & s3) && (l3 = (15 & u3) << 18 | (63 & a3) << 12 | (63 & o3) << 6 | 63 & s3) > 65535 && l3 < 1114112 && (h3 = l3);
            }
          null === h3 ? (h3 = 65533, c3 = 1) : h3 > 65535 && (h3 -= 65536, r3.push(h3 >>> 10 & 1023 | 55296), h3 = 56320 | 1023 & h3), r3.push(h3), n3 += c3;
        }
        return C2(r3);
      }
      i2.kMaxLength = n2, s2.TYPED_ARRAY_SUPPORT = a2(), s2.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s2.prototype, "parent", { enumerable: true, get: function() {
        if (s2.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(s2.prototype, "offset", { enumerable: true, get: function() {
        if (s2.isBuffer(this))
          return this.byteOffset;
      } }), "undefined" != typeof Symbol && null != Symbol.species && s2[Symbol.species] === s2 && Object.defineProperty(s2, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s2.poolSize = 8192, s2.from = function(e5, t5, i3) {
        return l2(e5, t5, i3);
      }, s2.prototype.__proto__ = Uint8Array.prototype, s2.__proto__ = Uint8Array, s2.alloc = function(e5, t5, i3) {
        return h2(e5, t5, i3);
      }, s2.allocUnsafe = function(e5) {
        return c2(e5);
      }, s2.allocUnsafeSlow = function(e5) {
        return c2(e5);
      }, s2.isBuffer = function(e5) {
        return null != e5 && true === e5._isBuffer && e5 !== s2.prototype;
      }, s2.compare = function(e5, t5) {
        if (Y2(e5, Uint8Array) && (e5 = s2.from(e5, e5.offset, e5.byteLength)), Y2(t5, Uint8Array) && (t5 = s2.from(t5, t5.offset, t5.byteLength)), !s2.isBuffer(e5) || !s2.isBuffer(t5))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (e5 === t5)
          return 0;
        for (var i3 = e5.length, r3 = t5.length, n3 = 0, a3 = Math.min(i3, r3); n3 < a3; ++n3)
          if (e5[n3] !== t5[n3]) {
            i3 = e5[n3], r3 = t5[n3];
            break;
          }
        return i3 < r3 ? -1 : r3 < i3 ? 1 : 0;
      }, s2.isEncoding = function(e5) {
        switch (String(e5).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, s2.concat = function(e5, t5) {
        if (!Array.isArray(e5))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === e5.length)
          return s2.alloc(0);
        var i3;
        if (void 0 === t5)
          for (t5 = 0, i3 = 0; i3 < e5.length; ++i3)
            t5 += e5[i3].length;
        var r3 = s2.allocUnsafe(t5), n3 = 0;
        for (i3 = 0; i3 < e5.length; ++i3) {
          var a3 = e5[i3];
          if (Y2(a3, Uint8Array) && (a3 = s2.from(a3)), !s2.isBuffer(a3))
            throw new TypeError('"list" argument must be an Array of Buffers');
          a3.copy(r3, n3), n3 += a3.length;
        }
        return r3;
      }, s2.byteLength = b2, s2.prototype._isBuffer = true, s2.prototype.swap16 = function() {
        var e5 = this.length;
        if (e5 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t5 = 0; t5 < e5; t5 += 2)
          w(this, t5, t5 + 1);
        return this;
      }, s2.prototype.swap32 = function() {
        var e5 = this.length;
        if (e5 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t5 = 0; t5 < e5; t5 += 4)
          w(this, t5, t5 + 3), w(this, t5 + 1, t5 + 2);
        return this;
      }, s2.prototype.swap64 = function() {
        var e5 = this.length;
        if (e5 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t5 = 0; t5 < e5; t5 += 8)
          w(this, t5, t5 + 7), w(this, t5 + 1, t5 + 6), w(this, t5 + 2, t5 + 5), w(this, t5 + 3, t5 + 4);
        return this;
      }, s2.prototype.toString = function() {
        var e5 = this.length;
        return 0 === e5 ? "" : 0 === arguments.length ? P(this, 0, e5) : y2.apply(this, arguments);
      }, s2.prototype.toLocaleString = s2.prototype.toString, s2.prototype.equals = function(e5) {
        if (!s2.isBuffer(e5))
          throw new TypeError("Argument must be a Buffer");
        return this === e5 || 0 === s2.compare(this, e5);
      }, s2.prototype.inspect = function() {
        var e5 = "", t5 = i2.INSPECT_MAX_BYTES;
        return e5 = this.toString("hex", 0, t5).replace(/(.{2})/g, "$1 ").trim(), this.length > t5 && (e5 += " ... "), "<Buffer " + e5 + ">";
      }, s2.prototype.compare = function(e5, t5, i3, r3, n3) {
        if (Y2(e5, Uint8Array) && (e5 = s2.from(e5, e5.offset, e5.byteLength)), !s2.isBuffer(e5))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e5);
        if (void 0 === t5 && (t5 = 0), void 0 === i3 && (i3 = e5 ? e5.length : 0), void 0 === r3 && (r3 = 0), void 0 === n3 && (n3 = this.length), t5 < 0 || i3 > e5.length || r3 < 0 || n3 > this.length)
          throw new RangeError("out of range index");
        if (r3 >= n3 && t5 >= i3)
          return 0;
        if (r3 >= n3)
          return -1;
        if (t5 >= i3)
          return 1;
        if (this === e5)
          return 0;
        for (var a3 = (n3 >>>= 0) - (r3 >>>= 0), o3 = (i3 >>>= 0) - (t5 >>>= 0), l3 = Math.min(a3, o3), u3 = this.slice(r3, n3), h3 = e5.slice(t5, i3), c3 = 0; c3 < l3; ++c3)
          if (u3[c3] !== h3[c3]) {
            a3 = u3[c3], o3 = h3[c3];
            break;
          }
        return a3 < o3 ? -1 : o3 < a3 ? 1 : 0;
      }, s2.prototype.includes = function(e5, t5, i3) {
        return -1 !== this.indexOf(e5, t5, i3);
      }, s2.prototype.indexOf = function(e5, t5, i3) {
        return v2(this, e5, t5, i3, true);
      }, s2.prototype.lastIndexOf = function(e5, t5, i3) {
        return v2(this, e5, t5, i3, false);
      }, s2.prototype.write = function(e5, t5, i3, r3) {
        if (void 0 === t5)
          r3 = "utf8", i3 = this.length, t5 = 0;
        else if (void 0 === i3 && "string" == typeof t5)
          r3 = t5, i3 = this.length, t5 = 0;
        else {
          if (!isFinite(t5))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          t5 >>>= 0, isFinite(i3) ? (i3 >>>= 0, void 0 === r3 && (r3 = "utf8")) : (r3 = i3, i3 = void 0);
        }
        var n3 = this.length - t5;
        if ((void 0 === i3 || i3 > n3) && (i3 = n3), e5.length > 0 && (i3 < 0 || t5 < 0) || t5 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        r3 || (r3 = "utf8");
        for (var a3 = false; ; )
          switch (r3) {
            case "hex":
              return E2(this, e5, t5, i3);
            case "utf8":
            case "utf-8":
              return k2(this, e5, t5, i3);
            case "ascii":
              return S2(this, e5, t5, i3);
            case "latin1":
            case "binary":
              return A2(this, e5, t5, i3);
            case "base64":
              return I(this, e5, t5, i3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return M2(this, e5, t5, i3);
            default:
              if (a3)
                throw new TypeError("Unknown encoding: " + r3);
              r3 = ("" + r3).toLowerCase(), a3 = true;
          }
      }, s2.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var B2 = 4096;
      function C2(e5) {
        var t5 = e5.length;
        if (t5 <= B2)
          return String.fromCharCode.apply(String, e5);
        for (var i3 = "", r3 = 0; r3 < t5; )
          i3 += String.fromCharCode.apply(String, e5.slice(r3, r3 += B2));
        return i3;
      }
      function R2(e5, t5, i3) {
        var r3 = "";
        i3 = Math.min(e5.length, i3);
        for (var n3 = t5; n3 < i3; ++n3)
          r3 += String.fromCharCode(127 & e5[n3]);
        return r3;
      }
      function z2(e5, t5, i3) {
        var r3 = "";
        i3 = Math.min(e5.length, i3);
        for (var n3 = t5; n3 < i3; ++n3)
          r3 += String.fromCharCode(e5[n3]);
        return r3;
      }
      function F(e5, t5, i3) {
        var r3 = e5.length;
        (!t5 || t5 < 0) && (t5 = 0), (!i3 || i3 < 0 || i3 > r3) && (i3 = r3);
        for (var n3 = "", a3 = t5; a3 < i3; ++a3)
          n3 += G(e5[a3]);
        return n3;
      }
      function N2(e5, t5, i3) {
        for (var r3 = e5.slice(t5, i3), n3 = "", a3 = 0; a3 < r3.length; a3 += 2)
          n3 += String.fromCharCode(r3[a3] + 256 * r3[a3 + 1]);
        return n3;
      }
      function O2(e5, t5, i3) {
        if (e5 % 1 != 0 || e5 < 0)
          throw new RangeError("offset is not uint");
        if (e5 + t5 > i3)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function D(e5, t5, i3, r3, n3, a3) {
        if (!s2.isBuffer(e5))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t5 > n3 || t5 < a3)
          throw new RangeError('"value" argument is out of bounds');
        if (i3 + r3 > e5.length)
          throw new RangeError("Index out of range");
      }
      function $(e5, t5, i3, r3, n3, a3) {
        if (i3 + r3 > e5.length)
          throw new RangeError("Index out of range");
        if (i3 < 0)
          throw new RangeError("Index out of range");
      }
      function L2(e5, t5, i3, n3, a3) {
        return t5 = +t5, i3 >>>= 0, a3 || $(e5, t5, i3, 4), r2.write(e5, t5, i3, n3, 23, 4), i3 + 4;
      }
      function U(e5, t5, i3, n3, a3) {
        return t5 = +t5, i3 >>>= 0, a3 || $(e5, t5, i3, 8), r2.write(e5, t5, i3, n3, 52, 8), i3 + 8;
      }
      s2.prototype.slice = function(e5, t5) {
        var i3 = this.length;
        (e5 = ~~e5) < 0 ? (e5 += i3) < 0 && (e5 = 0) : e5 > i3 && (e5 = i3), (t5 = void 0 === t5 ? i3 : ~~t5) < 0 ? (t5 += i3) < 0 && (t5 = 0) : t5 > i3 && (t5 = i3), t5 < e5 && (t5 = e5);
        var r3 = this.subarray(e5, t5);
        return r3.__proto__ = s2.prototype, r3;
      }, s2.prototype.readUIntLE = function(e5, t5, i3) {
        e5 >>>= 0, t5 >>>= 0, i3 || O2(e5, t5, this.length);
        for (var r3 = this[e5], n3 = 1, a3 = 0; ++a3 < t5 && (n3 *= 256); )
          r3 += this[e5 + a3] * n3;
        return r3;
      }, s2.prototype.readUIntBE = function(e5, t5, i3) {
        e5 >>>= 0, t5 >>>= 0, i3 || O2(e5, t5, this.length);
        for (var r3 = this[e5 + --t5], n3 = 1; t5 > 0 && (n3 *= 256); )
          r3 += this[e5 + --t5] * n3;
        return r3;
      }, s2.prototype.readUInt8 = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 1, this.length), this[e5];
      }, s2.prototype.readUInt16LE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 2, this.length), this[e5] | this[e5 + 1] << 8;
      }, s2.prototype.readUInt16BE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 2, this.length), this[e5] << 8 | this[e5 + 1];
      }, s2.prototype.readUInt32LE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 4, this.length), (this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16) + 16777216 * this[e5 + 3];
      }, s2.prototype.readUInt32BE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 4, this.length), 16777216 * this[e5] + (this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3]);
      }, s2.prototype.readIntLE = function(e5, t5, i3) {
        e5 >>>= 0, t5 >>>= 0, i3 || O2(e5, t5, this.length);
        for (var r3 = this[e5], n3 = 1, a3 = 0; ++a3 < t5 && (n3 *= 256); )
          r3 += this[e5 + a3] * n3;
        return r3 >= (n3 *= 128) && (r3 -= Math.pow(2, 8 * t5)), r3;
      }, s2.prototype.readIntBE = function(e5, t5, i3) {
        e5 >>>= 0, t5 >>>= 0, i3 || O2(e5, t5, this.length);
        for (var r3 = t5, n3 = 1, a3 = this[e5 + --r3]; r3 > 0 && (n3 *= 256); )
          a3 += this[e5 + --r3] * n3;
        return a3 >= (n3 *= 128) && (a3 -= Math.pow(2, 8 * t5)), a3;
      }, s2.prototype.readInt8 = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 1, this.length), 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
      }, s2.prototype.readInt16LE = function(e5, t5) {
        e5 >>>= 0, t5 || O2(e5, 2, this.length);
        var i3 = this[e5] | this[e5 + 1] << 8;
        return 32768 & i3 ? 4294901760 | i3 : i3;
      }, s2.prototype.readInt16BE = function(e5, t5) {
        e5 >>>= 0, t5 || O2(e5, 2, this.length);
        var i3 = this[e5 + 1] | this[e5] << 8;
        return 32768 & i3 ? 4294901760 | i3 : i3;
      }, s2.prototype.readInt32LE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 4, this.length), this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16 | this[e5 + 3] << 24;
      }, s2.prototype.readInt32BE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 4, this.length), this[e5] << 24 | this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3];
      }, s2.prototype.readFloatLE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 4, this.length), r2.read(this, e5, true, 23, 4);
      }, s2.prototype.readFloatBE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 4, this.length), r2.read(this, e5, false, 23, 4);
      }, s2.prototype.readDoubleLE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 8, this.length), r2.read(this, e5, true, 52, 8);
      }, s2.prototype.readDoubleBE = function(e5, t5) {
        return e5 >>>= 0, t5 || O2(e5, 8, this.length), r2.read(this, e5, false, 52, 8);
      }, s2.prototype.writeUIntLE = function(e5, t5, i3, r3) {
        e5 = +e5, t5 >>>= 0, i3 >>>= 0, r3 || D(this, e5, t5, i3, Math.pow(2, 8 * i3) - 1, 0);
        var n3 = 1, a3 = 0;
        for (this[t5] = 255 & e5; ++a3 < i3 && (n3 *= 256); )
          this[t5 + a3] = e5 / n3 & 255;
        return t5 + i3;
      }, s2.prototype.writeUIntBE = function(e5, t5, i3, r3) {
        e5 = +e5, t5 >>>= 0, i3 >>>= 0, r3 || D(this, e5, t5, i3, Math.pow(2, 8 * i3) - 1, 0);
        var n3 = i3 - 1, a3 = 1;
        for (this[t5 + n3] = 255 & e5; --n3 >= 0 && (a3 *= 256); )
          this[t5 + n3] = e5 / a3 & 255;
        return t5 + i3;
      }, s2.prototype.writeUInt8 = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 1, 255, 0), this[t5] = 255 & e5, t5 + 1;
      }, s2.prototype.writeUInt16LE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 2, 65535, 0), this[t5] = 255 & e5, this[t5 + 1] = e5 >>> 8, t5 + 2;
      }, s2.prototype.writeUInt16BE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 2, 65535, 0), this[t5] = e5 >>> 8, this[t5 + 1] = 255 & e5, t5 + 2;
      }, s2.prototype.writeUInt32LE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 4, 4294967295, 0), this[t5 + 3] = e5 >>> 24, this[t5 + 2] = e5 >>> 16, this[t5 + 1] = e5 >>> 8, this[t5] = 255 & e5, t5 + 4;
      }, s2.prototype.writeUInt32BE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 4, 4294967295, 0), this[t5] = e5 >>> 24, this[t5 + 1] = e5 >>> 16, this[t5 + 2] = e5 >>> 8, this[t5 + 3] = 255 & e5, t5 + 4;
      }, s2.prototype.writeIntLE = function(e5, t5, i3, r3) {
        if (e5 = +e5, t5 >>>= 0, !r3) {
          var n3 = Math.pow(2, 8 * i3 - 1);
          D(this, e5, t5, i3, n3 - 1, -n3);
        }
        var a3 = 0, o3 = 1, s3 = 0;
        for (this[t5] = 255 & e5; ++a3 < i3 && (o3 *= 256); )
          e5 < 0 && 0 === s3 && 0 !== this[t5 + a3 - 1] && (s3 = 1), this[t5 + a3] = (e5 / o3 | 0) - s3 & 255;
        return t5 + i3;
      }, s2.prototype.writeIntBE = function(e5, t5, i3, r3) {
        if (e5 = +e5, t5 >>>= 0, !r3) {
          var n3 = Math.pow(2, 8 * i3 - 1);
          D(this, e5, t5, i3, n3 - 1, -n3);
        }
        var a3 = i3 - 1, o3 = 1, s3 = 0;
        for (this[t5 + a3] = 255 & e5; --a3 >= 0 && (o3 *= 256); )
          e5 < 0 && 0 === s3 && 0 !== this[t5 + a3 + 1] && (s3 = 1), this[t5 + a3] = (e5 / o3 | 0) - s3 & 255;
        return t5 + i3;
      }, s2.prototype.writeInt8 = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 1, 127, -128), e5 < 0 && (e5 = 255 + e5 + 1), this[t5] = 255 & e5, t5 + 1;
      }, s2.prototype.writeInt16LE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 2, 32767, -32768), this[t5] = 255 & e5, this[t5 + 1] = e5 >>> 8, t5 + 2;
      }, s2.prototype.writeInt16BE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 2, 32767, -32768), this[t5] = e5 >>> 8, this[t5 + 1] = 255 & e5, t5 + 2;
      }, s2.prototype.writeInt32LE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 4, 2147483647, -2147483648), this[t5] = 255 & e5, this[t5 + 1] = e5 >>> 8, this[t5 + 2] = e5 >>> 16, this[t5 + 3] = e5 >>> 24, t5 + 4;
      }, s2.prototype.writeInt32BE = function(e5, t5, i3) {
        return e5 = +e5, t5 >>>= 0, i3 || D(this, e5, t5, 4, 2147483647, -2147483648), e5 < 0 && (e5 = 4294967295 + e5 + 1), this[t5] = e5 >>> 24, this[t5 + 1] = e5 >>> 16, this[t5 + 2] = e5 >>> 8, this[t5 + 3] = 255 & e5, t5 + 4;
      }, s2.prototype.writeFloatLE = function(e5, t5, i3) {
        return L2(this, e5, t5, true, i3);
      }, s2.prototype.writeFloatBE = function(e5, t5, i3) {
        return L2(this, e5, t5, false, i3);
      }, s2.prototype.writeDoubleLE = function(e5, t5, i3) {
        return U(this, e5, t5, true, i3);
      }, s2.prototype.writeDoubleBE = function(e5, t5, i3) {
        return U(this, e5, t5, false, i3);
      }, s2.prototype.copy = function(e5, t5, i3, r3) {
        if (!s2.isBuffer(e5))
          throw new TypeError("argument should be a Buffer");
        if (i3 || (i3 = 0), r3 || 0 === r3 || (r3 = this.length), t5 >= e5.length && (t5 = e5.length), t5 || (t5 = 0), r3 > 0 && r3 < i3 && (r3 = i3), r3 === i3)
          return 0;
        if (0 === e5.length || 0 === this.length)
          return 0;
        if (t5 < 0)
          throw new RangeError("targetStart out of bounds");
        if (i3 < 0 || i3 >= this.length)
          throw new RangeError("Index out of range");
        if (r3 < 0)
          throw new RangeError("sourceEnd out of bounds");
        r3 > this.length && (r3 = this.length), e5.length - t5 < r3 - i3 && (r3 = e5.length - t5 + i3);
        var n3 = r3 - i3;
        if (this === e5 && "function" == typeof Uint8Array.prototype.copyWithin)
          this.copyWithin(t5, i3, r3);
        else if (this === e5 && i3 < t5 && t5 < r3)
          for (var a3 = n3 - 1; a3 >= 0; --a3)
            e5[a3 + t5] = this[a3 + i3];
        else
          Uint8Array.prototype.set.call(e5, this.subarray(i3, r3), t5);
        return n3;
      }, s2.prototype.fill = function(e5, t5, i3, r3) {
        if ("string" == typeof e5) {
          if ("string" == typeof t5 ? (r3 = t5, t5 = 0, i3 = this.length) : "string" == typeof i3 && (r3 = i3, i3 = this.length), void 0 !== r3 && "string" != typeof r3)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof r3 && !s2.isEncoding(r3))
            throw new TypeError("Unknown encoding: " + r3);
          if (1 === e5.length) {
            var n3 = e5.charCodeAt(0);
            ("utf8" === r3 && n3 < 128 || "latin1" === r3) && (e5 = n3);
          }
        } else
          "number" == typeof e5 && (e5 &= 255);
        if (t5 < 0 || this.length < t5 || this.length < i3)
          throw new RangeError("Out of range index");
        if (i3 <= t5)
          return this;
        var a3;
        if (t5 >>>= 0, i3 = void 0 === i3 ? this.length : i3 >>> 0, e5 || (e5 = 0), "number" == typeof e5)
          for (a3 = t5; a3 < i3; ++a3)
            this[a3] = e5;
        else {
          var o3 = s2.isBuffer(e5) ? e5 : s2.from(e5, r3), l3 = o3.length;
          if (0 === l3)
            throw new TypeError('The value "' + e5 + '" is invalid for argument "value"');
          for (a3 = 0; a3 < i3 - t5; ++a3)
            this[a3 + t5] = o3[a3 % l3];
        }
        return this;
      };
      var Z = /[^+/0-9A-Za-z-_]/g;
      function j(e5) {
        if ((e5 = (e5 = e5.split("=")[0]).trim().replace(Z, "")).length < 2)
          return "";
        for (; e5.length % 4 != 0; )
          e5 += "=";
        return e5;
      }
      function G(e5) {
        return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
      }
      function H(e5, t5) {
        var i3;
        t5 = t5 || 1 / 0;
        for (var r3 = e5.length, n3 = null, a3 = [], o3 = 0; o3 < r3; ++o3) {
          if ((i3 = e5.charCodeAt(o3)) > 55295 && i3 < 57344) {
            if (!n3) {
              if (i3 > 56319) {
                (t5 -= 3) > -1 && a3.push(239, 191, 189);
                continue;
              }
              if (o3 + 1 === r3) {
                (t5 -= 3) > -1 && a3.push(239, 191, 189);
                continue;
              }
              n3 = i3;
              continue;
            }
            if (i3 < 56320) {
              (t5 -= 3) > -1 && a3.push(239, 191, 189), n3 = i3;
              continue;
            }
            i3 = 65536 + (n3 - 55296 << 10 | i3 - 56320);
          } else
            n3 && (t5 -= 3) > -1 && a3.push(239, 191, 189);
          if (n3 = null, i3 < 128) {
            if ((t5 -= 1) < 0)
              break;
            a3.push(i3);
          } else if (i3 < 2048) {
            if ((t5 -= 2) < 0)
              break;
            a3.push(i3 >> 6 | 192, 63 & i3 | 128);
          } else if (i3 < 65536) {
            if ((t5 -= 3) < 0)
              break;
            a3.push(i3 >> 12 | 224, i3 >> 6 & 63 | 128, 63 & i3 | 128);
          } else {
            if (!(i3 < 1114112))
              throw new Error("Invalid code point");
            if ((t5 -= 4) < 0)
              break;
            a3.push(i3 >> 18 | 240, i3 >> 12 & 63 | 128, i3 >> 6 & 63 | 128, 63 & i3 | 128);
          }
        }
        return a3;
      }
      function Q(e5) {
        for (var t5 = [], i3 = 0; i3 < e5.length; ++i3)
          t5.push(255 & e5.charCodeAt(i3));
        return t5;
      }
      function W(e5, t5) {
        for (var i3, r3, n3, a3 = [], o3 = 0; o3 < e5.length && !((t5 -= 2) < 0); ++o3)
          r3 = (i3 = e5.charCodeAt(o3)) >> 8, n3 = i3 % 256, a3.push(n3), a3.push(r3);
        return a3;
      }
      function q(e5) {
        return t4.toByteArray(j(e5));
      }
      function V(e5, t5, i3, r3) {
        for (var n3 = 0; n3 < r3 && !(n3 + i3 >= t5.length || n3 >= e5.length); ++n3)
          t5[n3 + i3] = e5[n3];
        return n3;
      }
      function Y2(e5, t5) {
        return e5 instanceof t5 || null != e5 && null != e5.constructor && null != e5.constructor.name && e5.constructor.name === t5.name;
      }
      function K(e5) {
        return e5 != e5;
      }
    }).call(this);
  }).call(this, e4("buffer").Buffer);
}, { "base64-js": 28, buffer: 32, ieee754: 45 }], 33: [function(e4, t2, i2) {
  var r2 = e4("get-intrinsic"), n2 = e4("./"), a2 = n2(r2("String.prototype.indexOf"));
  t2.exports = function(e5, t3) {
    var i3 = r2(e5, !!t3);
    return "function" == typeof i3 && a2(e5, ".prototype.") > -1 ? n2(i3) : i3;
  };
}, { "./": 34, "get-intrinsic": 39 }], 34: [function(e4, t2, i2) {
  var r2 = e4("function-bind"), n2 = e4("get-intrinsic"), a2 = n2("%Function.prototype.apply%"), o2 = n2("%Function.prototype.call%"), s2 = n2("%Reflect.apply%", true) || r2.call(o2, a2), l2 = n2("%Object.getOwnPropertyDescriptor%", true), u2 = n2("%Object.defineProperty%", true), h2 = n2("%Math.max%");
  if (u2)
    try {
      u2({}, "a", { value: 1 });
    } catch (e5) {
      u2 = null;
    }
  t2.exports = function(e5) {
    var t3 = s2(r2, o2, arguments);
    return l2 && u2 && l2(t3, "length").configurable && u2(t3, "length", { value: 1 + h2(0, e5.length - (arguments.length - 1)) }), t3;
  };
  var c2 = function() {
    return s2(r2, a2, arguments);
  };
  u2 ? u2(t2.exports, "apply", { value: c2 }) : t2.exports.apply = c2;
}, { "function-bind": 38, "get-intrinsic": 39 }], 35: [function(e4, t2, i2) {
  var r2, n2 = "object" == typeof Reflect ? Reflect : null, a2 = n2 && "function" == typeof n2.apply ? n2.apply : function(e5, t3, i3) {
    return Function.prototype.apply.call(e5, t3, i3);
  };
  function o2(e5) {
    console && console.warn && console.warn(e5);
  }
  r2 = n2 && "function" == typeof n2.ownKeys ? n2.ownKeys : Object.getOwnPropertySymbols ? function(e5) {
    return Object.getOwnPropertyNames(e5).concat(Object.getOwnPropertySymbols(e5));
  } : function(e5) {
    return Object.getOwnPropertyNames(e5);
  };
  var s2 = Number.isNaN || function(e5) {
    return e5 != e5;
  };
  function l2() {
    l2.init.call(this);
  }
  t2.exports = l2, t2.exports.once = w, l2.EventEmitter = l2, l2.prototype._events = void 0, l2.prototype._eventsCount = 0, l2.prototype._maxListeners = void 0;
  var u2 = 10;
  function h2(e5) {
    if ("function" != typeof e5)
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e5);
  }
  function c2(e5) {
    return void 0 === e5._maxListeners ? l2.defaultMaxListeners : e5._maxListeners;
  }
  function f2(e5, t3, i3, r3) {
    var n3, a3, s3;
    if (h2(i3), void 0 === (a3 = e5._events) ? (a3 = e5._events = /* @__PURE__ */ Object.create(null), e5._eventsCount = 0) : (void 0 !== a3.newListener && (e5.emit("newListener", t3, i3.listener ? i3.listener : i3), a3 = e5._events), s3 = a3[t3]), void 0 === s3)
      s3 = a3[t3] = i3, ++e5._eventsCount;
    else if ("function" == typeof s3 ? s3 = a3[t3] = r3 ? [i3, s3] : [s3, i3] : r3 ? s3.unshift(i3) : s3.push(i3), (n3 = c2(e5)) > 0 && s3.length > n3 && !s3.warned) {
      s3.warned = true;
      var l3 = new Error("Possible EventEmitter memory leak detected. " + s3.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      l3.name = "MaxListenersExceededWarning", l3.emitter = e5, l3.type = t3, l3.count = s3.length, o2(l3);
    }
    return e5;
  }
  function d() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function p2(e5, t3, i3) {
    var r3 = { fired: false, wrapFn: void 0, target: e5, type: t3, listener: i3 }, n3 = d.bind(r3);
    return n3.listener = i3, r3.wrapFn = n3, n3;
  }
  function m(e5, t3, i3) {
    var r3 = e5._events;
    if (void 0 === r3)
      return [];
    var n3 = r3[t3];
    return void 0 === n3 ? [] : "function" == typeof n3 ? i3 ? [n3.listener || n3] : [n3] : i3 ? y2(n3) : g(n3, n3.length);
  }
  function _2(e5) {
    var t3 = this._events;
    if (void 0 !== t3) {
      var i3 = t3[e5];
      if ("function" == typeof i3)
        return 1;
      if (void 0 !== i3)
        return i3.length;
    }
    return 0;
  }
  function g(e5, t3) {
    for (var i3 = new Array(t3), r3 = 0; r3 < t3; ++r3)
      i3[r3] = e5[r3];
    return i3;
  }
  function b2(e5, t3) {
    for (; t3 + 1 < e5.length; t3++)
      e5[t3] = e5[t3 + 1];
    e5.pop();
  }
  function y2(e5) {
    for (var t3 = new Array(e5.length), i3 = 0; i3 < t3.length; ++i3)
      t3[i3] = e5[i3].listener || e5[i3];
    return t3;
  }
  function w(e5, t3) {
    return new Promise(function(i3, r3) {
      function n3(i4) {
        e5.removeListener(t3, a3), r3(i4);
      }
      function a3() {
        "function" == typeof e5.removeListener && e5.removeListener("error", n3), i3([].slice.call(arguments));
      }
      x2(e5, t3, a3, { once: true }), "error" !== t3 && v2(e5, n3, { once: true });
    });
  }
  function v2(e5, t3, i3) {
    "function" == typeof e5.on && x2(e5, "error", t3, i3);
  }
  function x2(e5, t3, i3, r3) {
    if ("function" == typeof e5.on)
      r3.once ? e5.once(t3, i3) : e5.on(t3, i3);
    else {
      if ("function" != typeof e5.addEventListener)
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e5);
      e5.addEventListener(t3, function n3(a3) {
        r3.once && e5.removeEventListener(t3, n3), i3(a3);
      });
    }
  }
  Object.defineProperty(l2, "defaultMaxListeners", { enumerable: true, get: function() {
    return u2;
  }, set: function(e5) {
    if ("number" != typeof e5 || e5 < 0 || s2(e5))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e5 + ".");
    u2 = e5;
  } }), l2.init = function() {
    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, l2.prototype.setMaxListeners = function(e5) {
    if ("number" != typeof e5 || e5 < 0 || s2(e5))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e5 + ".");
    return this._maxListeners = e5, this;
  }, l2.prototype.getMaxListeners = function() {
    return c2(this);
  }, l2.prototype.emit = function(e5) {
    for (var t3 = [], i3 = 1; i3 < arguments.length; i3++)
      t3.push(arguments[i3]);
    var r3 = "error" === e5, n3 = this._events;
    if (void 0 !== n3)
      r3 = r3 && void 0 === n3.error;
    else if (!r3)
      return false;
    if (r3) {
      var o3;
      if (t3.length > 0 && (o3 = t3[0]), o3 instanceof Error)
        throw o3;
      var s3 = new Error("Unhandled error." + (o3 ? " (" + o3.message + ")" : ""));
      throw s3.context = o3, s3;
    }
    var l3 = n3[e5];
    if (void 0 === l3)
      return false;
    if ("function" == typeof l3)
      a2(l3, this, t3);
    else {
      var u3 = l3.length, h3 = g(l3, u3);
      for (i3 = 0; i3 < u3; ++i3)
        a2(h3[i3], this, t3);
    }
    return true;
  }, l2.prototype.addListener = function(e5, t3) {
    return f2(this, e5, t3, false);
  }, l2.prototype.on = l2.prototype.addListener, l2.prototype.prependListener = function(e5, t3) {
    return f2(this, e5, t3, true);
  }, l2.prototype.once = function(e5, t3) {
    return h2(t3), this.on(e5, p2(this, e5, t3)), this;
  }, l2.prototype.prependOnceListener = function(e5, t3) {
    return h2(t3), this.prependListener(e5, p2(this, e5, t3)), this;
  }, l2.prototype.removeListener = function(e5, t3) {
    var i3, r3, n3, a3, o3;
    if (h2(t3), void 0 === (r3 = this._events))
      return this;
    if (void 0 === (i3 = r3[e5]))
      return this;
    if (i3 === t3 || i3.listener === t3)
      0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r3[e5], r3.removeListener && this.emit("removeListener", e5, i3.listener || t3));
    else if ("function" != typeof i3) {
      for (n3 = -1, a3 = i3.length - 1; a3 >= 0; a3--)
        if (i3[a3] === t3 || i3[a3].listener === t3) {
          o3 = i3[a3].listener, n3 = a3;
          break;
        }
      if (n3 < 0)
        return this;
      0 === n3 ? i3.shift() : b2(i3, n3), 1 === i3.length && (r3[e5] = i3[0]), void 0 !== r3.removeListener && this.emit("removeListener", e5, o3 || t3);
    }
    return this;
  }, l2.prototype.off = l2.prototype.removeListener, l2.prototype.removeAllListeners = function(e5) {
    var t3, i3, r3;
    if (void 0 === (i3 = this._events))
      return this;
    if (void 0 === i3.removeListener)
      return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== i3[e5] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete i3[e5]), this;
    if (0 === arguments.length) {
      var n3, a3 = Object.keys(i3);
      for (r3 = 0; r3 < a3.length; ++r3)
        "removeListener" !== (n3 = a3[r3]) && this.removeAllListeners(n3);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if ("function" == typeof (t3 = i3[e5]))
      this.removeListener(e5, t3);
    else if (void 0 !== t3)
      for (r3 = t3.length - 1; r3 >= 0; r3--)
        this.removeListener(e5, t3[r3]);
    return this;
  }, l2.prototype.listeners = function(e5) {
    return m(this, e5, true);
  }, l2.prototype.rawListeners = function(e5) {
    return m(this, e5, false);
  }, l2.listenerCount = function(e5, t3) {
    return "function" == typeof e5.listenerCount ? e5.listenerCount(t3) : _2.call(e5, t3);
  }, l2.prototype.listenerCount = _2, l2.prototype.eventNames = function() {
    return this._eventsCount > 0 ? r2(this._events) : [];
  };
}, {}], 36: [function(e4, t2, i2) {
  var r2 = e4("is-callable"), n2 = Object.prototype.toString, a2 = Object.prototype.hasOwnProperty, o2 = function(e5, t3, i3) {
    for (var r3 = 0, n3 = e5.length; r3 < n3; r3++)
      a2.call(e5, r3) && (null == i3 ? t3(e5[r3], r3, e5) : t3.call(i3, e5[r3], r3, e5));
  }, s2 = function(e5, t3, i3) {
    for (var r3 = 0, n3 = e5.length; r3 < n3; r3++)
      null == i3 ? t3(e5.charAt(r3), r3, e5) : t3.call(i3, e5.charAt(r3), r3, e5);
  }, l2 = function(e5, t3, i3) {
    for (var r3 in e5)
      a2.call(e5, r3) && (null == i3 ? t3(e5[r3], r3, e5) : t3.call(i3, e5[r3], r3, e5));
  }, u2 = function(e5, t3, i3) {
    if (!r2(t3))
      throw new TypeError("iterator must be a function");
    var a3;
    arguments.length >= 3 && (a3 = i3), "[object Array]" === n2.call(e5) ? o2(e5, t3, a3) : "string" == typeof e5 ? s2(e5, t3, a3) : l2(e5, t3, a3);
  };
  t2.exports = u2;
}, { "is-callable": 48 }], 37: [function(e4, t2, i2) {
  var r2 = "Function.prototype.bind called on incompatible ", n2 = Array.prototype.slice, a2 = Object.prototype.toString, o2 = "[object Function]";
  t2.exports = function(e5) {
    var t3 = this;
    if ("function" != typeof t3 || a2.call(t3) !== o2)
      throw new TypeError(r2 + t3);
    for (var i3, s2 = n2.call(arguments, 1), l2 = function() {
      if (this instanceof i3) {
        var r3 = t3.apply(this, s2.concat(n2.call(arguments)));
        return Object(r3) === r3 ? r3 : this;
      }
      return t3.apply(e5, s2.concat(n2.call(arguments)));
    }, u2 = Math.max(0, t3.length - s2.length), h2 = [], c2 = 0; c2 < u2; c2++)
      h2.push("$" + c2);
    if (i3 = Function("binder", "return function (" + h2.join(",") + "){ return binder.apply(this,arguments); }")(l2), t3.prototype) {
      var f2 = function() {
      };
      f2.prototype = t3.prototype, i3.prototype = new f2(), f2.prototype = null;
    }
    return i3;
  };
}, {}], 38: [function(e4, t2, i2) {
  var r2 = e4("./implementation");
  t2.exports = Function.prototype.bind || r2;
}, { "./implementation": 37 }], 39: [function(e4, t2, i2) {
  var r2, n2 = SyntaxError, a2 = Function, o2 = TypeError, s2 = function(e5) {
    try {
      return a2('"use strict"; return (' + e5 + ").constructor;")();
    } catch (e6) {
    }
  }, l2 = Object.getOwnPropertyDescriptor;
  if (l2)
    try {
      l2({}, "");
    } catch (e5) {
      l2 = null;
    }
  var u2 = function() {
    throw new o2();
  }, h2 = l2 ? function() {
    try {
      return u2;
    } catch (e5) {
      try {
        return l2(arguments, "callee").get;
      } catch (e6) {
        return u2;
      }
    }
  }() : u2, c2 = e4("has-symbols")(), f2 = Object.getPrototypeOf || function(e5) {
    return e5.__proto__;
  }, d = {}, p2 = "undefined" == typeof Uint8Array ? r2 : f2(Uint8Array), m = { "%AggregateError%": "undefined" == typeof AggregateError ? r2 : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? r2 : ArrayBuffer, "%ArrayIteratorPrototype%": c2 ? f2([][Symbol.iterator]()) : r2, "%AsyncFromSyncIteratorPrototype%": r2, "%AsyncFunction%": d, "%AsyncGenerator%": d, "%AsyncGeneratorFunction%": d, "%AsyncIteratorPrototype%": d, "%Atomics%": "undefined" == typeof Atomics ? r2 : Atomics, "%BigInt%": "undefined" == typeof BigInt ? r2 : BigInt, "%BigInt64Array%": "undefined" == typeof BigInt64Array ? r2 : BigInt64Array, "%BigUint64Array%": "undefined" == typeof BigUint64Array ? r2 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? r2 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? r2 : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? r2 : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? r2 : FinalizationRegistry, "%Function%": a2, "%GeneratorFunction%": d, "%Int8Array%": "undefined" == typeof Int8Array ? r2 : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? r2 : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? r2 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": c2 ? f2(f2([][Symbol.iterator]())) : r2, "%JSON%": "object" == typeof JSON ? JSON : r2, "%Map%": "undefined" == typeof Map ? r2 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && c2 ? f2((/* @__PURE__ */ new Map())[Symbol.iterator]()) : r2, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? r2 : Promise, "%Proxy%": "undefined" == typeof Proxy ? r2 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? r2 : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? r2 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && c2 ? f2((/* @__PURE__ */ new Set())[Symbol.iterator]()) : r2, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? r2 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": c2 ? f2(""[Symbol.iterator]()) : r2, "%Symbol%": c2 ? Symbol : r2, "%SyntaxError%": n2, "%ThrowTypeError%": h2, "%TypedArray%": p2, "%TypeError%": o2, "%Uint8Array%": "undefined" == typeof Uint8Array ? r2 : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? r2 : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? r2 : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? r2 : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? r2 : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? r2 : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? r2 : WeakSet };
  try {
    null.error;
  } catch (e5) {
    var _2 = f2(f2(e5));
    m["%Error.prototype%"] = _2;
  }
  var g = function e5(t3) {
    var i3;
    if ("%AsyncFunction%" === t3)
      i3 = s2("async function () {}");
    else if ("%GeneratorFunction%" === t3)
      i3 = s2("function* () {}");
    else if ("%AsyncGeneratorFunction%" === t3)
      i3 = s2("async function* () {}");
    else if ("%AsyncGenerator%" === t3) {
      var r3 = e5("%AsyncGeneratorFunction%");
      r3 && (i3 = r3.prototype);
    } else if ("%AsyncIteratorPrototype%" === t3) {
      var n3 = e5("%AsyncGenerator%");
      n3 && (i3 = f2(n3.prototype));
    }
    return m[t3] = i3, i3;
  }, b2 = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, y2 = e4("function-bind"), w = e4("has"), v2 = y2.call(Function.call, Array.prototype.concat), x2 = y2.call(Function.apply, Array.prototype.splice), E2 = y2.call(Function.call, String.prototype.replace), k2 = y2.call(Function.call, String.prototype.slice), S2 = y2.call(Function.call, RegExp.prototype.exec), A2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, I = /\\(\\)?/g, M2 = function(e5) {
    var t3 = k2(e5, 0, 1), i3 = k2(e5, -1);
    if ("%" === t3 && "%" !== i3)
      throw new n2("invalid intrinsic syntax, expected closing `%`");
    if ("%" === i3 && "%" !== t3)
      throw new n2("invalid intrinsic syntax, expected opening `%`");
    var r3 = [];
    return E2(e5, A2, function(e6, t4, i4, n3) {
      r3[r3.length] = i4 ? E2(n3, I, "$1") : t4 || e6;
    }), r3;
  }, T2 = function(e5, t3) {
    var i3, r3 = e5;
    if (w(b2, r3) && (r3 = "%" + (i3 = b2[r3])[0] + "%"), w(m, r3)) {
      var a3 = m[r3];
      if (a3 === d && (a3 = g(r3)), void 0 === a3 && !t3)
        throw new o2("intrinsic " + e5 + " exists, but is not available. Please file an issue!");
      return { alias: i3, name: r3, value: a3 };
    }
    throw new n2("intrinsic " + e5 + " does not exist!");
  };
  t2.exports = function(e5, t3) {
    if ("string" != typeof e5 || 0 === e5.length)
      throw new o2("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && "boolean" != typeof t3)
      throw new o2('"allowMissing" argument must be a boolean');
    if (null === S2(/^%?[^%]*%?$/, e5))
      throw new n2("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i3 = M2(e5), r3 = i3.length > 0 ? i3[0] : "", a3 = T2("%" + r3 + "%", t3), s3 = a3.name, u3 = a3.value, h3 = false, c3 = a3.alias;
    c3 && (r3 = c3[0], x2(i3, v2([0, 1], c3)));
    for (var f3 = 1, d2 = true; f3 < i3.length; f3 += 1) {
      var p3 = i3[f3], _3 = k2(p3, 0, 1), g2 = k2(p3, -1);
      if (('"' === _3 || "'" === _3 || "`" === _3 || '"' === g2 || "'" === g2 || "`" === g2) && _3 !== g2)
        throw new n2("property names with quotes must have matching quotes");
      if ("constructor" !== p3 && d2 || (h3 = true), w(m, s3 = "%" + (r3 += "." + p3) + "%"))
        u3 = m[s3];
      else if (null != u3) {
        if (!(p3 in u3)) {
          if (!t3)
            throw new o2("base intrinsic for " + e5 + " exists, but the property is not available.");
          return;
        }
        if (l2 && f3 + 1 >= i3.length) {
          var b3 = l2(u3, p3);
          u3 = (d2 = !!b3) && "get" in b3 && !("originalValue" in b3.get) ? b3.get : u3[p3];
        } else
          d2 = w(u3, p3), u3 = u3[p3];
        d2 && !h3 && (m[s3] = u3);
      }
    }
    return u3;
  };
}, { "function-bind": 38, has: 44, "has-symbols": 41 }], 40: [function(e4, t2, i2) {
  var r2 = e4("get-intrinsic")("%Object.getOwnPropertyDescriptor%", true);
  if (r2)
    try {
      r2([], "length");
    } catch (e5) {
      r2 = null;
    }
  t2.exports = r2;
}, { "get-intrinsic": 39 }], 41: [function(e4, t2, i2) {
  var r2 = "undefined" != typeof Symbol && Symbol, n2 = e4("./shams");
  t2.exports = function() {
    return "function" == typeof r2 && "function" == typeof Symbol && "symbol" == typeof r2("foo") && "symbol" == typeof Symbol("bar") && n2();
  };
}, { "./shams": 42 }], 42: [function(e4, t2, i2) {
  t2.exports = function() {
    if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
      return false;
    if ("symbol" == typeof Symbol.iterator)
      return true;
    var e5 = {}, t3 = Symbol("test"), i3 = Object(t3);
    if ("string" == typeof t3)
      return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(t3))
      return false;
    if ("[object Symbol]" !== Object.prototype.toString.call(i3))
      return false;
    var r2 = 42;
    for (t3 in e5[t3] = r2, e5)
      return false;
    if ("function" == typeof Object.keys && 0 !== Object.keys(e5).length)
      return false;
    if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e5).length)
      return false;
    var n2 = Object.getOwnPropertySymbols(e5);
    if (1 !== n2.length || n2[0] !== t3)
      return false;
    if (!Object.prototype.propertyIsEnumerable.call(e5, t3))
      return false;
    if ("function" == typeof Object.getOwnPropertyDescriptor) {
      var a2 = Object.getOwnPropertyDescriptor(e5, t3);
      if (a2.value !== r2 || true !== a2.enumerable)
        return false;
    }
    return true;
  };
}, {}], 43: [function(e4, t2, i2) {
  var r2 = e4("has-symbols/shams");
  t2.exports = function() {
    return r2() && !!Symbol.toStringTag;
  };
}, { "has-symbols/shams": 42 }], 44: [function(e4, t2, i2) {
  var r2 = e4("function-bind");
  t2.exports = r2.call(Function.call, Object.prototype.hasOwnProperty);
}, { "function-bind": 38 }], 45: [function(e4, t2, i2) {
  i2.read = function(e5, t3, i3, r2, n2) {
    var a2, o2, s2 = 8 * n2 - r2 - 1, l2 = (1 << s2) - 1, u2 = l2 >> 1, h2 = -7, c2 = i3 ? n2 - 1 : 0, f2 = i3 ? -1 : 1, d = e5[t3 + c2];
    for (c2 += f2, a2 = d & (1 << -h2) - 1, d >>= -h2, h2 += s2; h2 > 0; a2 = 256 * a2 + e5[t3 + c2], c2 += f2, h2 -= 8)
      ;
    for (o2 = a2 & (1 << -h2) - 1, a2 >>= -h2, h2 += r2; h2 > 0; o2 = 256 * o2 + e5[t3 + c2], c2 += f2, h2 -= 8)
      ;
    if (0 === a2)
      a2 = 1 - u2;
    else {
      if (a2 === l2)
        return o2 ? NaN : 1 / 0 * (d ? -1 : 1);
      o2 += Math.pow(2, r2), a2 -= u2;
    }
    return (d ? -1 : 1) * o2 * Math.pow(2, a2 - r2);
  }, i2.write = function(e5, t3, i3, r2, n2, a2) {
    var o2, s2, l2, u2 = 8 * a2 - n2 - 1, h2 = (1 << u2) - 1, c2 = h2 >> 1, f2 = 23 === n2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r2 ? 0 : a2 - 1, p2 = r2 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
    for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (s2 = isNaN(t3) ? 1 : 0, o2 = h2) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), (t3 += o2 + c2 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - c2)) * l2 >= 2 && (o2++, l2 /= 2), o2 + c2 >= h2 ? (s2 = 0, o2 = h2) : o2 + c2 >= 1 ? (s2 = (t3 * l2 - 1) * Math.pow(2, n2), o2 += c2) : (s2 = t3 * Math.pow(2, c2 - 1) * Math.pow(2, n2), o2 = 0)); n2 >= 8; e5[i3 + d] = 255 & s2, d += p2, s2 /= 256, n2 -= 8)
      ;
    for (o2 = o2 << n2 | s2, u2 += n2; u2 > 0; e5[i3 + d] = 255 & o2, d += p2, o2 /= 256, u2 -= 8)
      ;
    e5[i3 + d - p2] |= 128 * m;
  };
}, {}], 46: [function(e4, t2, i2) {
  "function" == typeof Object.create ? t2.exports = function(e5, t3) {
    t3 && (e5.super_ = t3, e5.prototype = Object.create(t3.prototype, { constructor: { value: e5, enumerable: false, writable: true, configurable: true } }));
  } : t2.exports = function(e5, t3) {
    if (t3) {
      e5.super_ = t3;
      var i3 = function() {
      };
      i3.prototype = t3.prototype, e5.prototype = new i3(), e5.prototype.constructor = e5;
    }
  };
}, {}], 47: [function(e4, t2, i2) {
  var r2 = e4("has-tostringtag/shams")(), n2 = e4("call-bind/callBound")("Object.prototype.toString"), a2 = function(e5) {
    return !(r2 && e5 && "object" == typeof e5 && Symbol.toStringTag in e5) && "[object Arguments]" === n2(e5);
  }, o2 = function(e5) {
    return !!a2(e5) || null !== e5 && "object" == typeof e5 && "number" == typeof e5.length && e5.length >= 0 && "[object Array]" !== n2(e5) && "[object Function]" === n2(e5.callee);
  }, s2 = function() {
    return a2(arguments);
  }();
  a2.isLegacyArguments = o2, t2.exports = s2 ? a2 : o2;
}, { "call-bind/callBound": 33, "has-tostringtag/shams": 43 }], 48: [function(e4, t2, i2) {
  var r2, n2, a2 = Function.prototype.toString, o2 = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
  if ("function" == typeof o2 && "function" == typeof Object.defineProperty)
    try {
      r2 = Object.defineProperty({}, "length", { get: function() {
        throw n2;
      } }), n2 = {}, o2(function() {
        throw 42;
      }, null, r2);
    } catch (e5) {
      e5 !== n2 && (o2 = null);
    }
  else
    o2 = null;
  var s2 = /^\s*class\b/, l2 = function(e5) {
    try {
      var t3 = a2.call(e5);
      return s2.test(t3);
    } catch (e6) {
      return false;
    }
  }, u2 = function(e5) {
    try {
      return !l2(e5) && (a2.call(e5), true);
    } catch (e6) {
      return false;
    }
  }, h2 = Object.prototype.toString, c2 = "[object Object]", f2 = "[object Function]", d = "[object GeneratorFunction]", p2 = "[object HTMLAllCollection]", m = "[object HTML document.all class]", _2 = "[object HTMLCollection]", g = "function" == typeof Symbol && !!Symbol.toStringTag, b2 = !(0 in [,]), y2 = function() {
    return false;
  };
  if ("object" == typeof document) {
    var w = document.all;
    h2.call(w) === h2.call(document.all) && (y2 = function(e5) {
      if ((b2 || !e5) && (void 0 === e5 || "object" == typeof e5))
        try {
          var t3 = h2.call(e5);
          return (t3 === p2 || t3 === m || t3 === _2 || t3 === c2) && null == e5("");
        } catch (e6) {
        }
      return false;
    });
  }
  t2.exports = o2 ? function(e5) {
    if (y2(e5))
      return true;
    if (!e5)
      return false;
    if ("function" != typeof e5 && "object" != typeof e5)
      return false;
    try {
      o2(e5, null, r2);
    } catch (e6) {
      if (e6 !== n2)
        return false;
    }
    return !l2(e5) && u2(e5);
  } : function(e5) {
    if (y2(e5))
      return true;
    if (!e5)
      return false;
    if ("function" != typeof e5 && "object" != typeof e5)
      return false;
    if (g)
      return u2(e5);
    if (l2(e5))
      return false;
    var t3 = h2.call(e5);
    return !(t3 !== f2 && t3 !== d && !/^\[object HTML/.test(t3)) && u2(e5);
  };
}, {}], 49: [function(e4, t2, i2) {
  var r2, n2 = Object.prototype.toString, a2 = Function.prototype.toString, o2 = /^\s*(?:function)?\*/, s2 = e4("has-tostringtag/shams")(), l2 = Object.getPrototypeOf, u2 = function() {
    if (!s2)
      return false;
    try {
      return Function("return function*() {}")();
    } catch (e5) {
    }
  };
  t2.exports = function(e5) {
    if ("function" != typeof e5)
      return false;
    if (o2.test(a2.call(e5)))
      return true;
    if (!s2)
      return "[object GeneratorFunction]" === n2.call(e5);
    if (!l2)
      return false;
    if (void 0 === r2) {
      var t3 = u2();
      r2 = !!t3 && l2(t3);
    }
    return l2(e5) === r2;
  };
}, { "has-tostringtag/shams": 43 }], 50: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      var r2 = e4("for-each"), n2 = e4("available-typed-arrays"), a2 = e4("call-bind/callBound"), o2 = a2("Object.prototype.toString"), s2 = e4("has-tostringtag/shams")(), l2 = e4("gopd"), u2 = "undefined" == typeof globalThis ? i3 : globalThis, h2 = n2(), c2 = a2("Array.prototype.indexOf", true) || function(e5, t3) {
        for (var i4 = 0; i4 < e5.length; i4 += 1)
          if (e5[i4] === t3)
            return i4;
        return -1;
      }, f2 = a2("String.prototype.slice"), d = {}, p2 = Object.getPrototypeOf;
      s2 && l2 && p2 && r2(h2, function(e5) {
        var t3 = new u2[e5]();
        if (Symbol.toStringTag in t3) {
          var i4 = p2(t3), r3 = l2(i4, Symbol.toStringTag);
          if (!r3) {
            var n3 = p2(i4);
            r3 = l2(n3, Symbol.toStringTag);
          }
          d[e5] = r3.get;
        }
      });
      var m = function(e5) {
        var t3 = false;
        return r2(d, function(i4, r3) {
          if (!t3)
            try {
              t3 = i4.call(e5) === r3;
            } catch (e6) {
            }
        }), t3;
      };
      t2.exports = function(e5) {
        if (!e5 || "object" != typeof e5)
          return false;
        if (!s2 || !(Symbol.toStringTag in e5)) {
          var t3 = f2(o2(e5), 8, -1);
          return c2(h2, t3) > -1;
        }
        return !!l2 && m(e5);
      };
    }).call(this);
  }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43 }], 51: [function(e4, t2, i2) {
  var r2 = Object.getOwnPropertySymbols, n2 = Object.prototype.hasOwnProperty, a2 = Object.prototype.propertyIsEnumerable;
  function o2(e5) {
    if (null == e5)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(e5);
  }
  function s2() {
    try {
      if (!Object.assign)
        return false;
      var e5 = new String("abc");
      if (e5[5] = "de", "5" === Object.getOwnPropertyNames(e5)[0])
        return false;
      for (var t3 = {}, i3 = 0; i3 < 10; i3++)
        t3["_" + String.fromCharCode(i3)] = i3;
      var r3 = Object.getOwnPropertyNames(t3).map(function(e6) {
        return t3[e6];
      });
      if ("0123456789" !== r3.join(""))
        return false;
      var n3 = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(e6) {
        n3[e6] = e6;
      }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n3)).join("");
    } catch (e6) {
      return false;
    }
  }
  t2.exports = s2() ? Object.assign : function(e5, t3) {
    for (var i3, s3, l2 = o2(e5), u2 = 1; u2 < arguments.length; u2++) {
      for (var h2 in i3 = Object(arguments[u2]))
        n2.call(i3, h2) && (l2[h2] = i3[h2]);
      if (r2) {
        s3 = r2(i3);
        for (var c2 = 0; c2 < s3.length; c2++)
          a2.call(i3, s3[c2]) && (l2[s3[c2]] = i3[s3[c2]]);
      }
    }
    return l2;
  };
}, {}], 52: [function(e4, t2, i2) {
  var r2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
  function n2(e5, t3) {
    return Object.prototype.hasOwnProperty.call(e5, t3);
  }
  i2.assign = function(e5) {
    for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
      var i3 = t3.shift();
      if (i3) {
        if ("object" != typeof i3)
          throw new TypeError(i3 + "must be non-object");
        for (var r3 in i3)
          n2(i3, r3) && (e5[r3] = i3[r3]);
      }
    }
    return e5;
  }, i2.shrinkBuf = function(e5, t3) {
    return e5.length === t3 ? e5 : e5.subarray ? e5.subarray(0, t3) : (e5.length = t3, e5);
  };
  var a2 = { arraySet: function(e5, t3, i3, r3, n3) {
    if (t3.subarray && e5.subarray)
      e5.set(t3.subarray(i3, i3 + r3), n3);
    else
      for (var a3 = 0; a3 < r3; a3++)
        e5[n3 + a3] = t3[i3 + a3];
  }, flattenChunks: function(e5) {
    var t3, i3, r3, n3, a3, o3;
    for (r3 = 0, t3 = 0, i3 = e5.length; t3 < i3; t3++)
      r3 += e5[t3].length;
    for (o3 = new Uint8Array(r3), n3 = 0, t3 = 0, i3 = e5.length; t3 < i3; t3++)
      a3 = e5[t3], o3.set(a3, n3), n3 += a3.length;
    return o3;
  } }, o2 = { arraySet: function(e5, t3, i3, r3, n3) {
    for (var a3 = 0; a3 < r3; a3++)
      e5[n3 + a3] = t3[i3 + a3];
  }, flattenChunks: function(e5) {
    return [].concat.apply([], e5);
  } };
  i2.setTyped = function(e5) {
    e5 ? (i2.Buf8 = Uint8Array, i2.Buf16 = Uint16Array, i2.Buf32 = Int32Array, i2.assign(i2, a2)) : (i2.Buf8 = Array, i2.Buf16 = Array, i2.Buf32 = Array, i2.assign(i2, o2));
  }, i2.setTyped(r2);
}, {}], 53: [function(e4, t2, i2) {
  function r2(e5, t3, i3, r3) {
    for (var n2 = 65535 & e5, a2 = e5 >>> 16 & 65535, o2 = 0; 0 !== i3; ) {
      i3 -= o2 = i3 > 2e3 ? 2e3 : i3;
      do {
        a2 = a2 + (n2 = n2 + t3[r3++] | 0) | 0;
      } while (--o2);
      n2 %= 65521, a2 %= 65521;
    }
    return n2 | a2 << 16;
  }
  t2.exports = r2;
}, {}], 54: [function(e4, t2, i2) {
  t2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
}, {}], 55: [function(e4, t2, i2) {
  function r2() {
    for (var e5, t3 = [], i3 = 0; i3 < 256; i3++) {
      e5 = i3;
      for (var r3 = 0; r3 < 8; r3++)
        e5 = 1 & e5 ? 3988292384 ^ e5 >>> 1 : e5 >>> 1;
      t3[i3] = e5;
    }
    return t3;
  }
  var n2 = r2();
  function a2(e5, t3, i3, r3) {
    var a3 = n2, o2 = r3 + i3;
    e5 ^= -1;
    for (var s2 = r3; s2 < o2; s2++)
      e5 = e5 >>> 8 ^ a3[255 & (e5 ^ t3[s2])];
    return ~e5;
  }
  t2.exports = a2;
}, {}], 56: [function(e4, t2, i2) {
  var r2, n2 = e4("../utils/common"), a2 = e4("./trees"), o2 = e4("./adler32"), s2 = e4("./crc32"), l2 = e4("./messages"), u2 = 0, h2 = 1, c2 = 3, f2 = 4, d = 5, p2 = 0, m = 1, _2 = -2, g = -3, b2 = -5, y2 = -1, w = 1, v2 = 2, x2 = 3, E2 = 4, k2 = 0, S2 = 2, A2 = 8, I = 9, M2 = 15, T2 = 8, P = 286, B2 = 30, C2 = 19, R2 = 2 * P + 1, z2 = 15, F = 3, N2 = 258, O2 = N2 + F + 1, D = 32, $ = 42, L2 = 69, U = 73, Z = 91, j = 103, G = 113, H = 666, Q = 1, W = 2, q = 3, V = 4, Y2 = 3;
  function K(e5, t3) {
    return e5.msg = l2[t3], t3;
  }
  function J(e5) {
    return (e5 << 1) - (e5 > 4 ? 9 : 0);
  }
  function X(e5) {
    for (var t3 = e5.length; --t3 >= 0; )
      e5[t3] = 0;
  }
  function ee(e5) {
    var t3 = e5.state, i3 = t3.pending;
    i3 > e5.avail_out && (i3 = e5.avail_out), 0 !== i3 && (n2.arraySet(e5.output, t3.pending_buf, t3.pending_out, i3, e5.next_out), e5.next_out += i3, t3.pending_out += i3, e5.total_out += i3, e5.avail_out -= i3, t3.pending -= i3, 0 === t3.pending && (t3.pending_out = 0));
  }
  function te(e5, t3) {
    a2._tr_flush_block(e5, e5.block_start >= 0 ? e5.block_start : -1, e5.strstart - e5.block_start, t3), e5.block_start = e5.strstart, ee(e5.strm);
  }
  function ie(e5, t3) {
    e5.pending_buf[e5.pending++] = t3;
  }
  function re(e5, t3) {
    e5.pending_buf[e5.pending++] = t3 >>> 8 & 255, e5.pending_buf[e5.pending++] = 255 & t3;
  }
  function ne(e5, t3, i3, r3) {
    var a3 = e5.avail_in;
    return a3 > r3 && (a3 = r3), 0 === a3 ? 0 : (e5.avail_in -= a3, n2.arraySet(t3, e5.input, e5.next_in, a3, i3), 1 === e5.state.wrap ? e5.adler = o2(e5.adler, t3, a3, i3) : 2 === e5.state.wrap && (e5.adler = s2(e5.adler, t3, a3, i3)), e5.next_in += a3, e5.total_in += a3, a3);
  }
  function ae(e5, t3) {
    var i3, r3, n3 = e5.max_chain_length, a3 = e5.strstart, o3 = e5.prev_length, s3 = e5.nice_match, l3 = e5.strstart > e5.w_size - O2 ? e5.strstart - (e5.w_size - O2) : 0, u3 = e5.window, h3 = e5.w_mask, c3 = e5.prev, f3 = e5.strstart + N2, d2 = u3[a3 + o3 - 1], p3 = u3[a3 + o3];
    e5.prev_length >= e5.good_match && (n3 >>= 2), s3 > e5.lookahead && (s3 = e5.lookahead);
    do {
      if (u3[(i3 = t3) + o3] === p3 && u3[i3 + o3 - 1] === d2 && u3[i3] === u3[a3] && u3[++i3] === u3[a3 + 1]) {
        a3 += 2, i3++;
        do {
        } while (u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && a3 < f3);
        if (r3 = N2 - (f3 - a3), a3 = f3 - N2, r3 > o3) {
          if (e5.match_start = t3, o3 = r3, r3 >= s3)
            break;
          d2 = u3[a3 + o3 - 1], p3 = u3[a3 + o3];
        }
      }
    } while ((t3 = c3[t3 & h3]) > l3 && 0 != --n3);
    return o3 <= e5.lookahead ? o3 : e5.lookahead;
  }
  function oe(e5) {
    var t3, i3, r3, a3, o3, s3 = e5.w_size;
    do {
      if (a3 = e5.window_size - e5.lookahead - e5.strstart, e5.strstart >= s3 + (s3 - O2)) {
        n2.arraySet(e5.window, e5.window, s3, s3, 0), e5.match_start -= s3, e5.strstart -= s3, e5.block_start -= s3, t3 = i3 = e5.hash_size;
        do {
          r3 = e5.head[--t3], e5.head[t3] = r3 >= s3 ? r3 - s3 : 0;
        } while (--i3);
        t3 = i3 = s3;
        do {
          r3 = e5.prev[--t3], e5.prev[t3] = r3 >= s3 ? r3 - s3 : 0;
        } while (--i3);
        a3 += s3;
      }
      if (0 === e5.strm.avail_in)
        break;
      if (i3 = ne(e5.strm, e5.window, e5.strstart + e5.lookahead, a3), e5.lookahead += i3, e5.lookahead + e5.insert >= F)
        for (o3 = e5.strstart - e5.insert, e5.ins_h = e5.window[o3], e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[o3 + 1]) & e5.hash_mask; e5.insert && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[o3 + F - 1]) & e5.hash_mask, e5.prev[o3 & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = o3, o3++, e5.insert--, !(e5.lookahead + e5.insert < F)); )
          ;
    } while (e5.lookahead < O2 && 0 !== e5.strm.avail_in);
  }
  function se(e5, t3) {
    var i3 = 65535;
    for (i3 > e5.pending_buf_size - 5 && (i3 = e5.pending_buf_size - 5); ; ) {
      if (e5.lookahead <= 1) {
        if (oe(e5), 0 === e5.lookahead && t3 === u2)
          return Q;
        if (0 === e5.lookahead)
          break;
      }
      e5.strstart += e5.lookahead, e5.lookahead = 0;
      var r3 = e5.block_start + i3;
      if ((0 === e5.strstart || e5.strstart >= r3) && (e5.lookahead = e5.strstart - r3, e5.strstart = r3, te(e5, false), 0 === e5.strm.avail_out))
        return Q;
      if (e5.strstart - e5.block_start >= e5.w_size - O2 && (te(e5, false), 0 === e5.strm.avail_out))
        return Q;
    }
    return e5.insert = 0, t3 === f2 ? (te(e5, true), 0 === e5.strm.avail_out ? q : V) : (e5.strstart > e5.block_start && (te(e5, false), e5.strm.avail_out), Q);
  }
  function le(e5, t3) {
    for (var i3, r3; ; ) {
      if (e5.lookahead < O2) {
        if (oe(e5), e5.lookahead < O2 && t3 === u2)
          return Q;
        if (0 === e5.lookahead)
          break;
      }
      if (i3 = 0, e5.lookahead >= F && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart), 0 !== i3 && e5.strstart - i3 <= e5.w_size - O2 && (e5.match_length = ae(e5, i3)), e5.match_length >= F)
        if (r3 = a2._tr_tally(e5, e5.strstart - e5.match_start, e5.match_length - F), e5.lookahead -= e5.match_length, e5.match_length <= e5.max_lazy_match && e5.lookahead >= F) {
          e5.match_length--;
          do {
            e5.strstart++, e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart;
          } while (0 != --e5.match_length);
          e5.strstart++;
        } else
          e5.strstart += e5.match_length, e5.match_length = 0, e5.ins_h = e5.window[e5.strstart], e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + 1]) & e5.hash_mask;
      else
        r3 = a2._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++;
      if (r3 && (te(e5, false), 0 === e5.strm.avail_out))
        return Q;
    }
    return e5.insert = e5.strstart < F - 1 ? e5.strstart : F - 1, t3 === f2 ? (te(e5, true), 0 === e5.strm.avail_out ? q : V) : e5.last_lit && (te(e5, false), 0 === e5.strm.avail_out) ? Q : W;
  }
  function ue(e5, t3) {
    for (var i3, r3, n3; ; ) {
      if (e5.lookahead < O2) {
        if (oe(e5), e5.lookahead < O2 && t3 === u2)
          return Q;
        if (0 === e5.lookahead)
          break;
      }
      if (i3 = 0, e5.lookahead >= F && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart), e5.prev_length = e5.match_length, e5.prev_match = e5.match_start, e5.match_length = F - 1, 0 !== i3 && e5.prev_length < e5.max_lazy_match && e5.strstart - i3 <= e5.w_size - O2 && (e5.match_length = ae(e5, i3), e5.match_length <= 5 && (e5.strategy === w || e5.match_length === F && e5.strstart - e5.match_start > 4096) && (e5.match_length = F - 1)), e5.prev_length >= F && e5.match_length <= e5.prev_length) {
        n3 = e5.strstart + e5.lookahead - F, r3 = a2._tr_tally(e5, e5.strstart - 1 - e5.prev_match, e5.prev_length - F), e5.lookahead -= e5.prev_length - 1, e5.prev_length -= 2;
        do {
          ++e5.strstart <= n3 && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + F - 1]) & e5.hash_mask, i3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart);
        } while (0 != --e5.prev_length);
        if (e5.match_available = 0, e5.match_length = F - 1, e5.strstart++, r3 && (te(e5, false), 0 === e5.strm.avail_out))
          return Q;
      } else if (e5.match_available) {
        if ((r3 = a2._tr_tally(e5, 0, e5.window[e5.strstart - 1])) && te(e5, false), e5.strstart++, e5.lookahead--, 0 === e5.strm.avail_out)
          return Q;
      } else
        e5.match_available = 1, e5.strstart++, e5.lookahead--;
    }
    return e5.match_available && (r3 = a2._tr_tally(e5, 0, e5.window[e5.strstart - 1]), e5.match_available = 0), e5.insert = e5.strstart < F - 1 ? e5.strstart : F - 1, t3 === f2 ? (te(e5, true), 0 === e5.strm.avail_out ? q : V) : e5.last_lit && (te(e5, false), 0 === e5.strm.avail_out) ? Q : W;
  }
  function he(e5, t3) {
    for (var i3, r3, n3, o3, s3 = e5.window; ; ) {
      if (e5.lookahead <= N2) {
        if (oe(e5), e5.lookahead <= N2 && t3 === u2)
          return Q;
        if (0 === e5.lookahead)
          break;
      }
      if (e5.match_length = 0, e5.lookahead >= F && e5.strstart > 0 && (r3 = s3[n3 = e5.strstart - 1]) === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3]) {
        o3 = e5.strstart + N2;
        do {
        } while (r3 === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3] && r3 === s3[++n3] && n3 < o3);
        e5.match_length = N2 - (o3 - n3), e5.match_length > e5.lookahead && (e5.match_length = e5.lookahead);
      }
      if (e5.match_length >= F ? (i3 = a2._tr_tally(e5, 1, e5.match_length - F), e5.lookahead -= e5.match_length, e5.strstart += e5.match_length, e5.match_length = 0) : (i3 = a2._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++), i3 && (te(e5, false), 0 === e5.strm.avail_out))
        return Q;
    }
    return e5.insert = 0, t3 === f2 ? (te(e5, true), 0 === e5.strm.avail_out ? q : V) : e5.last_lit && (te(e5, false), 0 === e5.strm.avail_out) ? Q : W;
  }
  function ce(e5, t3) {
    for (var i3; ; ) {
      if (0 === e5.lookahead && (oe(e5), 0 === e5.lookahead)) {
        if (t3 === u2)
          return Q;
        break;
      }
      if (e5.match_length = 0, i3 = a2._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++, i3 && (te(e5, false), 0 === e5.strm.avail_out))
        return Q;
    }
    return e5.insert = 0, t3 === f2 ? (te(e5, true), 0 === e5.strm.avail_out ? q : V) : e5.last_lit && (te(e5, false), 0 === e5.strm.avail_out) ? Q : W;
  }
  function fe(e5, t3, i3, r3, n3) {
    this.good_length = e5, this.max_lazy = t3, this.nice_length = i3, this.max_chain = r3, this.func = n3;
  }
  function de(e5) {
    e5.window_size = 2 * e5.w_size, X(e5.head), e5.max_lazy_match = r2[e5.level].max_lazy, e5.good_match = r2[e5.level].good_length, e5.nice_match = r2[e5.level].nice_length, e5.max_chain_length = r2[e5.level].max_chain, e5.strstart = 0, e5.block_start = 0, e5.lookahead = 0, e5.insert = 0, e5.match_length = e5.prev_length = F - 1, e5.match_available = 0, e5.ins_h = 0;
  }
  function pe() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = A2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n2.Buf16(2 * R2), this.dyn_dtree = new n2.Buf16(2 * (2 * B2 + 1)), this.bl_tree = new n2.Buf16(2 * (2 * C2 + 1)), X(this.dyn_ltree), X(this.dyn_dtree), X(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n2.Buf16(z2 + 1), this.heap = new n2.Buf16(2 * P + 1), X(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n2.Buf16(2 * P + 1), X(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function me(e5) {
    var t3;
    return e5 && e5.state ? (e5.total_in = e5.total_out = 0, e5.data_type = S2, (t3 = e5.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? $ : G, e5.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = u2, a2._tr_init(t3), p2) : K(e5, _2);
  }
  function _e(e5) {
    var t3 = me(e5);
    return t3 === p2 && de(e5.state), t3;
  }
  function ge(e5, t3) {
    return e5 && e5.state ? 2 !== e5.state.wrap ? _2 : (e5.state.gzhead = t3, p2) : _2;
  }
  function be(e5, t3, i3, r3, a3, o3) {
    if (!e5)
      return _2;
    var s3 = 1;
    if (t3 === y2 && (t3 = 6), r3 < 0 ? (s3 = 0, r3 = -r3) : r3 > 15 && (s3 = 2, r3 -= 16), a3 < 1 || a3 > I || i3 !== A2 || r3 < 8 || r3 > 15 || t3 < 0 || t3 > 9 || o3 < 0 || o3 > E2)
      return K(e5, _2);
    8 === r3 && (r3 = 9);
    var l3 = new pe();
    return e5.state = l3, l3.strm = e5, l3.wrap = s3, l3.gzhead = null, l3.w_bits = r3, l3.w_size = 1 << l3.w_bits, l3.w_mask = l3.w_size - 1, l3.hash_bits = a3 + 7, l3.hash_size = 1 << l3.hash_bits, l3.hash_mask = l3.hash_size - 1, l3.hash_shift = ~~((l3.hash_bits + F - 1) / F), l3.window = new n2.Buf8(2 * l3.w_size), l3.head = new n2.Buf16(l3.hash_size), l3.prev = new n2.Buf16(l3.w_size), l3.lit_bufsize = 1 << a3 + 6, l3.pending_buf_size = 4 * l3.lit_bufsize, l3.pending_buf = new n2.Buf8(l3.pending_buf_size), l3.d_buf = 1 * l3.lit_bufsize, l3.l_buf = 3 * l3.lit_bufsize, l3.level = t3, l3.strategy = o3, l3.method = i3, _e(e5);
  }
  function ye(e5, t3) {
    return be(e5, t3, A2, M2, T2, k2);
  }
  function we(e5, t3) {
    var i3, n3, o3, l3;
    if (!e5 || !e5.state || t3 > d || t3 < 0)
      return e5 ? K(e5, _2) : _2;
    if (n3 = e5.state, !e5.output || !e5.input && 0 !== e5.avail_in || n3.status === H && t3 !== f2)
      return K(e5, 0 === e5.avail_out ? b2 : _2);
    if (n3.strm = e5, i3 = n3.last_flush, n3.last_flush = t3, n3.status === $)
      if (2 === n3.wrap)
        e5.adler = 0, ie(n3, 31), ie(n3, 139), ie(n3, 8), n3.gzhead ? (ie(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), ie(n3, 255 & n3.gzhead.time), ie(n3, n3.gzhead.time >> 8 & 255), ie(n3, n3.gzhead.time >> 16 & 255), ie(n3, n3.gzhead.time >> 24 & 255), ie(n3, 9 === n3.level ? 2 : n3.strategy >= v2 || n3.level < 2 ? 4 : 0), ie(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (ie(n3, 255 & n3.gzhead.extra.length), ie(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = L2) : (ie(n3, 0), ie(n3, 0), ie(n3, 0), ie(n3, 0), ie(n3, 0), ie(n3, 9 === n3.level ? 2 : n3.strategy >= v2 || n3.level < 2 ? 4 : 0), ie(n3, Y2), n3.status = G);
      else {
        var g2 = A2 + (n3.w_bits - 8 << 4) << 8;
        g2 |= (n3.strategy >= v2 || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (g2 |= D), g2 += 31 - g2 % 31, n3.status = G, re(n3, g2), 0 !== n3.strstart && (re(n3, e5.adler >>> 16), re(n3, 65535 & e5.adler)), e5.adler = 1;
      }
    if (n3.status === L2)
      if (n3.gzhead.extra) {
        for (o3 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > o3 && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending - o3, o3)), ee(e5), o3 = n3.pending, n3.pending !== n3.pending_buf_size)); )
          ie(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
        n3.gzhead.hcrc && n3.pending > o3 && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending - o3, o3)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = U);
      } else
        n3.status = U;
    if (n3.status === U)
      if (n3.gzhead.name) {
        o3 = n3.pending;
        do {
          if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > o3 && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending - o3, o3)), ee(e5), o3 = n3.pending, n3.pending === n3.pending_buf_size)) {
            l3 = 1;
            break;
          }
          l3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, ie(n3, l3);
        } while (0 !== l3);
        n3.gzhead.hcrc && n3.pending > o3 && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending - o3, o3)), 0 === l3 && (n3.gzindex = 0, n3.status = Z);
      } else
        n3.status = Z;
    if (n3.status === Z)
      if (n3.gzhead.comment) {
        o3 = n3.pending;
        do {
          if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > o3 && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending - o3, o3)), ee(e5), o3 = n3.pending, n3.pending === n3.pending_buf_size)) {
            l3 = 1;
            break;
          }
          l3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, ie(n3, l3);
        } while (0 !== l3);
        n3.gzhead.hcrc && n3.pending > o3 && (e5.adler = s2(e5.adler, n3.pending_buf, n3.pending - o3, o3)), 0 === l3 && (n3.status = j);
      } else
        n3.status = j;
    if (n3.status === j && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && ee(e5), n3.pending + 2 <= n3.pending_buf_size && (ie(n3, 255 & e5.adler), ie(n3, e5.adler >> 8 & 255), e5.adler = 0, n3.status = G)) : n3.status = G), 0 !== n3.pending) {
      if (ee(e5), 0 === e5.avail_out)
        return n3.last_flush = -1, p2;
    } else if (0 === e5.avail_in && J(t3) <= J(i3) && t3 !== f2)
      return K(e5, b2);
    if (n3.status === H && 0 !== e5.avail_in)
      return K(e5, b2);
    if (0 !== e5.avail_in || 0 !== n3.lookahead || t3 !== u2 && n3.status !== H) {
      var y3 = n3.strategy === v2 ? ce(n3, t3) : n3.strategy === x2 ? he(n3, t3) : r2[n3.level].func(n3, t3);
      if (y3 !== q && y3 !== V || (n3.status = H), y3 === Q || y3 === q)
        return 0 === e5.avail_out && (n3.last_flush = -1), p2;
      if (y3 === W && (t3 === h2 ? a2._tr_align(n3) : t3 !== d && (a2._tr_stored_block(n3, 0, 0, false), t3 === c2 && (X(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), ee(e5), 0 === e5.avail_out))
        return n3.last_flush = -1, p2;
    }
    return t3 !== f2 ? p2 : n3.wrap <= 0 ? m : (2 === n3.wrap ? (ie(n3, 255 & e5.adler), ie(n3, e5.adler >> 8 & 255), ie(n3, e5.adler >> 16 & 255), ie(n3, e5.adler >> 24 & 255), ie(n3, 255 & e5.total_in), ie(n3, e5.total_in >> 8 & 255), ie(n3, e5.total_in >> 16 & 255), ie(n3, e5.total_in >> 24 & 255)) : (re(n3, e5.adler >>> 16), re(n3, 65535 & e5.adler)), ee(e5), n3.wrap > 0 && (n3.wrap = -n3.wrap), 0 !== n3.pending ? p2 : m);
  }
  function ve(e5) {
    var t3;
    return e5 && e5.state ? (t3 = e5.state.status) !== $ && t3 !== L2 && t3 !== U && t3 !== Z && t3 !== j && t3 !== G && t3 !== H ? K(e5, _2) : (e5.state = null, t3 === G ? K(e5, g) : p2) : _2;
  }
  function xe(e5, t3) {
    var i3, r3, a3, s3, l3, u3, h3, c3, f3 = t3.length;
    if (!e5 || !e5.state)
      return _2;
    if (2 === (s3 = (i3 = e5.state).wrap) || 1 === s3 && i3.status !== $ || i3.lookahead)
      return _2;
    for (1 === s3 && (e5.adler = o2(e5.adler, t3, f3, 0)), i3.wrap = 0, f3 >= i3.w_size && (0 === s3 && (X(i3.head), i3.strstart = 0, i3.block_start = 0, i3.insert = 0), c3 = new n2.Buf8(i3.w_size), n2.arraySet(c3, t3, f3 - i3.w_size, i3.w_size, 0), t3 = c3, f3 = i3.w_size), l3 = e5.avail_in, u3 = e5.next_in, h3 = e5.input, e5.avail_in = f3, e5.next_in = 0, e5.input = t3, oe(i3); i3.lookahead >= F; ) {
      r3 = i3.strstart, a3 = i3.lookahead - (F - 1);
      do {
        i3.ins_h = (i3.ins_h << i3.hash_shift ^ i3.window[r3 + F - 1]) & i3.hash_mask, i3.prev[r3 & i3.w_mask] = i3.head[i3.ins_h], i3.head[i3.ins_h] = r3, r3++;
      } while (--a3);
      i3.strstart = r3, i3.lookahead = F - 1, oe(i3);
    }
    return i3.strstart += i3.lookahead, i3.block_start = i3.strstart, i3.insert = i3.lookahead, i3.lookahead = 0, i3.match_length = i3.prev_length = F - 1, i3.match_available = 0, e5.next_in = u3, e5.input = h3, e5.avail_in = l3, i3.wrap = s3, p2;
  }
  r2 = [new fe(0, 0, 0, 0, se), new fe(4, 4, 8, 4, le), new fe(4, 5, 16, 8, le), new fe(4, 6, 32, 32, le), new fe(4, 4, 16, 16, ue), new fe(8, 16, 32, 32, ue), new fe(8, 16, 128, 128, ue), new fe(8, 32, 128, 256, ue), new fe(32, 128, 258, 1024, ue), new fe(32, 258, 258, 4096, ue)], i2.deflateInit = ye, i2.deflateInit2 = be, i2.deflateReset = _e, i2.deflateResetKeep = me, i2.deflateSetHeader = ge, i2.deflate = we, i2.deflateEnd = ve, i2.deflateSetDictionary = xe, i2.deflateInfo = "pako deflate (from Nodeca project)";
}, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./messages": 60, "./trees": 61 }], 57: [function(e4, t2, i2) {
  var r2 = 30, n2 = 12;
  t2.exports = function(e5, t3) {
    var i3, a2, o2, s2, l2, u2, h2, c2, f2, d, p2, m, _2, g, b2, y2, w, v2, x2, E2, k2, S2, A2, I, M2;
    i3 = e5.state, a2 = e5.next_in, I = e5.input, o2 = a2 + (e5.avail_in - 5), s2 = e5.next_out, M2 = e5.output, l2 = s2 - (t3 - e5.avail_out), u2 = s2 + (e5.avail_out - 257), h2 = i3.dmax, c2 = i3.wsize, f2 = i3.whave, d = i3.wnext, p2 = i3.window, m = i3.hold, _2 = i3.bits, g = i3.lencode, b2 = i3.distcode, y2 = (1 << i3.lenbits) - 1, w = (1 << i3.distbits) - 1;
    e:
      do {
        _2 < 15 && (m += I[a2++] << _2, _2 += 8, m += I[a2++] << _2, _2 += 8), v2 = g[m & y2];
        t:
          for (; ; ) {
            if (m >>>= x2 = v2 >>> 24, _2 -= x2, 0 == (x2 = v2 >>> 16 & 255))
              M2[s2++] = 65535 & v2;
            else {
              if (!(16 & x2)) {
                if (64 & x2) {
                  if (32 & x2) {
                    i3.mode = n2;
                    break e;
                  }
                  e5.msg = "invalid literal/length code", i3.mode = r2;
                  break e;
                }
                v2 = g[(65535 & v2) + (m & (1 << x2) - 1)];
                continue t;
              }
              for (E2 = 65535 & v2, (x2 &= 15) && (_2 < x2 && (m += I[a2++] << _2, _2 += 8), E2 += m & (1 << x2) - 1, m >>>= x2, _2 -= x2), _2 < 15 && (m += I[a2++] << _2, _2 += 8, m += I[a2++] << _2, _2 += 8), v2 = b2[m & w]; ; ) {
                if (m >>>= x2 = v2 >>> 24, _2 -= x2, 16 & (x2 = v2 >>> 16 & 255)) {
                  if (k2 = 65535 & v2, _2 < (x2 &= 15) && (m += I[a2++] << _2, (_2 += 8) < x2 && (m += I[a2++] << _2, _2 += 8)), (k2 += m & (1 << x2) - 1) > h2) {
                    e5.msg = "invalid distance too far back", i3.mode = r2;
                    break e;
                  }
                  if (m >>>= x2, _2 -= x2, k2 > (x2 = s2 - l2)) {
                    if ((x2 = k2 - x2) > f2 && i3.sane) {
                      e5.msg = "invalid distance too far back", i3.mode = r2;
                      break e;
                    }
                    if (S2 = 0, A2 = p2, 0 === d) {
                      if (S2 += c2 - x2, x2 < E2) {
                        E2 -= x2;
                        do {
                          M2[s2++] = p2[S2++];
                        } while (--x2);
                        S2 = s2 - k2, A2 = M2;
                      }
                    } else if (d < x2) {
                      if (S2 += c2 + d - x2, (x2 -= d) < E2) {
                        E2 -= x2;
                        do {
                          M2[s2++] = p2[S2++];
                        } while (--x2);
                        if (S2 = 0, d < E2) {
                          E2 -= x2 = d;
                          do {
                            M2[s2++] = p2[S2++];
                          } while (--x2);
                          S2 = s2 - k2, A2 = M2;
                        }
                      }
                    } else if (S2 += d - x2, x2 < E2) {
                      E2 -= x2;
                      do {
                        M2[s2++] = p2[S2++];
                      } while (--x2);
                      S2 = s2 - k2, A2 = M2;
                    }
                    for (; E2 > 2; )
                      M2[s2++] = A2[S2++], M2[s2++] = A2[S2++], M2[s2++] = A2[S2++], E2 -= 3;
                    E2 && (M2[s2++] = A2[S2++], E2 > 1 && (M2[s2++] = A2[S2++]));
                  } else {
                    S2 = s2 - k2;
                    do {
                      M2[s2++] = M2[S2++], M2[s2++] = M2[S2++], M2[s2++] = M2[S2++], E2 -= 3;
                    } while (E2 > 2);
                    E2 && (M2[s2++] = M2[S2++], E2 > 1 && (M2[s2++] = M2[S2++]));
                  }
                  break;
                }
                if (64 & x2) {
                  e5.msg = "invalid distance code", i3.mode = r2;
                  break e;
                }
                v2 = b2[(65535 & v2) + (m & (1 << x2) - 1)];
              }
            }
            break;
          }
      } while (a2 < o2 && s2 < u2);
    a2 -= E2 = _2 >> 3, m &= (1 << (_2 -= E2 << 3)) - 1, e5.next_in = a2, e5.next_out = s2, e5.avail_in = a2 < o2 ? o2 - a2 + 5 : 5 - (a2 - o2), e5.avail_out = s2 < u2 ? u2 - s2 + 257 : 257 - (s2 - u2), i3.hold = m, i3.bits = _2;
  };
}, {}], 58: [function(e4, t2, i2) {
  var r2 = e4("../utils/common"), n2 = e4("./adler32"), a2 = e4("./crc32"), o2 = e4("./inffast"), s2 = e4("./inftrees"), l2 = 0, u2 = 1, h2 = 2, c2 = 4, f2 = 5, d = 6, p2 = 0, m = 1, _2 = 2, g = -2, b2 = -3, y2 = -4, w = -5, v2 = 8, x2 = 1, E2 = 2, k2 = 3, S2 = 4, A2 = 5, I = 6, M2 = 7, T2 = 8, P = 9, B2 = 10, C2 = 11, R2 = 12, z2 = 13, F = 14, N2 = 15, O2 = 16, D = 17, $ = 18, L2 = 19, U = 20, Z = 21, j = 22, G = 23, H = 24, Q = 25, W = 26, q = 27, V = 28, Y2 = 29, K = 30, J = 31, X = 852, ee = 592, te = 15;
  function ie(e5) {
    return (e5 >>> 24 & 255) + (e5 >>> 8 & 65280) + ((65280 & e5) << 8) + ((255 & e5) << 24);
  }
  function re() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r2.Buf16(320), this.work = new r2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function ne(e5) {
    var t3;
    return e5 && e5.state ? (t3 = e5.state, e5.total_in = e5.total_out = t3.total = 0, e5.msg = "", t3.wrap && (e5.adler = 1 & t3.wrap), t3.mode = x2, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new r2.Buf32(X), t3.distcode = t3.distdyn = new r2.Buf32(ee), t3.sane = 1, t3.back = -1, p2) : g;
  }
  function ae(e5) {
    var t3;
    return e5 && e5.state ? ((t3 = e5.state).wsize = 0, t3.whave = 0, t3.wnext = 0, ne(e5)) : g;
  }
  function oe(e5, t3) {
    var i3, r3;
    return e5 && e5.state ? (r3 = e5.state, t3 < 0 ? (i3 = 0, t3 = -t3) : (i3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? g : (null !== r3.window && r3.wbits !== t3 && (r3.window = null), r3.wrap = i3, r3.wbits = t3, ae(e5))) : g;
  }
  function se(e5, t3) {
    var i3, r3;
    return e5 ? (r3 = new re(), e5.state = r3, r3.window = null, (i3 = oe(e5, t3)) !== p2 && (e5.state = null), i3) : g;
  }
  function le(e5) {
    return se(e5, te);
  }
  var ue, he, ce = true;
  function fe(e5) {
    if (ce) {
      var t3;
      for (ue = new r2.Buf32(512), he = new r2.Buf32(32), t3 = 0; t3 < 144; )
        e5.lens[t3++] = 8;
      for (; t3 < 256; )
        e5.lens[t3++] = 9;
      for (; t3 < 280; )
        e5.lens[t3++] = 7;
      for (; t3 < 288; )
        e5.lens[t3++] = 8;
      for (s2(u2, e5.lens, 0, 288, ue, 0, e5.work, { bits: 9 }), t3 = 0; t3 < 32; )
        e5.lens[t3++] = 5;
      s2(h2, e5.lens, 0, 32, he, 0, e5.work, { bits: 5 }), ce = false;
    }
    e5.lencode = ue, e5.lenbits = 9, e5.distcode = he, e5.distbits = 5;
  }
  function de(e5, t3, i3, n3) {
    var a3, o3 = e5.state;
    return null === o3.window && (o3.wsize = 1 << o3.wbits, o3.wnext = 0, o3.whave = 0, o3.window = new r2.Buf8(o3.wsize)), n3 >= o3.wsize ? (r2.arraySet(o3.window, t3, i3 - o3.wsize, o3.wsize, 0), o3.wnext = 0, o3.whave = o3.wsize) : ((a3 = o3.wsize - o3.wnext) > n3 && (a3 = n3), r2.arraySet(o3.window, t3, i3 - n3, a3, o3.wnext), (n3 -= a3) ? (r2.arraySet(o3.window, t3, i3 - n3, n3, 0), o3.wnext = n3, o3.whave = o3.wsize) : (o3.wnext += a3, o3.wnext === o3.wsize && (o3.wnext = 0), o3.whave < o3.wsize && (o3.whave += a3))), 0;
  }
  function pe(e5, t3) {
    var i3, X2, ee2, te2, re2, ne2, ae2, oe2, se2, le2, ue2, he2, ce2, pe2, me2, _e2, ge2, be, ye, we, ve, xe, Ee, ke, Se = 0, Ae = new r2.Buf8(4), Ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!e5 || !e5.state || !e5.output || !e5.input && 0 !== e5.avail_in)
      return g;
    (i3 = e5.state).mode === R2 && (i3.mode = z2), re2 = e5.next_out, ee2 = e5.output, ae2 = e5.avail_out, te2 = e5.next_in, X2 = e5.input, ne2 = e5.avail_in, oe2 = i3.hold, se2 = i3.bits, le2 = ne2, ue2 = ae2, xe = p2;
    e:
      for (; ; )
        switch (i3.mode) {
          case x2:
            if (0 === i3.wrap) {
              i3.mode = z2;
              break;
            }
            for (; se2 < 16; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (2 & i3.wrap && 35615 === oe2) {
              i3.check = 0, Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0), oe2 = 0, se2 = 0, i3.mode = E2;
              break;
            }
            if (i3.flags = 0, i3.head && (i3.head.done = false), !(1 & i3.wrap) || (((255 & oe2) << 8) + (oe2 >> 8)) % 31) {
              e5.msg = "incorrect header check", i3.mode = K;
              break;
            }
            if ((15 & oe2) !== v2) {
              e5.msg = "unknown compression method", i3.mode = K;
              break;
            }
            if (se2 -= 4, ve = 8 + (15 & (oe2 >>>= 4)), 0 === i3.wbits)
              i3.wbits = ve;
            else if (ve > i3.wbits) {
              e5.msg = "invalid window size", i3.mode = K;
              break;
            }
            i3.dmax = 1 << ve, e5.adler = i3.check = 1, i3.mode = 512 & oe2 ? B2 : R2, oe2 = 0, se2 = 0;
            break;
          case E2:
            for (; se2 < 16; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (i3.flags = oe2, (255 & i3.flags) !== v2) {
              e5.msg = "unknown compression method", i3.mode = K;
              break;
            }
            if (57344 & i3.flags) {
              e5.msg = "unknown header flags set", i3.mode = K;
              break;
            }
            i3.head && (i3.head.text = oe2 >> 8 & 1), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0)), oe2 = 0, se2 = 0, i3.mode = k2;
          case k2:
            for (; se2 < 32; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            i3.head && (i3.head.time = oe2), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, Ae[2] = oe2 >>> 16 & 255, Ae[3] = oe2 >>> 24 & 255, i3.check = a2(i3.check, Ae, 4, 0)), oe2 = 0, se2 = 0, i3.mode = S2;
          case S2:
            for (; se2 < 16; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            i3.head && (i3.head.xflags = 255 & oe2, i3.head.os = oe2 >> 8), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0)), oe2 = 0, se2 = 0, i3.mode = A2;
          case A2:
            if (1024 & i3.flags) {
              for (; se2 < 16; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.length = oe2, i3.head && (i3.head.extra_len = oe2), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0)), oe2 = 0, se2 = 0;
            } else
              i3.head && (i3.head.extra = null);
            i3.mode = I;
          case I:
            if (1024 & i3.flags && ((he2 = i3.length) > ne2 && (he2 = ne2), he2 && (i3.head && (ve = i3.head.extra_len - i3.length, i3.head.extra || (i3.head.extra = new Array(i3.head.extra_len)), r2.arraySet(i3.head.extra, X2, te2, he2, ve)), 512 & i3.flags && (i3.check = a2(i3.check, X2, he2, te2)), ne2 -= he2, te2 += he2, i3.length -= he2), i3.length))
              break e;
            i3.length = 0, i3.mode = M2;
          case M2:
            if (2048 & i3.flags) {
              if (0 === ne2)
                break e;
              he2 = 0;
              do {
                ve = X2[te2 + he2++], i3.head && ve && i3.length < 65536 && (i3.head.name += String.fromCharCode(ve));
              } while (ve && he2 < ne2);
              if (512 & i3.flags && (i3.check = a2(i3.check, X2, he2, te2)), ne2 -= he2, te2 += he2, ve)
                break e;
            } else
              i3.head && (i3.head.name = null);
            i3.length = 0, i3.mode = T2;
          case T2:
            if (4096 & i3.flags) {
              if (0 === ne2)
                break e;
              he2 = 0;
              do {
                ve = X2[te2 + he2++], i3.head && ve && i3.length < 65536 && (i3.head.comment += String.fromCharCode(ve));
              } while (ve && he2 < ne2);
              if (512 & i3.flags && (i3.check = a2(i3.check, X2, he2, te2)), ne2 -= he2, te2 += he2, ve)
                break e;
            } else
              i3.head && (i3.head.comment = null);
            i3.mode = P;
          case P:
            if (512 & i3.flags) {
              for (; se2 < 16; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (oe2 !== (65535 & i3.check)) {
                e5.msg = "header crc mismatch", i3.mode = K;
                break;
              }
              oe2 = 0, se2 = 0;
            }
            i3.head && (i3.head.hcrc = i3.flags >> 9 & 1, i3.head.done = true), e5.adler = i3.check = 0, i3.mode = R2;
            break;
          case B2:
            for (; se2 < 32; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            e5.adler = i3.check = ie(oe2), oe2 = 0, se2 = 0, i3.mode = C2;
          case C2:
            if (0 === i3.havedict)
              return e5.next_out = re2, e5.avail_out = ae2, e5.next_in = te2, e5.avail_in = ne2, i3.hold = oe2, i3.bits = se2, _2;
            e5.adler = i3.check = 1, i3.mode = R2;
          case R2:
            if (t3 === f2 || t3 === d)
              break e;
          case z2:
            if (i3.last) {
              oe2 >>>= 7 & se2, se2 -= 7 & se2, i3.mode = q;
              break;
            }
            for (; se2 < 3; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            switch (i3.last = 1 & oe2, se2 -= 1, 3 & (oe2 >>>= 1)) {
              case 0:
                i3.mode = F;
                break;
              case 1:
                if (fe(i3), i3.mode = U, t3 === d) {
                  oe2 >>>= 2, se2 -= 2;
                  break e;
                }
                break;
              case 2:
                i3.mode = D;
                break;
              case 3:
                e5.msg = "invalid block type", i3.mode = K;
            }
            oe2 >>>= 2, se2 -= 2;
            break;
          case F:
            for (oe2 >>>= 7 & se2, se2 -= 7 & se2; se2 < 32; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if ((65535 & oe2) != (oe2 >>> 16 ^ 65535)) {
              e5.msg = "invalid stored block lengths", i3.mode = K;
              break;
            }
            if (i3.length = 65535 & oe2, oe2 = 0, se2 = 0, i3.mode = N2, t3 === d)
              break e;
          case N2:
            i3.mode = O2;
          case O2:
            if (he2 = i3.length) {
              if (he2 > ne2 && (he2 = ne2), he2 > ae2 && (he2 = ae2), 0 === he2)
                break e;
              r2.arraySet(ee2, X2, te2, he2, re2), ne2 -= he2, te2 += he2, ae2 -= he2, re2 += he2, i3.length -= he2;
              break;
            }
            i3.mode = R2;
            break;
          case D:
            for (; se2 < 14; ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (i3.nlen = 257 + (31 & oe2), oe2 >>>= 5, se2 -= 5, i3.ndist = 1 + (31 & oe2), oe2 >>>= 5, se2 -= 5, i3.ncode = 4 + (15 & oe2), oe2 >>>= 4, se2 -= 4, i3.nlen > 286 || i3.ndist > 30) {
              e5.msg = "too many length or distance symbols", i3.mode = K;
              break;
            }
            i3.have = 0, i3.mode = $;
          case $:
            for (; i3.have < i3.ncode; ) {
              for (; se2 < 3; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.lens[Ie[i3.have++]] = 7 & oe2, oe2 >>>= 3, se2 -= 3;
            }
            for (; i3.have < 19; )
              i3.lens[Ie[i3.have++]] = 0;
            if (i3.lencode = i3.lendyn, i3.lenbits = 7, Ee = { bits: i3.lenbits }, xe = s2(l2, i3.lens, 0, 19, i3.lencode, 0, i3.work, Ee), i3.lenbits = Ee.bits, xe) {
              e5.msg = "invalid code lengths set", i3.mode = K;
              break;
            }
            i3.have = 0, i3.mode = L2;
          case L2:
            for (; i3.have < i3.nlen + i3.ndist; ) {
              for (; _e2 = (Se = i3.lencode[oe2 & (1 << i3.lenbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (ge2 < 16)
                oe2 >>>= me2, se2 -= me2, i3.lens[i3.have++] = ge2;
              else {
                if (16 === ge2) {
                  for (ke = me2 + 2; se2 < ke; ) {
                    if (0 === ne2)
                      break e;
                    ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                  }
                  if (oe2 >>>= me2, se2 -= me2, 0 === i3.have) {
                    e5.msg = "invalid bit length repeat", i3.mode = K;
                    break;
                  }
                  ve = i3.lens[i3.have - 1], he2 = 3 + (3 & oe2), oe2 >>>= 2, se2 -= 2;
                } else if (17 === ge2) {
                  for (ke = me2 + 3; se2 < ke; ) {
                    if (0 === ne2)
                      break e;
                    ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                  }
                  se2 -= me2, ve = 0, he2 = 3 + (7 & (oe2 >>>= me2)), oe2 >>>= 3, se2 -= 3;
                } else {
                  for (ke = me2 + 7; se2 < ke; ) {
                    if (0 === ne2)
                      break e;
                    ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                  }
                  se2 -= me2, ve = 0, he2 = 11 + (127 & (oe2 >>>= me2)), oe2 >>>= 7, se2 -= 7;
                }
                if (i3.have + he2 > i3.nlen + i3.ndist) {
                  e5.msg = "invalid bit length repeat", i3.mode = K;
                  break;
                }
                for (; he2--; )
                  i3.lens[i3.have++] = ve;
              }
            }
            if (i3.mode === K)
              break;
            if (0 === i3.lens[256]) {
              e5.msg = "invalid code -- missing end-of-block", i3.mode = K;
              break;
            }
            if (i3.lenbits = 9, Ee = { bits: i3.lenbits }, xe = s2(u2, i3.lens, 0, i3.nlen, i3.lencode, 0, i3.work, Ee), i3.lenbits = Ee.bits, xe) {
              e5.msg = "invalid literal/lengths set", i3.mode = K;
              break;
            }
            if (i3.distbits = 6, i3.distcode = i3.distdyn, Ee = { bits: i3.distbits }, xe = s2(h2, i3.lens, i3.nlen, i3.ndist, i3.distcode, 0, i3.work, Ee), i3.distbits = Ee.bits, xe) {
              e5.msg = "invalid distances set", i3.mode = K;
              break;
            }
            if (i3.mode = U, t3 === d)
              break e;
          case U:
            i3.mode = Z;
          case Z:
            if (ne2 >= 6 && ae2 >= 258) {
              e5.next_out = re2, e5.avail_out = ae2, e5.next_in = te2, e5.avail_in = ne2, i3.hold = oe2, i3.bits = se2, o2(e5, ue2), re2 = e5.next_out, ee2 = e5.output, ae2 = e5.avail_out, te2 = e5.next_in, X2 = e5.input, ne2 = e5.avail_in, oe2 = i3.hold, se2 = i3.bits, i3.mode === R2 && (i3.back = -1);
              break;
            }
            for (i3.back = 0; _e2 = (Se = i3.lencode[oe2 & (1 << i3.lenbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (_e2 && !(240 & _e2)) {
              for (be = me2, ye = _e2, we = ge2; _e2 = (Se = i3.lencode[we + ((oe2 & (1 << be + ye) - 1) >> be)]) >>> 16 & 255, ge2 = 65535 & Se, !(be + (me2 = Se >>> 24) <= se2); ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              oe2 >>>= be, se2 -= be, i3.back += be;
            }
            if (oe2 >>>= me2, se2 -= me2, i3.back += me2, i3.length = ge2, 0 === _e2) {
              i3.mode = W;
              break;
            }
            if (32 & _e2) {
              i3.back = -1, i3.mode = R2;
              break;
            }
            if (64 & _e2) {
              e5.msg = "invalid literal/length code", i3.mode = K;
              break;
            }
            i3.extra = 15 & _e2, i3.mode = j;
          case j:
            if (i3.extra) {
              for (ke = i3.extra; se2 < ke; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.length += oe2 & (1 << i3.extra) - 1, oe2 >>>= i3.extra, se2 -= i3.extra, i3.back += i3.extra;
            }
            i3.was = i3.length, i3.mode = G;
          case G:
            for (; _e2 = (Se = i3.distcode[oe2 & (1 << i3.distbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
              if (0 === ne2)
                break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (!(240 & _e2)) {
              for (be = me2, ye = _e2, we = ge2; _e2 = (Se = i3.distcode[we + ((oe2 & (1 << be + ye) - 1) >> be)]) >>> 16 & 255, ge2 = 65535 & Se, !(be + (me2 = Se >>> 24) <= se2); ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              oe2 >>>= be, se2 -= be, i3.back += be;
            }
            if (oe2 >>>= me2, se2 -= me2, i3.back += me2, 64 & _e2) {
              e5.msg = "invalid distance code", i3.mode = K;
              break;
            }
            i3.offset = ge2, i3.extra = 15 & _e2, i3.mode = H;
          case H:
            if (i3.extra) {
              for (ke = i3.extra; se2 < ke; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.offset += oe2 & (1 << i3.extra) - 1, oe2 >>>= i3.extra, se2 -= i3.extra, i3.back += i3.extra;
            }
            if (i3.offset > i3.dmax) {
              e5.msg = "invalid distance too far back", i3.mode = K;
              break;
            }
            i3.mode = Q;
          case Q:
            if (0 === ae2)
              break e;
            if (he2 = ue2 - ae2, i3.offset > he2) {
              if ((he2 = i3.offset - he2) > i3.whave && i3.sane) {
                e5.msg = "invalid distance too far back", i3.mode = K;
                break;
              }
              he2 > i3.wnext ? (he2 -= i3.wnext, ce2 = i3.wsize - he2) : ce2 = i3.wnext - he2, he2 > i3.length && (he2 = i3.length), pe2 = i3.window;
            } else
              pe2 = ee2, ce2 = re2 - i3.offset, he2 = i3.length;
            he2 > ae2 && (he2 = ae2), ae2 -= he2, i3.length -= he2;
            do {
              ee2[re2++] = pe2[ce2++];
            } while (--he2);
            0 === i3.length && (i3.mode = Z);
            break;
          case W:
            if (0 === ae2)
              break e;
            ee2[re2++] = i3.length, ae2--, i3.mode = Z;
            break;
          case q:
            if (i3.wrap) {
              for (; se2 < 32; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 |= X2[te2++] << se2, se2 += 8;
              }
              if (ue2 -= ae2, e5.total_out += ue2, i3.total += ue2, ue2 && (e5.adler = i3.check = i3.flags ? a2(i3.check, ee2, ue2, re2 - ue2) : n2(i3.check, ee2, ue2, re2 - ue2)), ue2 = ae2, (i3.flags ? oe2 : ie(oe2)) !== i3.check) {
                e5.msg = "incorrect data check", i3.mode = K;
                break;
              }
              oe2 = 0, se2 = 0;
            }
            i3.mode = V;
          case V:
            if (i3.wrap && i3.flags) {
              for (; se2 < 32; ) {
                if (0 === ne2)
                  break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (oe2 !== (4294967295 & i3.total)) {
                e5.msg = "incorrect length check", i3.mode = K;
                break;
              }
              oe2 = 0, se2 = 0;
            }
            i3.mode = Y2;
          case Y2:
            xe = m;
            break e;
          case K:
            xe = b2;
            break e;
          case J:
            return y2;
          default:
            return g;
        }
    return e5.next_out = re2, e5.avail_out = ae2, e5.next_in = te2, e5.avail_in = ne2, i3.hold = oe2, i3.bits = se2, (i3.wsize || ue2 !== e5.avail_out && i3.mode < K && (i3.mode < q || t3 !== c2)) && de(e5, e5.output, e5.next_out, ue2 - e5.avail_out), le2 -= e5.avail_in, ue2 -= e5.avail_out, e5.total_in += le2, e5.total_out += ue2, i3.total += ue2, i3.wrap && ue2 && (e5.adler = i3.check = i3.flags ? a2(i3.check, ee2, ue2, e5.next_out - ue2) : n2(i3.check, ee2, ue2, e5.next_out - ue2)), e5.data_type = i3.bits + (i3.last ? 64 : 0) + (i3.mode === R2 ? 128 : 0) + (i3.mode === U || i3.mode === N2 ? 256 : 0), (0 === le2 && 0 === ue2 || t3 === c2) && xe === p2 && (xe = w), xe;
  }
  function me(e5) {
    if (!e5 || !e5.state)
      return g;
    var t3 = e5.state;
    return t3.window && (t3.window = null), e5.state = null, p2;
  }
  function _e(e5, t3) {
    var i3;
    return e5 && e5.state && 2 & (i3 = e5.state).wrap ? (i3.head = t3, t3.done = false, p2) : g;
  }
  function ge(e5, t3) {
    var i3, r3 = t3.length;
    return e5 && e5.state ? 0 !== (i3 = e5.state).wrap && i3.mode !== C2 ? g : i3.mode === C2 && n2(1, t3, r3, 0) !== i3.check ? b2 : de(e5, t3, r3, r3) ? (i3.mode = J, y2) : (i3.havedict = 1, p2) : g;
  }
  i2.inflateReset = ae, i2.inflateReset2 = oe, i2.inflateResetKeep = ne, i2.inflateInit = le, i2.inflateInit2 = se, i2.inflate = pe, i2.inflateEnd = me, i2.inflateGetHeader = _e, i2.inflateSetDictionary = ge, i2.inflateInfo = "pako inflate (from Nodeca project)";
}, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./inffast": 57, "./inftrees": 59 }], 59: [function(e4, t2, i2) {
  var r2 = e4("../utils/common"), n2 = 15, a2 = 852, o2 = 592, s2 = 0, l2 = 1, u2 = 2, h2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], f2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  t2.exports = function(e5, t3, i3, p2, m, _2, g, b2) {
    var y2, w, v2, x2, E2, k2, S2, A2, I, M2 = b2.bits, T2 = 0, P = 0, B2 = 0, C2 = 0, R2 = 0, z2 = 0, F = 0, N2 = 0, O2 = 0, D = 0, $ = null, L2 = 0, U = new r2.Buf16(n2 + 1), Z = new r2.Buf16(n2 + 1), j = null, G = 0;
    for (T2 = 0; T2 <= n2; T2++)
      U[T2] = 0;
    for (P = 0; P < p2; P++)
      U[t3[i3 + P]]++;
    for (R2 = M2, C2 = n2; C2 >= 1 && 0 === U[C2]; C2--)
      ;
    if (R2 > C2 && (R2 = C2), 0 === C2)
      return m[_2++] = 20971520, m[_2++] = 20971520, b2.bits = 1, 0;
    for (B2 = 1; B2 < C2 && 0 === U[B2]; B2++)
      ;
    for (R2 < B2 && (R2 = B2), N2 = 1, T2 = 1; T2 <= n2; T2++)
      if (N2 <<= 1, (N2 -= U[T2]) < 0)
        return -1;
    if (N2 > 0 && (e5 === s2 || 1 !== C2))
      return -1;
    for (Z[1] = 0, T2 = 1; T2 < n2; T2++)
      Z[T2 + 1] = Z[T2] + U[T2];
    for (P = 0; P < p2; P++)
      0 !== t3[i3 + P] && (g[Z[t3[i3 + P]]++] = P);
    if (e5 === s2 ? ($ = j = g, k2 = 19) : e5 === l2 ? ($ = h2, L2 -= 257, j = c2, G -= 257, k2 = 256) : ($ = f2, j = d, k2 = -1), D = 0, P = 0, T2 = B2, E2 = _2, z2 = R2, F = 0, v2 = -1, x2 = (O2 = 1 << R2) - 1, e5 === l2 && O2 > a2 || e5 === u2 && O2 > o2)
      return 1;
    for (; ; ) {
      S2 = T2 - F, g[P] < k2 ? (A2 = 0, I = g[P]) : g[P] > k2 ? (A2 = j[G + g[P]], I = $[L2 + g[P]]) : (A2 = 96, I = 0), y2 = 1 << T2 - F, B2 = w = 1 << z2;
      do {
        m[E2 + (D >> F) + (w -= y2)] = S2 << 24 | A2 << 16 | I;
      } while (0 !== w);
      for (y2 = 1 << T2 - 1; D & y2; )
        y2 >>= 1;
      if (0 !== y2 ? (D &= y2 - 1, D += y2) : D = 0, P++, 0 == --U[T2]) {
        if (T2 === C2)
          break;
        T2 = t3[i3 + g[P]];
      }
      if (T2 > R2 && (D & x2) !== v2) {
        for (0 === F && (F = R2), E2 += B2, N2 = 1 << (z2 = T2 - F); z2 + F < C2 && !((N2 -= U[z2 + F]) <= 0); )
          z2++, N2 <<= 1;
        if (O2 += 1 << z2, e5 === l2 && O2 > a2 || e5 === u2 && O2 > o2)
          return 1;
        m[v2 = D & x2] = R2 << 24 | z2 << 16 | E2 - _2;
      }
    }
    return 0 !== D && (m[E2 + D] = T2 - F << 24 | 64 << 16), b2.bits = R2, 0;
  };
}, { "../utils/common": 52 }], 60: [function(e4, t2, i2) {
  t2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
}, {}], 61: [function(e4, t2, i2) {
  var r2 = e4("../utils/common"), n2 = 4, a2 = 0, o2 = 1, s2 = 2;
  function l2(e5) {
    for (var t3 = e5.length; --t3 >= 0; )
      e5[t3] = 0;
  }
  var u2 = 0, h2 = 1, c2 = 2, f2 = 3, d = 258, p2 = 29, m = 256, _2 = m + 1 + p2, g = 30, b2 = 19, y2 = 2 * _2 + 1, w = 15, v2 = 16, x2 = 7, E2 = 256, k2 = 16, S2 = 17, A2 = 18, I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], P = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], B2 = 512, C2 = new Array(2 * (_2 + 2));
  l2(C2);
  var R2 = new Array(2 * g);
  l2(R2);
  var z2 = new Array(B2);
  l2(z2);
  var F = new Array(d - f2 + 1);
  l2(F);
  var N2 = new Array(p2);
  l2(N2);
  var O2, D, $, L2 = new Array(g);
  function U(e5, t3, i3, r3, n3) {
    this.static_tree = e5, this.extra_bits = t3, this.extra_base = i3, this.elems = r3, this.max_length = n3, this.has_stree = e5 && e5.length;
  }
  function Z(e5, t3) {
    this.dyn_tree = e5, this.max_code = 0, this.stat_desc = t3;
  }
  function j(e5) {
    return e5 < 256 ? z2[e5] : z2[256 + (e5 >>> 7)];
  }
  function G(e5, t3) {
    e5.pending_buf[e5.pending++] = 255 & t3, e5.pending_buf[e5.pending++] = t3 >>> 8 & 255;
  }
  function H(e5, t3, i3) {
    e5.bi_valid > v2 - i3 ? (e5.bi_buf |= t3 << e5.bi_valid & 65535, G(e5, e5.bi_buf), e5.bi_buf = t3 >> v2 - e5.bi_valid, e5.bi_valid += i3 - v2) : (e5.bi_buf |= t3 << e5.bi_valid & 65535, e5.bi_valid += i3);
  }
  function Q(e5, t3, i3) {
    H(e5, i3[2 * t3], i3[2 * t3 + 1]);
  }
  function W(e5, t3) {
    var i3 = 0;
    do {
      i3 |= 1 & e5, e5 >>>= 1, i3 <<= 1;
    } while (--t3 > 0);
    return i3 >>> 1;
  }
  function q(e5) {
    16 === e5.bi_valid ? (G(e5, e5.bi_buf), e5.bi_buf = 0, e5.bi_valid = 0) : e5.bi_valid >= 8 && (e5.pending_buf[e5.pending++] = 255 & e5.bi_buf, e5.bi_buf >>= 8, e5.bi_valid -= 8);
  }
  function V(e5, t3) {
    var i3, r3, n3, a3, o3, s3, l3 = t3.dyn_tree, u3 = t3.max_code, h3 = t3.stat_desc.static_tree, c3 = t3.stat_desc.has_stree, f3 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p3 = t3.stat_desc.max_length, m2 = 0;
    for (a3 = 0; a3 <= w; a3++)
      e5.bl_count[a3] = 0;
    for (l3[2 * e5.heap[e5.heap_max] + 1] = 0, i3 = e5.heap_max + 1; i3 < y2; i3++)
      (a3 = l3[2 * l3[2 * (r3 = e5.heap[i3]) + 1] + 1] + 1) > p3 && (a3 = p3, m2++), l3[2 * r3 + 1] = a3, r3 > u3 || (e5.bl_count[a3]++, o3 = 0, r3 >= d2 && (o3 = f3[r3 - d2]), s3 = l3[2 * r3], e5.opt_len += s3 * (a3 + o3), c3 && (e5.static_len += s3 * (h3[2 * r3 + 1] + o3)));
    if (0 !== m2) {
      do {
        for (a3 = p3 - 1; 0 === e5.bl_count[a3]; )
          a3--;
        e5.bl_count[a3]--, e5.bl_count[a3 + 1] += 2, e5.bl_count[p3]--, m2 -= 2;
      } while (m2 > 0);
      for (a3 = p3; 0 !== a3; a3--)
        for (r3 = e5.bl_count[a3]; 0 !== r3; )
          (n3 = e5.heap[--i3]) > u3 || (l3[2 * n3 + 1] !== a3 && (e5.opt_len += (a3 - l3[2 * n3 + 1]) * l3[2 * n3], l3[2 * n3 + 1] = a3), r3--);
    }
  }
  function Y2(e5, t3, i3) {
    var r3, n3, a3 = new Array(w + 1), o3 = 0;
    for (r3 = 1; r3 <= w; r3++)
      a3[r3] = o3 = o3 + i3[r3 - 1] << 1;
    for (n3 = 0; n3 <= t3; n3++) {
      var s3 = e5[2 * n3 + 1];
      0 !== s3 && (e5[2 * n3] = W(a3[s3]++, s3));
    }
  }
  function K() {
    var e5, t3, i3, r3, n3, a3 = new Array(w + 1);
    for (i3 = 0, r3 = 0; r3 < p2 - 1; r3++)
      for (N2[r3] = i3, e5 = 0; e5 < 1 << I[r3]; e5++)
        F[i3++] = r3;
    for (F[i3 - 1] = r3, n3 = 0, r3 = 0; r3 < 16; r3++)
      for (L2[r3] = n3, e5 = 0; e5 < 1 << M2[r3]; e5++)
        z2[n3++] = r3;
    for (n3 >>= 7; r3 < g; r3++)
      for (L2[r3] = n3 << 7, e5 = 0; e5 < 1 << M2[r3] - 7; e5++)
        z2[256 + n3++] = r3;
    for (t3 = 0; t3 <= w; t3++)
      a3[t3] = 0;
    for (e5 = 0; e5 <= 143; )
      C2[2 * e5 + 1] = 8, e5++, a3[8]++;
    for (; e5 <= 255; )
      C2[2 * e5 + 1] = 9, e5++, a3[9]++;
    for (; e5 <= 279; )
      C2[2 * e5 + 1] = 7, e5++, a3[7]++;
    for (; e5 <= 287; )
      C2[2 * e5 + 1] = 8, e5++, a3[8]++;
    for (Y2(C2, _2 + 1, a3), e5 = 0; e5 < g; e5++)
      R2[2 * e5 + 1] = 5, R2[2 * e5] = W(e5, 5);
    O2 = new U(C2, I, m + 1, _2, w), D = new U(R2, M2, 0, g, w), $ = new U(new Array(0), T2, 0, b2, x2);
  }
  function J(e5) {
    var t3;
    for (t3 = 0; t3 < _2; t3++)
      e5.dyn_ltree[2 * t3] = 0;
    for (t3 = 0; t3 < g; t3++)
      e5.dyn_dtree[2 * t3] = 0;
    for (t3 = 0; t3 < b2; t3++)
      e5.bl_tree[2 * t3] = 0;
    e5.dyn_ltree[2 * E2] = 1, e5.opt_len = e5.static_len = 0, e5.last_lit = e5.matches = 0;
  }
  function X(e5) {
    e5.bi_valid > 8 ? G(e5, e5.bi_buf) : e5.bi_valid > 0 && (e5.pending_buf[e5.pending++] = e5.bi_buf), e5.bi_buf = 0, e5.bi_valid = 0;
  }
  function ee(e5, t3, i3, n3) {
    X(e5), G(e5, i3), G(e5, ~i3), r2.arraySet(e5.pending_buf, e5.window, t3, i3, e5.pending), e5.pending += i3;
  }
  function te(e5, t3, i3, r3) {
    var n3 = 2 * t3, a3 = 2 * i3;
    return e5[n3] < e5[a3] || e5[n3] === e5[a3] && r3[t3] <= r3[i3];
  }
  function ie(e5, t3, i3) {
    for (var r3 = e5.heap[i3], n3 = i3 << 1; n3 <= e5.heap_len && (n3 < e5.heap_len && te(t3, e5.heap[n3 + 1], e5.heap[n3], e5.depth) && n3++, !te(t3, r3, e5.heap[n3], e5.depth)); )
      e5.heap[i3] = e5.heap[n3], i3 = n3, n3 <<= 1;
    e5.heap[i3] = r3;
  }
  function re(e5, t3, i3) {
    var r3, n3, a3, o3, s3 = 0;
    if (0 !== e5.last_lit)
      do {
        r3 = e5.pending_buf[e5.d_buf + 2 * s3] << 8 | e5.pending_buf[e5.d_buf + 2 * s3 + 1], n3 = e5.pending_buf[e5.l_buf + s3], s3++, 0 === r3 ? Q(e5, n3, t3) : (Q(e5, (a3 = F[n3]) + m + 1, t3), 0 !== (o3 = I[a3]) && H(e5, n3 -= N2[a3], o3), Q(e5, a3 = j(--r3), i3), 0 !== (o3 = M2[a3]) && H(e5, r3 -= L2[a3], o3));
      } while (s3 < e5.last_lit);
    Q(e5, E2, t3);
  }
  function ne(e5, t3) {
    var i3, r3, n3, a3 = t3.dyn_tree, o3 = t3.stat_desc.static_tree, s3 = t3.stat_desc.has_stree, l3 = t3.stat_desc.elems, u3 = -1;
    for (e5.heap_len = 0, e5.heap_max = y2, i3 = 0; i3 < l3; i3++)
      0 !== a3[2 * i3] ? (e5.heap[++e5.heap_len] = u3 = i3, e5.depth[i3] = 0) : a3[2 * i3 + 1] = 0;
    for (; e5.heap_len < 2; )
      a3[2 * (n3 = e5.heap[++e5.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e5.depth[n3] = 0, e5.opt_len--, s3 && (e5.static_len -= o3[2 * n3 + 1]);
    for (t3.max_code = u3, i3 = e5.heap_len >> 1; i3 >= 1; i3--)
      ie(e5, a3, i3);
    n3 = l3;
    do {
      i3 = e5.heap[1], e5.heap[1] = e5.heap[e5.heap_len--], ie(e5, a3, 1), r3 = e5.heap[1], e5.heap[--e5.heap_max] = i3, e5.heap[--e5.heap_max] = r3, a3[2 * n3] = a3[2 * i3] + a3[2 * r3], e5.depth[n3] = (e5.depth[i3] >= e5.depth[r3] ? e5.depth[i3] : e5.depth[r3]) + 1, a3[2 * i3 + 1] = a3[2 * r3 + 1] = n3, e5.heap[1] = n3++, ie(e5, a3, 1);
    } while (e5.heap_len >= 2);
    e5.heap[--e5.heap_max] = e5.heap[1], V(e5, t3), Y2(a3, u3, e5.bl_count);
  }
  function ae(e5, t3, i3) {
    var r3, n3, a3 = -1, o3 = t3[1], s3 = 0, l3 = 7, u3 = 4;
    for (0 === o3 && (l3 = 138, u3 = 3), t3[2 * (i3 + 1) + 1] = 65535, r3 = 0; r3 <= i3; r3++)
      n3 = o3, o3 = t3[2 * (r3 + 1) + 1], ++s3 < l3 && n3 === o3 || (s3 < u3 ? e5.bl_tree[2 * n3] += s3 : 0 !== n3 ? (n3 !== a3 && e5.bl_tree[2 * n3]++, e5.bl_tree[2 * k2]++) : s3 <= 10 ? e5.bl_tree[2 * S2]++ : e5.bl_tree[2 * A2]++, s3 = 0, a3 = n3, 0 === o3 ? (l3 = 138, u3 = 3) : n3 === o3 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4));
  }
  function oe(e5, t3, i3) {
    var r3, n3, a3 = -1, o3 = t3[1], s3 = 0, l3 = 7, u3 = 4;
    for (0 === o3 && (l3 = 138, u3 = 3), r3 = 0; r3 <= i3; r3++)
      if (n3 = o3, o3 = t3[2 * (r3 + 1) + 1], !(++s3 < l3 && n3 === o3)) {
        if (s3 < u3)
          do {
            Q(e5, n3, e5.bl_tree);
          } while (0 != --s3);
        else
          0 !== n3 ? (n3 !== a3 && (Q(e5, n3, e5.bl_tree), s3--), Q(e5, k2, e5.bl_tree), H(e5, s3 - 3, 2)) : s3 <= 10 ? (Q(e5, S2, e5.bl_tree), H(e5, s3 - 3, 3)) : (Q(e5, A2, e5.bl_tree), H(e5, s3 - 11, 7));
        s3 = 0, a3 = n3, 0 === o3 ? (l3 = 138, u3 = 3) : n3 === o3 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4);
      }
  }
  function se(e5) {
    var t3;
    for (ae(e5, e5.dyn_ltree, e5.l_desc.max_code), ae(e5, e5.dyn_dtree, e5.d_desc.max_code), ne(e5, e5.bl_desc), t3 = b2 - 1; t3 >= 3 && 0 === e5.bl_tree[2 * P[t3] + 1]; t3--)
      ;
    return e5.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
  }
  function le(e5, t3, i3, r3) {
    var n3;
    for (H(e5, t3 - 257, 5), H(e5, i3 - 1, 5), H(e5, r3 - 4, 4), n3 = 0; n3 < r3; n3++)
      H(e5, e5.bl_tree[2 * P[n3] + 1], 3);
    oe(e5, e5.dyn_ltree, t3 - 1), oe(e5, e5.dyn_dtree, i3 - 1);
  }
  function ue(e5) {
    var t3, i3 = 4093624447;
    for (t3 = 0; t3 <= 31; t3++, i3 >>>= 1)
      if (1 & i3 && 0 !== e5.dyn_ltree[2 * t3])
        return a2;
    if (0 !== e5.dyn_ltree[18] || 0 !== e5.dyn_ltree[20] || 0 !== e5.dyn_ltree[26])
      return o2;
    for (t3 = 32; t3 < m; t3++)
      if (0 !== e5.dyn_ltree[2 * t3])
        return o2;
    return a2;
  }
  l2(L2);
  var he = false;
  function ce(e5) {
    he || (K(), he = true), e5.l_desc = new Z(e5.dyn_ltree, O2), e5.d_desc = new Z(e5.dyn_dtree, D), e5.bl_desc = new Z(e5.bl_tree, $), e5.bi_buf = 0, e5.bi_valid = 0, J(e5);
  }
  function fe(e5, t3, i3, r3) {
    H(e5, (u2 << 1) + (r3 ? 1 : 0), 3), ee(e5, t3, i3);
  }
  function de(e5) {
    H(e5, h2 << 1, 3), Q(e5, E2, C2), q(e5);
  }
  function pe(e5, t3, i3, r3) {
    var a3, o3, l3 = 0;
    e5.level > 0 ? (e5.strm.data_type === s2 && (e5.strm.data_type = ue(e5)), ne(e5, e5.l_desc), ne(e5, e5.d_desc), l3 = se(e5), a3 = e5.opt_len + 3 + 7 >>> 3, (o3 = e5.static_len + 3 + 7 >>> 3) <= a3 && (a3 = o3)) : a3 = o3 = i3 + 5, i3 + 4 <= a3 && -1 !== t3 ? fe(e5, t3, i3, r3) : e5.strategy === n2 || o3 === a3 ? (H(e5, (h2 << 1) + (r3 ? 1 : 0), 3), re(e5, C2, R2)) : (H(e5, (c2 << 1) + (r3 ? 1 : 0), 3), le(e5, e5.l_desc.max_code + 1, e5.d_desc.max_code + 1, l3 + 1), re(e5, e5.dyn_ltree, e5.dyn_dtree)), J(e5), r3 && X(e5);
  }
  function me(e5, t3, i3) {
    return e5.pending_buf[e5.d_buf + 2 * e5.last_lit] = t3 >>> 8 & 255, e5.pending_buf[e5.d_buf + 2 * e5.last_lit + 1] = 255 & t3, e5.pending_buf[e5.l_buf + e5.last_lit] = 255 & i3, e5.last_lit++, 0 === t3 ? e5.dyn_ltree[2 * i3]++ : (e5.matches++, t3--, e5.dyn_ltree[2 * (F[i3] + m + 1)]++, e5.dyn_dtree[2 * j(t3)]++), e5.last_lit === e5.lit_bufsize - 1;
  }
  i2._tr_init = ce, i2._tr_stored_block = fe, i2._tr_flush_block = pe, i2._tr_tally = me, i2._tr_align = de;
}, { "../utils/common": 52 }], 62: [function(e4, t2, i2) {
  function r2() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }
  t2.exports = r2;
}, {}], 63: [function(e4, t2, i2) {
  var r2, n2, a2 = t2.exports = {};
  function o2() {
    throw new Error("setTimeout has not been defined");
  }
  function s2() {
    throw new Error("clearTimeout has not been defined");
  }
  function l2(e5) {
    if (r2 === setTimeout)
      return setTimeout(e5, 0);
    if ((r2 === o2 || !r2) && setTimeout)
      return r2 = setTimeout, setTimeout(e5, 0);
    try {
      return r2(e5, 0);
    } catch (t3) {
      try {
        return r2.call(null, e5, 0);
      } catch (t4) {
        return r2.call(this, e5, 0);
      }
    }
  }
  function u2(e5) {
    if (n2 === clearTimeout)
      return clearTimeout(e5);
    if ((n2 === s2 || !n2) && clearTimeout)
      return n2 = clearTimeout, clearTimeout(e5);
    try {
      return n2(e5);
    } catch (t3) {
      try {
        return n2.call(null, e5);
      } catch (t4) {
        return n2.call(this, e5);
      }
    }
  }
  !function() {
    try {
      r2 = "function" == typeof setTimeout ? setTimeout : o2;
    } catch (e5) {
      r2 = o2;
    }
    try {
      n2 = "function" == typeof clearTimeout ? clearTimeout : s2;
    } catch (e5) {
      n2 = s2;
    }
  }();
  var h2, c2 = [], f2 = false, d = -1;
  function p2() {
    f2 && h2 && (f2 = false, h2.length ? c2 = h2.concat(c2) : d = -1, c2.length && m());
  }
  function m() {
    if (!f2) {
      var e5 = l2(p2);
      f2 = true;
      for (var t3 = c2.length; t3; ) {
        for (h2 = c2, c2 = []; ++d < t3; )
          h2 && h2[d].run();
        d = -1, t3 = c2.length;
      }
      h2 = null, f2 = false, u2(e5);
    }
  }
  function _2(e5, t3) {
    this.fun = e5, this.array = t3;
  }
  function g() {
  }
  a2.nextTick = function(e5) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var i3 = 1; i3 < arguments.length; i3++)
        t3[i3 - 1] = arguments[i3];
    c2.push(new _2(e5, t3)), 1 !== c2.length || f2 || l2(m);
  }, _2.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, a2.title = "browser", a2.browser = true, a2.env = {}, a2.argv = [], a2.version = "", a2.versions = {}, a2.on = g, a2.addListener = g, a2.once = g, a2.off = g, a2.removeListener = g, a2.removeAllListeners = g, a2.emit = g, a2.prependListener = g, a2.prependOnceListener = g, a2.listeners = function(e5) {
    return [];
  }, a2.binding = function(e5) {
    throw new Error("process.binding is not supported");
  }, a2.cwd = function() {
    return "/";
  }, a2.chdir = function(e5) {
    throw new Error("process.chdir is not supported");
  }, a2.umask = function() {
    return 0;
  };
}, {}], 64: [function(e4, t2, i2) {
  var r2 = e4("buffer"), n2 = r2.Buffer;
  function a2(e5, t3) {
    for (var i3 in e5)
      t3[i3] = e5[i3];
  }
  function o2(e5, t3, i3) {
    return n2(e5, t3, i3);
  }
  n2.from && n2.alloc && n2.allocUnsafe && n2.allocUnsafeSlow ? t2.exports = r2 : (a2(r2, i2), i2.Buffer = o2), o2.prototype = Object.create(n2.prototype), a2(n2, o2), o2.from = function(e5, t3, i3) {
    if ("number" == typeof e5)
      throw new TypeError("Argument must not be a number");
    return n2(e5, t3, i3);
  }, o2.alloc = function(e5, t3, i3) {
    if ("number" != typeof e5)
      throw new TypeError("Argument must be a number");
    var r3 = n2(e5);
    return void 0 !== t3 ? "string" == typeof i3 ? r3.fill(t3, i3) : r3.fill(t3) : r3.fill(0), r3;
  }, o2.allocUnsafe = function(e5) {
    if ("number" != typeof e5)
      throw new TypeError("Argument must be a number");
    return n2(e5);
  }, o2.allocUnsafeSlow = function(e5) {
    if ("number" != typeof e5)
      throw new TypeError("Argument must be a number");
    return r2.SlowBuffer(e5);
  };
}, { buffer: 32 }], 65: [function(e4, t2, i2) {
  t2.exports = n2;
  var r2 = e4("events").EventEmitter;
  function n2() {
    r2.call(this);
  }
  e4("inherits")(n2, r2), n2.Readable = e4("readable-stream/lib/_stream_readable.js"), n2.Writable = e4("readable-stream/lib/_stream_writable.js"), n2.Duplex = e4("readable-stream/lib/_stream_duplex.js"), n2.Transform = e4("readable-stream/lib/_stream_transform.js"), n2.PassThrough = e4("readable-stream/lib/_stream_passthrough.js"), n2.finished = e4("readable-stream/lib/internal/streams/end-of-stream.js"), n2.pipeline = e4("readable-stream/lib/internal/streams/pipeline.js"), n2.Stream = n2, n2.prototype.pipe = function(e5, t3) {
    var i3 = this;
    function n3(t4) {
      e5.writable && false === e5.write(t4) && i3.pause && i3.pause();
    }
    function a2() {
      i3.readable && i3.resume && i3.resume();
    }
    i3.on("data", n3), e5.on("drain", a2), e5._isStdio || t3 && false === t3.end || (i3.on("end", s2), i3.on("close", l2));
    var o2 = false;
    function s2() {
      o2 || (o2 = true, e5.end());
    }
    function l2() {
      o2 || (o2 = true, "function" == typeof e5.destroy && e5.destroy());
    }
    function u2(e6) {
      if (h2(), 0 === r2.listenerCount(this, "error"))
        throw e6;
    }
    function h2() {
      i3.removeListener("data", n3), e5.removeListener("drain", a2), i3.removeListener("end", s2), i3.removeListener("close", l2), i3.removeListener("error", u2), e5.removeListener("error", u2), i3.removeListener("end", h2), i3.removeListener("close", h2), e5.removeListener("close", h2);
    }
    return i3.on("error", u2), e5.on("error", u2), i3.on("end", h2), i3.on("close", h2), e5.on("close", h2), e5.emit("pipe", i3), e5;
  };
}, { events: 35, inherits: 46, "readable-stream/lib/_stream_duplex.js": 67, "readable-stream/lib/_stream_passthrough.js": 68, "readable-stream/lib/_stream_readable.js": 69, "readable-stream/lib/_stream_transform.js": 70, "readable-stream/lib/_stream_writable.js": 71, "readable-stream/lib/internal/streams/end-of-stream.js": 75, "readable-stream/lib/internal/streams/pipeline.js": 77 }], 66: [function(e4, t2, i2) {
  function r2(e5, t3) {
    e5.prototype = Object.create(t3.prototype), e5.prototype.constructor = e5, e5.__proto__ = t3;
  }
  var n2 = {};
  function a2(e5, t3, i3) {
    function a3(e6, i4, r3) {
      return "string" == typeof t3 ? t3 : t3(e6, i4, r3);
    }
    i3 || (i3 = Error);
    var o3 = function(e6) {
      function t4(t5, i4, r3) {
        return e6.call(this, a3(t5, i4, r3)) || this;
      }
      return r2(t4, e6), t4;
    }(i3);
    o3.prototype.name = i3.name, o3.prototype.code = e5, n2[e5] = o3;
  }
  function o2(e5, t3) {
    if (Array.isArray(e5)) {
      var i3 = e5.length;
      return e5 = e5.map(function(e6) {
        return String(e6);
      }), i3 > 2 ? "one of ".concat(t3, " ").concat(e5.slice(0, i3 - 1).join(", "), ", or ") + e5[i3 - 1] : 2 === i3 ? "one of ".concat(t3, " ").concat(e5[0], " or ").concat(e5[1]) : "of ".concat(t3, " ").concat(e5[0]);
    }
    return "of ".concat(t3, " ").concat(String(e5));
  }
  function s2(e5, t3, i3) {
    return e5.substr(0, t3.length) === t3;
  }
  function l2(e5, t3, i3) {
    return (void 0 === i3 || i3 > e5.length) && (i3 = e5.length), e5.substring(i3 - t3.length, i3) === t3;
  }
  function u2(e5, t3, i3) {
    return "number" != typeof i3 && (i3 = 0), !(i3 + t3.length > e5.length) && -1 !== e5.indexOf(t3, i3);
  }
  a2("ERR_INVALID_OPT_VALUE", function(e5, t3) {
    return 'The value "' + t3 + '" is invalid for option "' + e5 + '"';
  }, TypeError), a2("ERR_INVALID_ARG_TYPE", function(e5, t3, i3) {
    var r3, n3;
    if ("string" == typeof t3 && s2(t3, "not ") ? (r3 = "must not be", t3 = t3.replace(/^not /, "")) : r3 = "must be", l2(e5, " argument"))
      n3 = "The ".concat(e5, " ").concat(r3, " ").concat(o2(t3, "type"));
    else {
      var a3 = u2(e5, ".") ? "property" : "argument";
      n3 = 'The "'.concat(e5, '" ').concat(a3, " ").concat(r3, " ").concat(o2(t3, "type"));
    }
    return n3 += ". Received type ".concat(typeof i3);
  }, TypeError), a2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), a2("ERR_METHOD_NOT_IMPLEMENTED", function(e5) {
    return "The " + e5 + " method is not implemented";
  }), a2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), a2("ERR_STREAM_DESTROYED", function(e5) {
    return "Cannot call " + e5 + " after a stream was destroyed";
  }), a2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), a2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), a2("ERR_STREAM_WRITE_AFTER_END", "write after end"), a2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), a2("ERR_UNKNOWN_ENCODING", function(e5) {
    return "Unknown encoding: " + e5;
  }, TypeError), a2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t2.exports.codes = n2;
}, {}], 67: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      var r2 = Object.keys || function(e5) {
        var t3 = [];
        for (var i4 in e5)
          t3.push(i4);
        return t3;
      };
      t2.exports = u2;
      var n2 = e4("./_stream_readable"), a2 = e4("./_stream_writable");
      e4("inherits")(u2, n2);
      for (var o2 = r2(a2.prototype), s2 = 0; s2 < o2.length; s2++) {
        var l2 = o2[s2];
        u2.prototype[l2] || (u2.prototype[l2] = a2.prototype[l2]);
      }
      function u2(e5) {
        if (!(this instanceof u2))
          return new u2(e5);
        n2.call(this, e5), a2.call(this, e5), this.allowHalfOpen = true, e5 && (false === e5.readable && (this.readable = false), false === e5.writable && (this.writable = false), false === e5.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", h2)));
      }
      function h2() {
        this._writableState.ended || i3.nextTick(c2, this);
      }
      function c2(e5) {
        e5.end();
      }
      Object.defineProperty(u2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), Object.defineProperty(u2.prototype, "writableBuffer", { enumerable: false, get: function() {
        return this._writableState && this._writableState.getBuffer();
      } }), Object.defineProperty(u2.prototype, "writableLength", { enumerable: false, get: function() {
        return this._writableState.length;
      } }), Object.defineProperty(u2.prototype, "destroyed", { enumerable: false, get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
      }, set: function(e5) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e5, this._writableState.destroyed = e5);
      } });
    }).call(this);
  }).call(this, e4("_process"));
}, { "./_stream_readable": 69, "./_stream_writable": 71, _process: 63, inherits: 46 }], 68: [function(e4, t2, i2) {
  t2.exports = n2;
  var r2 = e4("./_stream_transform");
  function n2(e5) {
    if (!(this instanceof n2))
      return new n2(e5);
    r2.call(this, e5);
  }
  e4("inherits")(n2, r2), n2.prototype._transform = function(e5, t3, i3) {
    i3(null, e5);
  };
}, { "./_stream_transform": 70, inherits: 46 }], 69: [function(e4, t2, i2) {
  (function(i3, r2) {
    (function() {
      var n2;
      t2.exports = M2, M2.ReadableState = I, e4("events").EventEmitter;
      var a2 = function(e5, t3) {
        return e5.listeners(t3).length;
      }, o2 = e4("./internal/streams/stream"), s2 = e4("buffer").Buffer, l2 = r2.Uint8Array || function() {
      };
      function u2(e5) {
        return s2.from(e5);
      }
      function h2(e5) {
        return s2.isBuffer(e5) || e5 instanceof l2;
      }
      var c2, f2 = e4("util");
      c2 = f2 && f2.debuglog ? f2.debuglog("stream") : function() {
      };
      var d, p2, m, _2 = e4("./internal/streams/buffer_list"), g = e4("./internal/streams/destroy"), b2 = e4("./internal/streams/state").getHighWaterMark, y2 = e4("../errors").codes, w = y2.ERR_INVALID_ARG_TYPE, v2 = y2.ERR_STREAM_PUSH_AFTER_EOF, x2 = y2.ERR_METHOD_NOT_IMPLEMENTED, E2 = y2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      e4("inherits")(M2, o2);
      var k2 = g.errorOrDestroy, S2 = ["error", "close", "destroy", "pause", "resume"];
      function A2(e5, t3, i4) {
        if ("function" == typeof e5.prependListener)
          return e5.prependListener(t3, i4);
        e5._events && e5._events[t3] ? Array.isArray(e5._events[t3]) ? e5._events[t3].unshift(i4) : e5._events[t3] = [i4, e5._events[t3]] : e5.on(t3, i4);
      }
      function I(t3, i4, r3) {
        n2 = n2 || e4("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = i4 instanceof n2), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.readableObjectMode), this.highWaterMark = b2(this, t3, "readableHighWaterMark", r3), this.buffer = new _2(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.destroyed = false, this.defaultEncoding = t3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t3.encoding && (d || (d = e4("string_decoder/").StringDecoder), this.decoder = new d(t3.encoding), this.encoding = t3.encoding);
      }
      function M2(t3) {
        if (n2 = n2 || e4("./_stream_duplex"), !(this instanceof M2))
          return new M2(t3);
        var i4 = this instanceof n2;
        this._readableState = new I(t3, this, i4), this.readable = true, t3 && ("function" == typeof t3.read && (this._read = t3.read), "function" == typeof t3.destroy && (this._destroy = t3.destroy)), o2.call(this);
      }
      function T2(e5, t3, i4, r3, n3) {
        c2("readableAddChunk", t3);
        var a3, o3 = e5._readableState;
        if (null === t3)
          o3.reading = false, F(e5, o3);
        else if (n3 || (a3 = B2(o3, t3)), a3)
          k2(e5, a3);
        else if (o3.objectMode || t3 && t3.length > 0)
          if ("string" == typeof t3 || o3.objectMode || Object.getPrototypeOf(t3) === s2.prototype || (t3 = u2(t3)), r3)
            o3.endEmitted ? k2(e5, new E2()) : P(e5, o3, t3, true);
          else if (o3.ended)
            k2(e5, new v2());
          else {
            if (o3.destroyed)
              return false;
            o3.reading = false, o3.decoder && !i4 ? (t3 = o3.decoder.write(t3), o3.objectMode || 0 !== t3.length ? P(e5, o3, t3, false) : D(e5, o3)) : P(e5, o3, t3, false);
          }
        else
          r3 || (o3.reading = false, D(e5, o3));
        return !o3.ended && (o3.length < o3.highWaterMark || 0 === o3.length);
      }
      function P(e5, t3, i4, r3) {
        t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e5.emit("data", i4)) : (t3.length += t3.objectMode ? 1 : i4.length, r3 ? t3.buffer.unshift(i4) : t3.buffer.push(i4), t3.needReadable && N2(e5)), D(e5, t3);
      }
      function B2(e5, t3) {
        var i4;
        return h2(t3) || "string" == typeof t3 || void 0 === t3 || e5.objectMode || (i4 = new w("chunk", ["string", "Buffer", "Uint8Array"], t3)), i4;
      }
      Object.defineProperty(M2.prototype, "destroyed", { enumerable: false, get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed;
      }, set: function(e5) {
        this._readableState && (this._readableState.destroyed = e5);
      } }), M2.prototype.destroy = g.destroy, M2.prototype._undestroy = g.undestroy, M2.prototype._destroy = function(e5, t3) {
        t3(e5);
      }, M2.prototype.push = function(e5, t3) {
        var i4, r3 = this._readableState;
        return r3.objectMode ? i4 = true : "string" == typeof e5 && ((t3 = t3 || r3.defaultEncoding) !== r3.encoding && (e5 = s2.from(e5, t3), t3 = ""), i4 = true), T2(this, e5, t3, false, i4);
      }, M2.prototype.unshift = function(e5) {
        return T2(this, e5, null, true, false);
      }, M2.prototype.isPaused = function() {
        return false === this._readableState.flowing;
      }, M2.prototype.setEncoding = function(t3) {
        d || (d = e4("string_decoder/").StringDecoder);
        var i4 = new d(t3);
        this._readableState.decoder = i4, this._readableState.encoding = this._readableState.decoder.encoding;
        for (var r3 = this._readableState.buffer.head, n3 = ""; null !== r3; )
          n3 += i4.write(r3.data), r3 = r3.next;
        return this._readableState.buffer.clear(), "" !== n3 && this._readableState.buffer.push(n3), this._readableState.length = n3.length, this;
      };
      var C2 = 1073741824;
      function R2(e5) {
        return e5 >= C2 ? e5 = C2 : (e5--, e5 |= e5 >>> 1, e5 |= e5 >>> 2, e5 |= e5 >>> 4, e5 |= e5 >>> 8, e5 |= e5 >>> 16, e5++), e5;
      }
      function z2(e5, t3) {
        return e5 <= 0 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e5 != e5 ? t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length : (e5 > t3.highWaterMark && (t3.highWaterMark = R2(e5)), e5 <= t3.length ? e5 : t3.ended ? t3.length : (t3.needReadable = true, 0));
      }
      function F(e5, t3) {
        if (c2("onEofChunk"), !t3.ended) {
          if (t3.decoder) {
            var i4 = t3.decoder.end();
            i4 && i4.length && (t3.buffer.push(i4), t3.length += t3.objectMode ? 1 : i4.length);
          }
          t3.ended = true, t3.sync ? N2(e5) : (t3.needReadable = false, t3.emittedReadable || (t3.emittedReadable = true, O2(e5)));
        }
      }
      function N2(e5) {
        var t3 = e5._readableState;
        c2("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (c2("emitReadable", t3.flowing), t3.emittedReadable = true, i3.nextTick(O2, e5));
      }
      function O2(e5) {
        var t3 = e5._readableState;
        c2("emitReadable_", t3.destroyed, t3.length, t3.ended), t3.destroyed || !t3.length && !t3.ended || (e5.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, H(e5);
      }
      function D(e5, t3) {
        t3.readingMore || (t3.readingMore = true, i3.nextTick($, e5, t3));
      }
      function $(e5, t3) {
        for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
          var i4 = t3.length;
          if (c2("maybeReadMore read 0"), e5.read(0), i4 === t3.length)
            break;
        }
        t3.readingMore = false;
      }
      function L2(e5) {
        return function() {
          var t3 = e5._readableState;
          c2("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && a2(e5, "data") && (t3.flowing = true, H(e5));
        };
      }
      function U(e5) {
        var t3 = e5._readableState;
        t3.readableListening = e5.listenerCount("readable") > 0, t3.resumeScheduled && !t3.paused ? t3.flowing = true : e5.listenerCount("data") > 0 && e5.resume();
      }
      function Z(e5) {
        c2("readable nexttick read 0"), e5.read(0);
      }
      function j(e5, t3) {
        t3.resumeScheduled || (t3.resumeScheduled = true, i3.nextTick(G, e5, t3));
      }
      function G(e5, t3) {
        c2("resume", t3.reading), t3.reading || e5.read(0), t3.resumeScheduled = false, e5.emit("resume"), H(e5), t3.flowing && !t3.reading && e5.read(0);
      }
      function H(e5) {
        var t3 = e5._readableState;
        for (c2("flow", t3.flowing); t3.flowing && null !== e5.read(); )
          ;
      }
      function Q(e5, t3) {
        return 0 === t3.length ? null : (t3.objectMode ? i4 = t3.buffer.shift() : !e5 || e5 >= t3.length ? (i4 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : i4 = t3.buffer.consume(e5, t3.decoder), i4);
        var i4;
      }
      function W(e5) {
        var t3 = e5._readableState;
        c2("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, i3.nextTick(q, t3, e5));
      }
      function q(e5, t3) {
        if (c2("endReadableNT", e5.endEmitted, e5.length), !e5.endEmitted && 0 === e5.length && (e5.endEmitted = true, t3.readable = false, t3.emit("end"), e5.autoDestroy)) {
          var i4 = t3._writableState;
          (!i4 || i4.autoDestroy && i4.finished) && t3.destroy();
        }
      }
      function V(e5, t3) {
        for (var i4 = 0, r3 = e5.length; i4 < r3; i4++)
          if (e5[i4] === t3)
            return i4;
        return -1;
      }
      M2.prototype.read = function(e5) {
        c2("read", e5), e5 = parseInt(e5, 10);
        var t3 = this._readableState, i4 = e5;
        if (0 !== e5 && (t3.emittedReadable = false), 0 === e5 && t3.needReadable && ((0 !== t3.highWaterMark ? t3.length >= t3.highWaterMark : t3.length > 0) || t3.ended))
          return c2("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? W(this) : N2(this), null;
        if (0 === (e5 = z2(e5, t3)) && t3.ended)
          return 0 === t3.length && W(this), null;
        var r3, n3 = t3.needReadable;
        return c2("need readable", n3), (0 === t3.length || t3.length - e5 < t3.highWaterMark) && c2("length less than watermark", n3 = true), t3.ended || t3.reading ? c2("reading or ended", n3 = false) : n3 && (c2("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, t3.reading || (e5 = z2(i4, t3))), null === (r3 = e5 > 0 ? Q(e5, t3) : null) ? (t3.needReadable = t3.length <= t3.highWaterMark, e5 = 0) : (t3.length -= e5, t3.awaitDrain = 0), 0 === t3.length && (t3.ended || (t3.needReadable = true), i4 !== e5 && t3.ended && W(this)), null !== r3 && this.emit("data", r3), r3;
      }, M2.prototype._read = function(e5) {
        k2(this, new x2("_read()"));
      }, M2.prototype.pipe = function(e5, t3) {
        var r3 = this, n3 = this._readableState;
        switch (n3.pipesCount) {
          case 0:
            n3.pipes = e5;
            break;
          case 1:
            n3.pipes = [n3.pipes, e5];
            break;
          default:
            n3.pipes.push(e5);
        }
        n3.pipesCount += 1, c2("pipe count=%d opts=%j", n3.pipesCount, t3);
        var o3 = t3 && false === t3.end || e5 === i3.stdout || e5 === i3.stderr ? g2 : l3;
        function s3(e6, t4) {
          c2("onunpipe"), e6 === r3 && t4 && false === t4.hasUnpiped && (t4.hasUnpiped = true, f3());
        }
        function l3() {
          c2("onend"), e5.end();
        }
        n3.endEmitted ? i3.nextTick(o3) : r3.once("end", o3), e5.on("unpipe", s3);
        var u3 = L2(r3);
        e5.on("drain", u3);
        var h3 = false;
        function f3() {
          c2("cleanup"), e5.removeListener("close", m2), e5.removeListener("finish", _3), e5.removeListener("drain", u3), e5.removeListener("error", p3), e5.removeListener("unpipe", s3), r3.removeListener("end", l3), r3.removeListener("end", g2), r3.removeListener("data", d2), h3 = true, !n3.awaitDrain || e5._writableState && !e5._writableState.needDrain || u3();
        }
        function d2(t4) {
          c2("ondata");
          var i4 = e5.write(t4);
          c2("dest.write", i4), false === i4 && ((1 === n3.pipesCount && n3.pipes === e5 || n3.pipesCount > 1 && -1 !== V(n3.pipes, e5)) && !h3 && (c2("false write response, pause", n3.awaitDrain), n3.awaitDrain++), r3.pause());
        }
        function p3(t4) {
          c2("onerror", t4), g2(), e5.removeListener("error", p3), 0 === a2(e5, "error") && k2(e5, t4);
        }
        function m2() {
          e5.removeListener("finish", _3), g2();
        }
        function _3() {
          c2("onfinish"), e5.removeListener("close", m2), g2();
        }
        function g2() {
          c2("unpipe"), r3.unpipe(e5);
        }
        return r3.on("data", d2), A2(e5, "error", p3), e5.once("close", m2), e5.once("finish", _3), e5.emit("pipe", r3), n3.flowing || (c2("pipe resume"), r3.resume()), e5;
      }, M2.prototype.unpipe = function(e5) {
        var t3 = this._readableState, i4 = { hasUnpiped: false };
        if (0 === t3.pipesCount)
          return this;
        if (1 === t3.pipesCount)
          return e5 && e5 !== t3.pipes || (e5 || (e5 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e5 && e5.emit("unpipe", this, i4)), this;
        if (!e5) {
          var r3 = t3.pipes, n3 = t3.pipesCount;
          t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
          for (var a3 = 0; a3 < n3; a3++)
            r3[a3].emit("unpipe", this, { hasUnpiped: false });
          return this;
        }
        var o3 = V(t3.pipes, e5);
        return -1 === o3 || (t3.pipes.splice(o3, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e5.emit("unpipe", this, i4)), this;
      }, M2.prototype.on = function(e5, t3) {
        var r3 = o2.prototype.on.call(this, e5, t3), n3 = this._readableState;
        return "data" === e5 ? (n3.readableListening = this.listenerCount("readable") > 0, false !== n3.flowing && this.resume()) : "readable" === e5 && (n3.endEmitted || n3.readableListening || (n3.readableListening = n3.needReadable = true, n3.flowing = false, n3.emittedReadable = false, c2("on readable", n3.length, n3.reading), n3.length ? N2(this) : n3.reading || i3.nextTick(Z, this))), r3;
      }, M2.prototype.addListener = M2.prototype.on, M2.prototype.removeListener = function(e5, t3) {
        var r3 = o2.prototype.removeListener.call(this, e5, t3);
        return "readable" === e5 && i3.nextTick(U, this), r3;
      }, M2.prototype.removeAllListeners = function(e5) {
        var t3 = o2.prototype.removeAllListeners.apply(this, arguments);
        return "readable" !== e5 && void 0 !== e5 || i3.nextTick(U, this), t3;
      }, M2.prototype.resume = function() {
        var e5 = this._readableState;
        return e5.flowing || (c2("resume"), e5.flowing = !e5.readableListening, j(this, e5)), e5.paused = false, this;
      }, M2.prototype.pause = function() {
        return c2("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (c2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
      }, M2.prototype.wrap = function(e5) {
        var t3 = this, i4 = this._readableState, r3 = false;
        for (var n3 in e5.on("end", function() {
          if (c2("wrapped end"), i4.decoder && !i4.ended) {
            var e6 = i4.decoder.end();
            e6 && e6.length && t3.push(e6);
          }
          t3.push(null);
        }), e5.on("data", function(n4) {
          c2("wrapped data"), i4.decoder && (n4 = i4.decoder.write(n4)), i4.objectMode && null == n4 || (i4.objectMode || n4 && n4.length) && (t3.push(n4) || (r3 = true, e5.pause()));
        }), e5)
          void 0 === this[n3] && "function" == typeof e5[n3] && (this[n3] = function(t4) {
            return function() {
              return e5[t4].apply(e5, arguments);
            };
          }(n3));
        for (var a3 = 0; a3 < S2.length; a3++)
          e5.on(S2[a3], this.emit.bind(this, S2[a3]));
        return this._read = function(t4) {
          c2("wrapped _read", t4), r3 && (r3 = false, e5.resume());
        }, this;
      }, "function" == typeof Symbol && (M2.prototype[Symbol.asyncIterator] = function() {
        return void 0 === p2 && (p2 = e4("./internal/streams/async_iterator")), p2(this);
      }), Object.defineProperty(M2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
        return this._readableState.highWaterMark;
      } }), Object.defineProperty(M2.prototype, "readableBuffer", { enumerable: false, get: function() {
        return this._readableState && this._readableState.buffer;
      } }), Object.defineProperty(M2.prototype, "readableFlowing", { enumerable: false, get: function() {
        return this._readableState.flowing;
      }, set: function(e5) {
        this._readableState && (this._readableState.flowing = e5);
      } }), M2._fromList = Q, Object.defineProperty(M2.prototype, "readableLength", { enumerable: false, get: function() {
        return this._readableState.length;
      } }), "function" == typeof Symbol && (M2.from = function(t3, i4) {
        return void 0 === m && (m = e4("./internal/streams/from")), m(M2, t3, i4);
      });
    }).call(this);
  }).call(this, e4("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/async_iterator": 72, "./internal/streams/buffer_list": 73, "./internal/streams/destroy": 74, "./internal/streams/from": 76, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, events: 35, inherits: 46, "string_decoder/": 80, util: 29 }], 70: [function(e4, t2, i2) {
  t2.exports = h2;
  var r2 = e4("../errors").codes, n2 = r2.ERR_METHOD_NOT_IMPLEMENTED, a2 = r2.ERR_MULTIPLE_CALLBACK, o2 = r2.ERR_TRANSFORM_ALREADY_TRANSFORMING, s2 = r2.ERR_TRANSFORM_WITH_LENGTH_0, l2 = e4("./_stream_duplex");
  function u2(e5, t3) {
    var i3 = this._transformState;
    i3.transforming = false;
    var r3 = i3.writecb;
    if (null === r3)
      return this.emit("error", new a2());
    i3.writechunk = null, i3.writecb = null, null != t3 && this.push(t3), r3(e5);
    var n3 = this._readableState;
    n3.reading = false, (n3.needReadable || n3.length < n3.highWaterMark) && this._read(n3.highWaterMark);
  }
  function h2(e5) {
    if (!(this instanceof h2))
      return new h2(e5);
    l2.call(this, e5), this._transformState = { afterTransform: u2.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e5 && ("function" == typeof e5.transform && (this._transform = e5.transform), "function" == typeof e5.flush && (this._flush = e5.flush)), this.on("prefinish", c2);
  }
  function c2() {
    var e5 = this;
    "function" != typeof this._flush || this._readableState.destroyed ? f2(this, null, null) : this._flush(function(t3, i3) {
      f2(e5, t3, i3);
    });
  }
  function f2(e5, t3, i3) {
    if (t3)
      return e5.emit("error", t3);
    if (null != i3 && e5.push(i3), e5._writableState.length)
      throw new s2();
    if (e5._transformState.transforming)
      throw new o2();
    return e5.push(null);
  }
  e4("inherits")(h2, l2), h2.prototype.push = function(e5, t3) {
    return this._transformState.needTransform = false, l2.prototype.push.call(this, e5, t3);
  }, h2.prototype._transform = function(e5, t3, i3) {
    i3(new n2("_transform()"));
  }, h2.prototype._write = function(e5, t3, i3) {
    var r3 = this._transformState;
    if (r3.writecb = i3, r3.writechunk = e5, r3.writeencoding = t3, !r3.transforming) {
      var n3 = this._readableState;
      (r3.needTransform || n3.needReadable || n3.length < n3.highWaterMark) && this._read(n3.highWaterMark);
    }
  }, h2.prototype._read = function(e5) {
    var t3 = this._transformState;
    null === t3.writechunk || t3.transforming ? t3.needTransform = true : (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform));
  }, h2.prototype._destroy = function(e5, t3) {
    l2.prototype._destroy.call(this, e5, function(e6) {
      t3(e6);
    });
  };
}, { "../errors": 66, "./_stream_duplex": 67, inherits: 46 }], 71: [function(e4, t2, i2) {
  (function(i3, r2) {
    (function() {
      function n2(e5) {
        var t3 = this;
        this.next = null, this.entry = null, this.finish = function() {
          G(t3, e5);
        };
      }
      var a2;
      t2.exports = I, I.WritableState = A2;
      var o2 = { deprecate: e4("util-deprecate") }, s2 = e4("./internal/streams/stream"), l2 = e4("buffer").Buffer, u2 = r2.Uint8Array || function() {
      };
      function h2(e5) {
        return l2.from(e5);
      }
      function c2(e5) {
        return l2.isBuffer(e5) || e5 instanceof u2;
      }
      var f2, d = e4("./internal/streams/destroy"), p2 = e4("./internal/streams/state").getHighWaterMark, m = e4("../errors").codes, _2 = m.ERR_INVALID_ARG_TYPE, g = m.ERR_METHOD_NOT_IMPLEMENTED, b2 = m.ERR_MULTIPLE_CALLBACK, y2 = m.ERR_STREAM_CANNOT_PIPE, w = m.ERR_STREAM_DESTROYED, v2 = m.ERR_STREAM_NULL_VALUES, x2 = m.ERR_STREAM_WRITE_AFTER_END, E2 = m.ERR_UNKNOWN_ENCODING, k2 = d.errorOrDestroy;
      function S2() {
      }
      function A2(t3, i4, r3) {
        a2 = a2 || e4("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = i4 instanceof a2), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.writableObjectMode), this.highWaterMark = p2(this, t3, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
        var o3 = false === t3.decodeStrings;
        this.decodeStrings = !o3, this.defaultEncoding = t3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e5) {
          F(i4, e5);
        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n2(this);
      }
      function I(t3) {
        var i4 = this instanceof (a2 = a2 || e4("./_stream_duplex"));
        if (!i4 && !f2.call(I, this))
          return new I(t3);
        this._writableState = new A2(t3, this, i4), this.writable = true, t3 && ("function" == typeof t3.write && (this._write = t3.write), "function" == typeof t3.writev && (this._writev = t3.writev), "function" == typeof t3.destroy && (this._destroy = t3.destroy), "function" == typeof t3.final && (this._final = t3.final)), s2.call(this);
      }
      function M2(e5, t3) {
        var r3 = new x2();
        k2(e5, r3), i3.nextTick(t3, r3);
      }
      function T2(e5, t3, r3, n3) {
        var a3;
        return null === r3 ? a3 = new v2() : "string" == typeof r3 || t3.objectMode || (a3 = new _2("chunk", ["string", "Buffer"], r3)), !a3 || (k2(e5, a3), i3.nextTick(n3, a3), false);
      }
      function P(e5, t3, i4) {
        return e5.objectMode || false === e5.decodeStrings || "string" != typeof t3 || (t3 = l2.from(t3, i4)), t3;
      }
      function B2(e5, t3, i4, r3, n3, a3) {
        if (!i4) {
          var o3 = P(t3, r3, n3);
          r3 !== o3 && (i4 = true, n3 = "buffer", r3 = o3);
        }
        var s3 = t3.objectMode ? 1 : r3.length;
        t3.length += s3;
        var l3 = t3.length < t3.highWaterMark;
        if (l3 || (t3.needDrain = true), t3.writing || t3.corked) {
          var u3 = t3.lastBufferedRequest;
          t3.lastBufferedRequest = { chunk: r3, encoding: n3, isBuf: i4, callback: a3, next: null }, u3 ? u3.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
        } else
          C2(e5, t3, false, s3, r3, n3, a3);
        return l3;
      }
      function C2(e5, t3, i4, r3, n3, a3, o3) {
        t3.writelen = r3, t3.writecb = o3, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new w("write")) : i4 ? e5._writev(n3, t3.onwrite) : e5._write(n3, a3, t3.onwrite), t3.sync = false;
      }
      function R2(e5, t3, r3, n3, a3) {
        --t3.pendingcb, r3 ? (i3.nextTick(a3, n3), i3.nextTick(Z, e5, t3), e5._writableState.errorEmitted = true, k2(e5, n3)) : (a3(n3), e5._writableState.errorEmitted = true, k2(e5, n3), Z(e5, t3));
      }
      function z2(e5) {
        e5.writing = false, e5.writecb = null, e5.length -= e5.writelen, e5.writelen = 0;
      }
      function F(e5, t3) {
        var r3 = e5._writableState, n3 = r3.sync, a3 = r3.writecb;
        if ("function" != typeof a3)
          throw new b2();
        if (z2(r3), t3)
          R2(e5, r3, n3, t3, a3);
        else {
          var o3 = $(r3) || e5.destroyed;
          o3 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || D(e5, r3), n3 ? i3.nextTick(N2, e5, r3, o3, a3) : N2(e5, r3, o3, a3);
        }
      }
      function N2(e5, t3, i4, r3) {
        i4 || O2(e5, t3), t3.pendingcb--, r3(), Z(e5, t3);
      }
      function O2(e5, t3) {
        0 === t3.length && t3.needDrain && (t3.needDrain = false, e5.emit("drain"));
      }
      function D(e5, t3) {
        t3.bufferProcessing = true;
        var i4 = t3.bufferedRequest;
        if (e5._writev && i4 && i4.next) {
          var r3 = t3.bufferedRequestCount, a3 = new Array(r3), o3 = t3.corkedRequestsFree;
          o3.entry = i4;
          for (var s3 = 0, l3 = true; i4; )
            a3[s3] = i4, i4.isBuf || (l3 = false), i4 = i4.next, s3 += 1;
          a3.allBuffers = l3, C2(e5, t3, true, t3.length, a3, "", o3.finish), t3.pendingcb++, t3.lastBufferedRequest = null, o3.next ? (t3.corkedRequestsFree = o3.next, o3.next = null) : t3.corkedRequestsFree = new n2(t3), t3.bufferedRequestCount = 0;
        } else {
          for (; i4; ) {
            var u3 = i4.chunk, h3 = i4.encoding, c3 = i4.callback;
            if (C2(e5, t3, false, t3.objectMode ? 1 : u3.length, u3, h3, c3), i4 = i4.next, t3.bufferedRequestCount--, t3.writing)
              break;
          }
          null === i4 && (t3.lastBufferedRequest = null);
        }
        t3.bufferedRequest = i4, t3.bufferProcessing = false;
      }
      function $(e5) {
        return e5.ending && 0 === e5.length && null === e5.bufferedRequest && !e5.finished && !e5.writing;
      }
      function L2(e5, t3) {
        e5._final(function(i4) {
          t3.pendingcb--, i4 && k2(e5, i4), t3.prefinished = true, e5.emit("prefinish"), Z(e5, t3);
        });
      }
      function U(e5, t3) {
        t3.prefinished || t3.finalCalled || ("function" != typeof e5._final || t3.destroyed ? (t3.prefinished = true, e5.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = true, i3.nextTick(L2, e5, t3)));
      }
      function Z(e5, t3) {
        var i4 = $(t3);
        if (i4 && (U(e5, t3), 0 === t3.pendingcb && (t3.finished = true, e5.emit("finish"), t3.autoDestroy))) {
          var r3 = e5._readableState;
          (!r3 || r3.autoDestroy && r3.endEmitted) && e5.destroy();
        }
        return i4;
      }
      function j(e5, t3, r3) {
        t3.ending = true, Z(e5, t3), r3 && (t3.finished ? i3.nextTick(r3) : e5.once("finish", r3)), t3.ended = true, e5.writable = false;
      }
      function G(e5, t3, i4) {
        var r3 = e5.entry;
        for (e5.entry = null; r3; ) {
          var n3 = r3.callback;
          t3.pendingcb--, n3(i4), r3 = r3.next;
        }
        t3.corkedRequestsFree.next = e5;
      }
      e4("inherits")(I, s2), A2.prototype.getBuffer = function() {
        for (var e5 = this.bufferedRequest, t3 = []; e5; )
          t3.push(e5), e5 = e5.next;
        return t3;
      }, function() {
        try {
          Object.defineProperty(A2.prototype, "buffer", { get: o2.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
        } catch (e5) {
        }
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (f2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, { value: function(e5) {
        return !!f2.call(this, e5) || this === I && e5 && e5._writableState instanceof A2;
      } })) : f2 = function(e5) {
        return e5 instanceof this;
      }, I.prototype.pipe = function() {
        k2(this, new y2());
      }, I.prototype.write = function(e5, t3, i4) {
        var r3 = this._writableState, n3 = false, a3 = !r3.objectMode && c2(e5);
        return a3 && !l2.isBuffer(e5) && (e5 = h2(e5)), "function" == typeof t3 && (i4 = t3, t3 = null), a3 ? t3 = "buffer" : t3 || (t3 = r3.defaultEncoding), "function" != typeof i4 && (i4 = S2), r3.ending ? M2(this, i4) : (a3 || T2(this, r3, e5, i4)) && (r3.pendingcb++, n3 = B2(this, r3, a3, e5, t3, i4)), n3;
      }, I.prototype.cork = function() {
        this._writableState.corked++;
      }, I.prototype.uncork = function() {
        var e5 = this._writableState;
        e5.corked && (e5.corked--, e5.writing || e5.corked || e5.bufferProcessing || !e5.bufferedRequest || D(this, e5));
      }, I.prototype.setDefaultEncoding = function(e5) {
        if ("string" == typeof e5 && (e5 = e5.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e5 + "").toLowerCase()) > -1))
          throw new E2(e5);
        return this._writableState.defaultEncoding = e5, this;
      }, Object.defineProperty(I.prototype, "writableBuffer", { enumerable: false, get: function() {
        return this._writableState && this._writableState.getBuffer();
      } }), Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
        return this._writableState.highWaterMark;
      } }), I.prototype._write = function(e5, t3, i4) {
        i4(new g("_write()"));
      }, I.prototype._writev = null, I.prototype.end = function(e5, t3, i4) {
        var r3 = this._writableState;
        return "function" == typeof e5 ? (i4 = e5, e5 = null, t3 = null) : "function" == typeof t3 && (i4 = t3, t3 = null), null != e5 && this.write(e5, t3), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || j(this, r3, i4), this;
      }, Object.defineProperty(I.prototype, "writableLength", { enumerable: false, get: function() {
        return this._writableState.length;
      } }), Object.defineProperty(I.prototype, "destroyed", { enumerable: false, get: function() {
        return void 0 !== this._writableState && this._writableState.destroyed;
      }, set: function(e5) {
        this._writableState && (this._writableState.destroyed = e5);
      } }), I.prototype.destroy = d.destroy, I.prototype._undestroy = d.undestroy, I.prototype._destroy = function(e5, t3) {
        t3(e5);
      };
    }).call(this);
  }).call(this, e4("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/destroy": 74, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, inherits: 46, "util-deprecate": 81 }], 72: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      var r2;
      function n2(e5, t3, i4) {
        return t3 in e5 ? Object.defineProperty(e5, t3, { value: i4, enumerable: true, configurable: true, writable: true }) : e5[t3] = i4, e5;
      }
      var a2 = e4("./end-of-stream"), o2 = Symbol("lastResolve"), s2 = Symbol("lastReject"), l2 = Symbol("error"), u2 = Symbol("ended"), h2 = Symbol("lastPromise"), c2 = Symbol("handlePromise"), f2 = Symbol("stream");
      function d(e5, t3) {
        return { value: e5, done: t3 };
      }
      function p2(e5) {
        var t3 = e5[o2];
        if (null !== t3) {
          var i4 = e5[f2].read();
          null !== i4 && (e5[h2] = null, e5[o2] = null, e5[s2] = null, t3(d(i4, false)));
        }
      }
      function m(e5) {
        i3.nextTick(p2, e5);
      }
      function _2(e5, t3) {
        return function(i4, r3) {
          e5.then(function() {
            t3[u2] ? i4(d(void 0, true)) : t3[c2](i4, r3);
          }, r3);
        };
      }
      var g = Object.getPrototypeOf(function() {
      }), b2 = Object.setPrototypeOf((r2 = { get stream() {
        return this[f2];
      }, next: function() {
        var e5 = this, t3 = this[l2];
        if (null !== t3)
          return Promise.reject(t3);
        if (this[u2])
          return Promise.resolve(d(void 0, true));
        if (this[f2].destroyed)
          return new Promise(function(t4, r4) {
            i3.nextTick(function() {
              e5[l2] ? r4(e5[l2]) : t4(d(void 0, true));
            });
          });
        var r3, n3 = this[h2];
        if (n3)
          r3 = new Promise(_2(n3, this));
        else {
          var a3 = this[f2].read();
          if (null !== a3)
            return Promise.resolve(d(a3, false));
          r3 = new Promise(this[c2]);
        }
        return this[h2] = r3, r3;
      } }, n2(r2, Symbol.asyncIterator, function() {
        return this;
      }), n2(r2, "return", function() {
        var e5 = this;
        return new Promise(function(t3, i4) {
          e5[f2].destroy(null, function(e6) {
            e6 ? i4(e6) : t3(d(void 0, true));
          });
        });
      }), r2), g), y2 = function(e5) {
        var t3, i4 = Object.create(b2, (n2(t3 = {}, f2, { value: e5, writable: true }), n2(t3, o2, { value: null, writable: true }), n2(t3, s2, { value: null, writable: true }), n2(t3, l2, { value: null, writable: true }), n2(t3, u2, { value: e5._readableState.endEmitted, writable: true }), n2(t3, c2, { value: function(e6, t4) {
          var r3 = i4[f2].read();
          r3 ? (i4[h2] = null, i4[o2] = null, i4[s2] = null, e6(d(r3, false))) : (i4[o2] = e6, i4[s2] = t4);
        }, writable: true }), t3));
        return i4[h2] = null, a2(e5, function(e6) {
          if (e6 && "ERR_STREAM_PREMATURE_CLOSE" !== e6.code) {
            var t4 = i4[s2];
            return null !== t4 && (i4[h2] = null, i4[o2] = null, i4[s2] = null, t4(e6)), void (i4[l2] = e6);
          }
          var r3 = i4[o2];
          null !== r3 && (i4[h2] = null, i4[o2] = null, i4[s2] = null, r3(d(void 0, true))), i4[u2] = true;
        }), e5.on("readable", m.bind(null, i4)), i4;
      };
      t2.exports = y2;
    }).call(this);
  }).call(this, e4("_process"));
}, { "./end-of-stream": 75, _process: 63 }], 73: [function(e4, t2, i2) {
  function r2(e5, t3) {
    var i3 = Object.keys(e5);
    if (Object.getOwnPropertySymbols) {
      var r3 = Object.getOwnPropertySymbols(e5);
      t3 && (r3 = r3.filter(function(t4) {
        return Object.getOwnPropertyDescriptor(e5, t4).enumerable;
      })), i3.push.apply(i3, r3);
    }
    return i3;
  }
  function n2(e5) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var i3 = null != arguments[t3] ? arguments[t3] : {};
      t3 % 2 ? r2(Object(i3), true).forEach(function(t4) {
        a2(e5, t4, i3[t4]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e5, Object.getOwnPropertyDescriptors(i3)) : r2(Object(i3)).forEach(function(t4) {
        Object.defineProperty(e5, t4, Object.getOwnPropertyDescriptor(i3, t4));
      });
    }
    return e5;
  }
  function a2(e5, t3, i3) {
    return t3 in e5 ? Object.defineProperty(e5, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e5[t3] = i3, e5;
  }
  function o2(e5, t3) {
    if (!(e5 instanceof t3))
      throw new TypeError("Cannot call a class as a function");
  }
  function s2(e5, t3) {
    for (var i3 = 0; i3 < t3.length; i3++) {
      var r3 = t3[i3];
      r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e5, r3.key, r3);
    }
  }
  function l2(e5, t3, i3) {
    return t3 && s2(e5.prototype, t3), e5;
  }
  var u2 = e4("buffer").Buffer, h2 = e4("util").inspect, c2 = h2 && h2.custom || "inspect";
  function f2(e5, t3, i3) {
    u2.prototype.copy.call(e5, t3, i3);
  }
  t2.exports = function() {
    function e5() {
      o2(this, e5), this.head = null, this.tail = null, this.length = 0;
    }
    return l2(e5, [{ key: "push", value: function(e6) {
      var t3 = { data: e6, next: null };
      this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
    } }, { key: "unshift", value: function(e6) {
      var t3 = { data: e6, next: this.head };
      0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
    } }, { key: "shift", value: function() {
      if (0 !== this.length) {
        var e6 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e6;
      }
    } }, { key: "clear", value: function() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function(e6) {
      if (0 === this.length)
        return "";
      for (var t3 = this.head, i3 = "" + t3.data; t3 = t3.next; )
        i3 += e6 + t3.data;
      return i3;
    } }, { key: "concat", value: function(e6) {
      if (0 === this.length)
        return u2.alloc(0);
      for (var t3 = u2.allocUnsafe(e6 >>> 0), i3 = this.head, r3 = 0; i3; )
        f2(i3.data, t3, r3), r3 += i3.data.length, i3 = i3.next;
      return t3;
    } }, { key: "consume", value: function(e6, t3) {
      var i3;
      return e6 < this.head.data.length ? (i3 = this.head.data.slice(0, e6), this.head.data = this.head.data.slice(e6)) : i3 = e6 === this.head.data.length ? this.shift() : t3 ? this._getString(e6) : this._getBuffer(e6), i3;
    } }, { key: "first", value: function() {
      return this.head.data;
    } }, { key: "_getString", value: function(e6) {
      var t3 = this.head, i3 = 1, r3 = t3.data;
      for (e6 -= r3.length; t3 = t3.next; ) {
        var n3 = t3.data, a3 = e6 > n3.length ? n3.length : e6;
        if (a3 === n3.length ? r3 += n3 : r3 += n3.slice(0, e6), 0 == (e6 -= a3)) {
          a3 === n3.length ? (++i3, t3.next ? this.head = t3.next : this.head = this.tail = null) : (this.head = t3, t3.data = n3.slice(a3));
          break;
        }
        ++i3;
      }
      return this.length -= i3, r3;
    } }, { key: "_getBuffer", value: function(e6) {
      var t3 = u2.allocUnsafe(e6), i3 = this.head, r3 = 1;
      for (i3.data.copy(t3), e6 -= i3.data.length; i3 = i3.next; ) {
        var n3 = i3.data, a3 = e6 > n3.length ? n3.length : e6;
        if (n3.copy(t3, t3.length - e6, 0, a3), 0 == (e6 -= a3)) {
          a3 === n3.length ? (++r3, i3.next ? this.head = i3.next : this.head = this.tail = null) : (this.head = i3, i3.data = n3.slice(a3));
          break;
        }
        ++r3;
      }
      return this.length -= r3, t3;
    } }, { key: c2, value: function(e6, t3) {
      return h2(this, n2({}, t3, { depth: 0, customInspect: false }));
    } }]), e5;
  }();
}, { buffer: 32, util: 29 }], 74: [function(e4, t2, i2) {
  (function(e5) {
    (function() {
      function i3(t3, i4) {
        var a3 = this, s3 = this._readableState && this._readableState.destroyed, l2 = this._writableState && this._writableState.destroyed;
        return s3 || l2 ? (i4 ? i4(t3) : t3 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, e5.nextTick(o2, this, t3)) : e5.nextTick(o2, this, t3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t3 || null, function(t4) {
          !i4 && t4 ? a3._writableState ? a3._writableState.errorEmitted ? e5.nextTick(n2, a3) : (a3._writableState.errorEmitted = true, e5.nextTick(r2, a3, t4)) : e5.nextTick(r2, a3, t4) : i4 ? (e5.nextTick(n2, a3), i4(t4)) : e5.nextTick(n2, a3);
        }), this);
      }
      function r2(e6, t3) {
        o2(e6, t3), n2(e6);
      }
      function n2(e6) {
        e6._writableState && !e6._writableState.emitClose || e6._readableState && !e6._readableState.emitClose || e6.emit("close");
      }
      function a2() {
        this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
      }
      function o2(e6, t3) {
        e6.emit("error", t3);
      }
      function s2(e6, t3) {
        var i4 = e6._readableState, r3 = e6._writableState;
        i4 && i4.autoDestroy || r3 && r3.autoDestroy ? e6.destroy(t3) : e6.emit("error", t3);
      }
      t2.exports = { destroy: i3, undestroy: a2, errorOrDestroy: s2 };
    }).call(this);
  }).call(this, e4("_process"));
}, { _process: 63 }], 75: [function(e4, t2, i2) {
  var r2 = e4("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
  function n2(e5) {
    var t3 = false;
    return function() {
      if (!t3) {
        t3 = true;
        for (var i3 = arguments.length, r3 = new Array(i3), n3 = 0; n3 < i3; n3++)
          r3[n3] = arguments[n3];
        e5.apply(this, r3);
      }
    };
  }
  function a2() {
  }
  function o2(e5) {
    return e5.setHeader && "function" == typeof e5.abort;
  }
  function s2(e5, t3, i3) {
    if ("function" == typeof t3)
      return s2(e5, null, t3);
    t3 || (t3 = {}), i3 = n2(i3 || a2);
    var l2 = t3.readable || false !== t3.readable && e5.readable, u2 = t3.writable || false !== t3.writable && e5.writable, h2 = function() {
      e5.writable || f2();
    }, c2 = e5._writableState && e5._writableState.finished, f2 = function() {
      u2 = false, c2 = true, l2 || i3.call(e5);
    }, d = e5._readableState && e5._readableState.endEmitted, p2 = function() {
      l2 = false, d = true, u2 || i3.call(e5);
    }, m = function(t4) {
      i3.call(e5, t4);
    }, _2 = function() {
      var t4;
      return l2 && !d ? (e5._readableState && e5._readableState.ended || (t4 = new r2()), i3.call(e5, t4)) : u2 && !c2 ? (e5._writableState && e5._writableState.ended || (t4 = new r2()), i3.call(e5, t4)) : void 0;
    }, g = function() {
      e5.req.on("finish", f2);
    };
    return o2(e5) ? (e5.on("complete", f2), e5.on("abort", _2), e5.req ? g() : e5.on("request", g)) : u2 && !e5._writableState && (e5.on("end", h2), e5.on("close", h2)), e5.on("end", p2), e5.on("finish", f2), false !== t3.error && e5.on("error", m), e5.on("close", _2), function() {
      e5.removeListener("complete", f2), e5.removeListener("abort", _2), e5.removeListener("request", g), e5.req && e5.req.removeListener("finish", f2), e5.removeListener("end", h2), e5.removeListener("close", h2), e5.removeListener("finish", f2), e5.removeListener("end", p2), e5.removeListener("error", m), e5.removeListener("close", _2);
    };
  }
  t2.exports = s2;
}, { "../../../errors": 66 }], 76: [function(e4, t2, i2) {
  t2.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
}, {}], 77: [function(e4, t2, i2) {
  var r2;
  function n2(e5) {
    var t3 = false;
    return function() {
      t3 || (t3 = true, e5.apply(void 0, arguments));
    };
  }
  var a2 = e4("../../../errors").codes, o2 = a2.ERR_MISSING_ARGS, s2 = a2.ERR_STREAM_DESTROYED;
  function l2(e5) {
    if (e5)
      throw e5;
  }
  function u2(e5) {
    return e5.setHeader && "function" == typeof e5.abort;
  }
  function h2(t3, i3, a3, o3) {
    o3 = n2(o3);
    var l3 = false;
    t3.on("close", function() {
      l3 = true;
    }), void 0 === r2 && (r2 = e4("./end-of-stream")), r2(t3, { readable: i3, writable: a3 }, function(e5) {
      if (e5)
        return o3(e5);
      l3 = true, o3();
    });
    var h3 = false;
    return function(e5) {
      if (!l3 && !h3)
        return h3 = true, u2(t3) ? t3.abort() : "function" == typeof t3.destroy ? t3.destroy() : void o3(e5 || new s2("pipe"));
    };
  }
  function c2(e5) {
    e5();
  }
  function f2(e5, t3) {
    return e5.pipe(t3);
  }
  function d(e5) {
    return e5.length ? "function" != typeof e5[e5.length - 1] ? l2 : e5.pop() : l2;
  }
  function p2() {
    for (var e5 = arguments.length, t3 = new Array(e5), i3 = 0; i3 < e5; i3++)
      t3[i3] = arguments[i3];
    var r3, n3 = d(t3);
    if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2)
      throw new o2("streams");
    var a3 = t3.map(function(e6, i4) {
      var o3 = i4 < t3.length - 1;
      return h2(e6, o3, i4 > 0, function(e7) {
        r3 || (r3 = e7), e7 && a3.forEach(c2), o3 || (a3.forEach(c2), n3(r3));
      });
    });
    return t3.reduce(f2);
  }
  t2.exports = p2;
}, { "../../../errors": 66, "./end-of-stream": 75 }], 78: [function(e4, t2, i2) {
  var r2 = e4("../../../errors").codes.ERR_INVALID_OPT_VALUE;
  function n2(e5, t3, i3) {
    return null != e5.highWaterMark ? e5.highWaterMark : t3 ? e5[i3] : null;
  }
  function a2(e5, t3, i3, a3) {
    var o2 = n2(t3, a3, i3);
    if (null != o2) {
      if (!isFinite(o2) || Math.floor(o2) !== o2 || o2 < 0)
        throw new r2(a3 ? i3 : "highWaterMark", o2);
      return Math.floor(o2);
    }
    return e5.objectMode ? 16 : 16384;
  }
  t2.exports = { getHighWaterMark: a2 };
}, { "../../../errors": 66 }], 79: [function(e4, t2, i2) {
  t2.exports = e4("events").EventEmitter;
}, { events: 35 }], 80: [function(e4, t2, i2) {
  var r2 = e4("safe-buffer").Buffer, n2 = r2.isEncoding || function(e5) {
    switch ((e5 = "" + e5) && e5.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function a2(e5) {
    if (!e5)
      return "utf8";
    for (var t3; ; )
      switch (e5) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return e5;
        default:
          if (t3)
            return;
          e5 = ("" + e5).toLowerCase(), t3 = true;
      }
  }
  function o2(e5) {
    var t3 = a2(e5);
    if ("string" != typeof t3 && (r2.isEncoding === n2 || !n2(e5)))
      throw new Error("Unknown encoding: " + e5);
    return t3 || e5;
  }
  function s2(e5) {
    var t3;
    switch (this.encoding = o2(e5), this.encoding) {
      case "utf16le":
        this.text = p2, this.end = m, t3 = 4;
        break;
      case "utf8":
        this.fillLast = c2, t3 = 4;
        break;
      case "base64":
        this.text = _2, this.end = g, t3 = 3;
        break;
      default:
        return this.write = b2, void (this.end = y2);
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r2.allocUnsafe(t3);
  }
  function l2(e5) {
    return e5 <= 127 ? 0 : e5 >> 5 == 6 ? 2 : e5 >> 4 == 14 ? 3 : e5 >> 3 == 30 ? 4 : e5 >> 6 == 2 ? -1 : -2;
  }
  function u2(e5, t3, i3) {
    var r3 = t3.length - 1;
    if (r3 < i3)
      return 0;
    var n3 = l2(t3[r3]);
    return n3 >= 0 ? (n3 > 0 && (e5.lastNeed = n3 - 1), n3) : --r3 < i3 || -2 === n3 ? 0 : (n3 = l2(t3[r3])) >= 0 ? (n3 > 0 && (e5.lastNeed = n3 - 2), n3) : --r3 < i3 || -2 === n3 ? 0 : (n3 = l2(t3[r3])) >= 0 ? (n3 > 0 && (2 === n3 ? n3 = 0 : e5.lastNeed = n3 - 3), n3) : 0;
  }
  function h2(e5, t3, i3) {
    if (128 != (192 & t3[0]))
      return e5.lastNeed = 0, "\uFFFD";
    if (e5.lastNeed > 1 && t3.length > 1) {
      if (128 != (192 & t3[1]))
        return e5.lastNeed = 1, "\uFFFD";
      if (e5.lastNeed > 2 && t3.length > 2 && 128 != (192 & t3[2]))
        return e5.lastNeed = 2, "\uFFFD";
    }
  }
  function c2(e5) {
    var t3 = this.lastTotal - this.lastNeed, i3 = h2(this, e5);
    return void 0 !== i3 ? i3 : this.lastNeed <= e5.length ? (e5.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e5.copy(this.lastChar, t3, 0, e5.length), void (this.lastNeed -= e5.length));
  }
  function f2(e5, t3) {
    var i3 = u2(this, e5, t3);
    if (!this.lastNeed)
      return e5.toString("utf8", t3);
    this.lastTotal = i3;
    var r3 = e5.length - (i3 - this.lastNeed);
    return e5.copy(this.lastChar, 0, r3), e5.toString("utf8", t3, r3);
  }
  function d(e5) {
    var t3 = e5 && e5.length ? this.write(e5) : "";
    return this.lastNeed ? t3 + "\uFFFD" : t3;
  }
  function p2(e5, t3) {
    if ((e5.length - t3) % 2 == 0) {
      var i3 = e5.toString("utf16le", t3);
      if (i3) {
        var r3 = i3.charCodeAt(i3.length - 1);
        if (r3 >= 55296 && r3 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e5[e5.length - 2], this.lastChar[1] = e5[e5.length - 1], i3.slice(0, -1);
      }
      return i3;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e5[e5.length - 1], e5.toString("utf16le", t3, e5.length - 1);
  }
  function m(e5) {
    var t3 = e5 && e5.length ? this.write(e5) : "";
    if (this.lastNeed) {
      var i3 = this.lastTotal - this.lastNeed;
      return t3 + this.lastChar.toString("utf16le", 0, i3);
    }
    return t3;
  }
  function _2(e5, t3) {
    var i3 = (e5.length - t3) % 3;
    return 0 === i3 ? e5.toString("base64", t3) : (this.lastNeed = 3 - i3, this.lastTotal = 3, 1 === i3 ? this.lastChar[0] = e5[e5.length - 1] : (this.lastChar[0] = e5[e5.length - 2], this.lastChar[1] = e5[e5.length - 1]), e5.toString("base64", t3, e5.length - i3));
  }
  function g(e5) {
    var t3 = e5 && e5.length ? this.write(e5) : "";
    return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
  }
  function b2(e5) {
    return e5.toString(this.encoding);
  }
  function y2(e5) {
    return e5 && e5.length ? this.write(e5) : "";
  }
  i2.StringDecoder = s2, s2.prototype.write = function(e5) {
    if (0 === e5.length)
      return "";
    var t3, i3;
    if (this.lastNeed) {
      if (void 0 === (t3 = this.fillLast(e5)))
        return "";
      i3 = this.lastNeed, this.lastNeed = 0;
    } else
      i3 = 0;
    return i3 < e5.length ? t3 ? t3 + this.text(e5, i3) : this.text(e5, i3) : t3 || "";
  }, s2.prototype.end = d, s2.prototype.text = f2, s2.prototype.fillLast = function(e5) {
    if (this.lastNeed <= e5.length)
      return e5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    e5.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e5.length), this.lastNeed -= e5.length;
  };
}, { "safe-buffer": 64 }], 81: [function(e4, t2, i2) {
  (function(e5) {
    (function() {
      function i3(e6, t3) {
        if (r2("noDeprecation"))
          return e6;
        var i4 = false;
        function n2() {
          if (!i4) {
            if (r2("throwDeprecation"))
              throw new Error(t3);
            r2("traceDeprecation") ? console.trace(t3) : console.warn(t3), i4 = true;
          }
          return e6.apply(this, arguments);
        }
        return n2;
      }
      function r2(t3) {
        try {
          if (!e5.localStorage)
            return false;
        } catch (e6) {
          return false;
        }
        var i4 = e5.localStorage[t3];
        return null != i4 && "true" === String(i4).toLowerCase();
      }
      t2.exports = i3;
    }).call(this);
  }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, {}], 82: [function(e4, t2, i2) {
  arguments[4][25][0].apply(i2, arguments);
}, { dup: 25 }], 83: [function(e4, t2, i2) {
  var r2 = e4("is-arguments"), n2 = e4("is-generator-function"), a2 = e4("which-typed-array"), o2 = e4("is-typed-array");
  function s2(e5) {
    return e5.call.bind(e5);
  }
  var l2 = "undefined" != typeof BigInt, u2 = "undefined" != typeof Symbol, h2 = s2(Object.prototype.toString), c2 = s2(Number.prototype.valueOf), f2 = s2(String.prototype.valueOf), d = s2(Boolean.prototype.valueOf);
  if (l2)
    var p2 = s2(BigInt.prototype.valueOf);
  if (u2)
    var m = s2(Symbol.prototype.valueOf);
  function _2(e5, t3) {
    if ("object" != typeof e5)
      return false;
    try {
      return t3(e5), true;
    } catch (e6) {
      return false;
    }
  }
  function g(e5) {
    return "undefined" != typeof Promise && e5 instanceof Promise || null !== e5 && "object" == typeof e5 && "function" == typeof e5.then && "function" == typeof e5.catch;
  }
  function b2(e5) {
    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e5) : o2(e5) || U(e5);
  }
  function y2(e5) {
    return "Uint8Array" === a2(e5);
  }
  function w(e5) {
    return "Uint8ClampedArray" === a2(e5);
  }
  function v2(e5) {
    return "Uint16Array" === a2(e5);
  }
  function x2(e5) {
    return "Uint32Array" === a2(e5);
  }
  function E2(e5) {
    return "Int8Array" === a2(e5);
  }
  function k2(e5) {
    return "Int16Array" === a2(e5);
  }
  function S2(e5) {
    return "Int32Array" === a2(e5);
  }
  function A2(e5) {
    return "Float32Array" === a2(e5);
  }
  function I(e5) {
    return "Float64Array" === a2(e5);
  }
  function M2(e5) {
    return "BigInt64Array" === a2(e5);
  }
  function T2(e5) {
    return "BigUint64Array" === a2(e5);
  }
  function P(e5) {
    return "[object Map]" === h2(e5);
  }
  function B2(e5) {
    return "undefined" != typeof Map && (P.working ? P(e5) : e5 instanceof Map);
  }
  function C2(e5) {
    return "[object Set]" === h2(e5);
  }
  function R2(e5) {
    return "undefined" != typeof Set && (C2.working ? C2(e5) : e5 instanceof Set);
  }
  function z2(e5) {
    return "[object WeakMap]" === h2(e5);
  }
  function F(e5) {
    return "undefined" != typeof WeakMap && (z2.working ? z2(e5) : e5 instanceof WeakMap);
  }
  function N2(e5) {
    return "[object WeakSet]" === h2(e5);
  }
  function O2(e5) {
    return N2(e5);
  }
  function D(e5) {
    return "[object ArrayBuffer]" === h2(e5);
  }
  function $(e5) {
    return "undefined" != typeof ArrayBuffer && (D.working ? D(e5) : e5 instanceof ArrayBuffer);
  }
  function L2(e5) {
    return "[object DataView]" === h2(e5);
  }
  function U(e5) {
    return "undefined" != typeof DataView && (L2.working ? L2(e5) : e5 instanceof DataView);
  }
  i2.isArgumentsObject = r2, i2.isGeneratorFunction = n2, i2.isTypedArray = o2, i2.isPromise = g, i2.isArrayBufferView = b2, i2.isUint8Array = y2, i2.isUint8ClampedArray = w, i2.isUint16Array = v2, i2.isUint32Array = x2, i2.isInt8Array = E2, i2.isInt16Array = k2, i2.isInt32Array = S2, i2.isFloat32Array = A2, i2.isFloat64Array = I, i2.isBigInt64Array = M2, i2.isBigUint64Array = T2, P.working = "undefined" != typeof Map && P(/* @__PURE__ */ new Map()), i2.isMap = B2, C2.working = "undefined" != typeof Set && C2(/* @__PURE__ */ new Set()), i2.isSet = R2, z2.working = "undefined" != typeof WeakMap && z2(/* @__PURE__ */ new WeakMap()), i2.isWeakMap = F, N2.working = "undefined" != typeof WeakSet && N2(/* @__PURE__ */ new WeakSet()), i2.isWeakSet = O2, D.working = "undefined" != typeof ArrayBuffer && D(new ArrayBuffer()), i2.isArrayBuffer = $, L2.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && L2(new DataView(new ArrayBuffer(1), 0, 1)), i2.isDataView = U;
  var Z = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
  function j(e5) {
    return "[object SharedArrayBuffer]" === h2(e5);
  }
  function G(e5) {
    return void 0 !== Z && (void 0 === j.working && (j.working = j(new Z())), j.working ? j(e5) : e5 instanceof Z);
  }
  function H(e5) {
    return "[object AsyncFunction]" === h2(e5);
  }
  function Q(e5) {
    return "[object Map Iterator]" === h2(e5);
  }
  function W(e5) {
    return "[object Set Iterator]" === h2(e5);
  }
  function q(e5) {
    return "[object Generator]" === h2(e5);
  }
  function V(e5) {
    return "[object WebAssembly.Module]" === h2(e5);
  }
  function Y2(e5) {
    return _2(e5, c2);
  }
  function K(e5) {
    return _2(e5, f2);
  }
  function J(e5) {
    return _2(e5, d);
  }
  function X(e5) {
    return l2 && _2(e5, p2);
  }
  function ee(e5) {
    return u2 && _2(e5, m);
  }
  function te(e5) {
    return Y2(e5) || K(e5) || J(e5) || X(e5) || ee(e5);
  }
  function ie(e5) {
    return "undefined" != typeof Uint8Array && ($(e5) || G(e5));
  }
  i2.isSharedArrayBuffer = G, i2.isAsyncFunction = H, i2.isMapIterator = Q, i2.isSetIterator = W, i2.isGeneratorObject = q, i2.isWebAssemblyCompiledModule = V, i2.isNumberObject = Y2, i2.isStringObject = K, i2.isBooleanObject = J, i2.isBigIntObject = X, i2.isSymbolObject = ee, i2.isBoxedPrimitive = te, i2.isAnyArrayBuffer = ie, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e5) {
    Object.defineProperty(i2, e5, { enumerable: false, value: function() {
      throw new Error(e5 + " is not supported in userland");
    } });
  });
}, { "is-arguments": 47, "is-generator-function": 49, "is-typed-array": 50, "which-typed-array": 85 }], 84: [function(e4, t2, i2) {
  (function(t3) {
    (function() {
      var r2 = Object.getOwnPropertyDescriptors || function(e5) {
        for (var t4 = Object.keys(e5), i3 = {}, r3 = 0; r3 < t4.length; r3++)
          i3[t4[r3]] = Object.getOwnPropertyDescriptor(e5, t4[r3]);
        return i3;
      }, n2 = /%[sdj%]/g;
      i2.format = function(e5) {
        if (!E2(e5)) {
          for (var t4 = [], i3 = 0; i3 < arguments.length; i3++)
            t4.push(l2(arguments[i3]));
          return t4.join(" ");
        }
        i3 = 1;
        for (var r3 = arguments, a3 = r3.length, o3 = String(e5).replace(n2, function(e6) {
          if ("%%" === e6)
            return "%";
          if (i3 >= a3)
            return e6;
          switch (e6) {
            case "%s":
              return String(r3[i3++]);
            case "%d":
              return Number(r3[i3++]);
            case "%j":
              try {
                return JSON.stringify(r3[i3++]);
              } catch (e7) {
                return "[Circular]";
              }
            default:
              return e6;
          }
        }), s3 = r3[i3]; i3 < a3; s3 = r3[++i3])
          w(s3) || !I(s3) ? o3 += " " + s3 : o3 += " " + l2(s3);
        return o3;
      }, i2.deprecate = function(e5, r3) {
        if (void 0 !== t3 && true === t3.noDeprecation)
          return e5;
        if (void 0 === t3)
          return function() {
            return i2.deprecate(e5, r3).apply(this, arguments);
          };
        var n3 = false;
        function a3() {
          if (!n3) {
            if (t3.throwDeprecation)
              throw new Error(r3);
            t3.traceDeprecation ? console.trace(r3) : console.error(r3), n3 = true;
          }
          return e5.apply(this, arguments);
        }
        return a3;
      };
      var a2 = {}, o2 = /^$/;
      if (t3.env.NODE_DEBUG) {
        var s2 = t3.env.NODE_DEBUG;
        s2 = s2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o2 = new RegExp("^" + s2 + "$", "i");
      }
      function l2(e5, t4) {
        var r3 = { seen: [], stylize: h2 };
        return arguments.length >= 3 && (r3.depth = arguments[2]), arguments.length >= 4 && (r3.colors = arguments[3]), y2(t4) ? r3.showHidden = t4 : t4 && i2._extend(r3, t4), S2(r3.showHidden) && (r3.showHidden = false), S2(r3.depth) && (r3.depth = 2), S2(r3.colors) && (r3.colors = false), S2(r3.customInspect) && (r3.customInspect = true), r3.colors && (r3.stylize = u2), f2(r3, e5, r3.depth);
      }
      function u2(e5, t4) {
        var i3 = l2.styles[t4];
        return i3 ? "\x1B[" + l2.colors[i3][0] + "m" + e5 + "\x1B[" + l2.colors[i3][1] + "m" : e5;
      }
      function h2(e5, t4) {
        return e5;
      }
      function c2(e5) {
        var t4 = {};
        return e5.forEach(function(e6, i3) {
          t4[e6] = true;
        }), t4;
      }
      function f2(e5, t4, r3) {
        if (e5.customInspect && t4 && P(t4.inspect) && t4.inspect !== i2.inspect && (!t4.constructor || t4.constructor.prototype !== t4)) {
          var n3 = t4.inspect(r3, e5);
          return E2(n3) || (n3 = f2(e5, n3, r3)), n3;
        }
        var a3 = d(e5, t4);
        if (a3)
          return a3;
        var o3 = Object.keys(t4), s3 = c2(o3);
        if (e5.showHidden && (o3 = Object.getOwnPropertyNames(t4)), T2(t4) && (o3.indexOf("message") >= 0 || o3.indexOf("description") >= 0))
          return p2(t4);
        if (0 === o3.length) {
          if (P(t4)) {
            var l3 = t4.name ? ": " + t4.name : "";
            return e5.stylize("[Function" + l3 + "]", "special");
          }
          if (A2(t4))
            return e5.stylize(RegExp.prototype.toString.call(t4), "regexp");
          if (M2(t4))
            return e5.stylize(Date.prototype.toString.call(t4), "date");
          if (T2(t4))
            return p2(t4);
        }
        var u3, h3 = "", y3 = false, w2 = ["{", "}"];
        return b2(t4) && (y3 = true, w2 = ["[", "]"]), P(t4) && (h3 = " [Function" + (t4.name ? ": " + t4.name : "") + "]"), A2(t4) && (h3 = " " + RegExp.prototype.toString.call(t4)), M2(t4) && (h3 = " " + Date.prototype.toUTCString.call(t4)), T2(t4) && (h3 = " " + p2(t4)), 0 !== o3.length || y3 && 0 != t4.length ? r3 < 0 ? A2(t4) ? e5.stylize(RegExp.prototype.toString.call(t4), "regexp") : e5.stylize("[Object]", "special") : (e5.seen.push(t4), u3 = y3 ? m(e5, t4, r3, s3, o3) : o3.map(function(i3) {
          return _2(e5, t4, r3, s3, i3, y3);
        }), e5.seen.pop(), g(u3, h3, w2)) : w2[0] + h3 + w2[1];
      }
      function d(e5, t4) {
        if (S2(t4))
          return e5.stylize("undefined", "undefined");
        if (E2(t4)) {
          var i3 = "'" + JSON.stringify(t4).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e5.stylize(i3, "string");
        }
        return x2(t4) ? e5.stylize("" + t4, "number") : y2(t4) ? e5.stylize("" + t4, "boolean") : w(t4) ? e5.stylize("null", "null") : void 0;
      }
      function p2(e5) {
        return "[" + Error.prototype.toString.call(e5) + "]";
      }
      function m(e5, t4, i3, r3, n3) {
        for (var a3 = [], o3 = 0, s3 = t4.length; o3 < s3; ++o3)
          N2(t4, String(o3)) ? a3.push(_2(e5, t4, i3, r3, String(o3), true)) : a3.push("");
        return n3.forEach(function(n4) {
          n4.match(/^\d+$/) || a3.push(_2(e5, t4, i3, r3, n4, true));
        }), a3;
      }
      function _2(e5, t4, i3, r3, n3, a3) {
        var o3, s3, l3;
        if ((l3 = Object.getOwnPropertyDescriptor(t4, n3) || { value: t4[n3] }).get ? s3 = l3.set ? e5.stylize("[Getter/Setter]", "special") : e5.stylize("[Getter]", "special") : l3.set && (s3 = e5.stylize("[Setter]", "special")), N2(r3, n3) || (o3 = "[" + n3 + "]"), s3 || (e5.seen.indexOf(l3.value) < 0 ? (s3 = w(i3) ? f2(e5, l3.value, null) : f2(e5, l3.value, i3 - 1)).indexOf("\n") > -1 && (s3 = a3 ? s3.split("\n").map(function(e6) {
          return "  " + e6;
        }).join("\n").slice(2) : "\n" + s3.split("\n").map(function(e6) {
          return "   " + e6;
        }).join("\n")) : s3 = e5.stylize("[Circular]", "special")), S2(o3)) {
          if (a3 && n3.match(/^\d+$/))
            return s3;
          (o3 = JSON.stringify("" + n3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o3 = o3.slice(1, -1), o3 = e5.stylize(o3, "name")) : (o3 = o3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o3 = e5.stylize(o3, "string"));
        }
        return o3 + ": " + s3;
      }
      function g(e5, t4, i3) {
        return e5.reduce(function(e6, t5) {
          return t5.indexOf("\n"), e6 + t5.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0) > 60 ? i3[0] + ("" === t4 ? "" : t4 + "\n ") + " " + e5.join(",\n  ") + " " + i3[1] : i3[0] + t4 + " " + e5.join(", ") + " " + i3[1];
      }
      function b2(e5) {
        return Array.isArray(e5);
      }
      function y2(e5) {
        return "boolean" == typeof e5;
      }
      function w(e5) {
        return null === e5;
      }
      function v2(e5) {
        return null == e5;
      }
      function x2(e5) {
        return "number" == typeof e5;
      }
      function E2(e5) {
        return "string" == typeof e5;
      }
      function k2(e5) {
        return "symbol" == typeof e5;
      }
      function S2(e5) {
        return void 0 === e5;
      }
      function A2(e5) {
        return I(e5) && "[object RegExp]" === C2(e5);
      }
      function I(e5) {
        return "object" == typeof e5 && null !== e5;
      }
      function M2(e5) {
        return I(e5) && "[object Date]" === C2(e5);
      }
      function T2(e5) {
        return I(e5) && ("[object Error]" === C2(e5) || e5 instanceof Error);
      }
      function P(e5) {
        return "function" == typeof e5;
      }
      function B2(e5) {
        return null === e5 || "boolean" == typeof e5 || "number" == typeof e5 || "string" == typeof e5 || "symbol" == typeof e5 || void 0 === e5;
      }
      function C2(e5) {
        return Object.prototype.toString.call(e5);
      }
      function R2(e5) {
        return e5 < 10 ? "0" + e5.toString(10) : e5.toString(10);
      }
      i2.debuglog = function(e5) {
        if (e5 = e5.toUpperCase(), !a2[e5])
          if (o2.test(e5)) {
            var r3 = t3.pid;
            a2[e5] = function() {
              var t4 = i2.format.apply(i2, arguments);
              console.error("%s %d: %s", e5, r3, t4);
            };
          } else
            a2[e5] = function() {
            };
        return a2[e5];
      }, i2.inspect = l2, l2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.types = e4("./support/types"), i2.isArray = b2, i2.isBoolean = y2, i2.isNull = w, i2.isNullOrUndefined = v2, i2.isNumber = x2, i2.isString = E2, i2.isSymbol = k2, i2.isUndefined = S2, i2.isRegExp = A2, i2.types.isRegExp = A2, i2.isObject = I, i2.isDate = M2, i2.types.isDate = M2, i2.isError = T2, i2.types.isNativeError = T2, i2.isFunction = P, i2.isPrimitive = B2, i2.isBuffer = e4("./support/isBuffer");
      var z2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      function F() {
        var e5 = new Date(), t4 = [R2(e5.getHours()), R2(e5.getMinutes()), R2(e5.getSeconds())].join(":");
        return [e5.getDate(), z2[e5.getMonth()], t4].join(" ");
      }
      function N2(e5, t4) {
        return Object.prototype.hasOwnProperty.call(e5, t4);
      }
      i2.log = function() {
        console.log("%s - %s", F(), i2.format.apply(i2, arguments));
      }, i2.inherits = e4("inherits"), i2._extend = function(e5, t4) {
        if (!t4 || !I(t4))
          return e5;
        for (var i3 = Object.keys(t4), r3 = i3.length; r3--; )
          e5[i3[r3]] = t4[i3[r3]];
        return e5;
      };
      var O2 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
      function D(e5, t4) {
        if (!e5) {
          var i3 = new Error("Promise was rejected with a falsy value");
          i3.reason = e5, e5 = i3;
        }
        return t4(e5);
      }
      function $(e5) {
        if ("function" != typeof e5)
          throw new TypeError('The "original" argument must be of type Function');
        function i3() {
          for (var i4 = [], r3 = 0; r3 < arguments.length; r3++)
            i4.push(arguments[r3]);
          var n3 = i4.pop();
          if ("function" != typeof n3)
            throw new TypeError("The last argument must be of type Function");
          var a3 = this, o3 = function() {
            return n3.apply(a3, arguments);
          };
          e5.apply(this, i4).then(function(e6) {
            t3.nextTick(o3.bind(null, null, e6));
          }, function(e6) {
            t3.nextTick(D.bind(null, e6, o3));
          });
        }
        return Object.setPrototypeOf(i3, Object.getPrototypeOf(e5)), Object.defineProperties(i3, r2(e5)), i3;
      }
      i2.promisify = function(e5) {
        if ("function" != typeof e5)
          throw new TypeError('The "original" argument must be of type Function');
        if (O2 && e5[O2]) {
          var t4;
          if ("function" != typeof (t4 = e5[O2]))
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t4, O2, { value: t4, enumerable: false, writable: false, configurable: true }), t4;
        }
        function t4() {
          for (var t5, i3, r3 = new Promise(function(e6, r4) {
            t5 = e6, i3 = r4;
          }), n3 = [], a3 = 0; a3 < arguments.length; a3++)
            n3.push(arguments[a3]);
          n3.push(function(e6, r4) {
            e6 ? i3(e6) : t5(r4);
          });
          try {
            e5.apply(this, n3);
          } catch (e6) {
            i3(e6);
          }
          return r3;
        }
        return Object.setPrototypeOf(t4, Object.getPrototypeOf(e5)), O2 && Object.defineProperty(t4, O2, { value: t4, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t4, r2(e5));
      }, i2.promisify.custom = O2, i2.callbackify = $;
    }).call(this);
  }).call(this, e4("_process"));
}, { "./support/isBuffer": 82, "./support/types": 83, _process: 63, inherits: 46 }], 85: [function(e4, t2, i2) {
  (function(i3) {
    (function() {
      var r2 = e4("for-each"), n2 = e4("available-typed-arrays"), a2 = e4("call-bind/callBound"), o2 = e4("gopd"), s2 = a2("Object.prototype.toString"), l2 = e4("has-tostringtag/shams")(), u2 = "undefined" == typeof globalThis ? i3 : globalThis, h2 = n2(), c2 = a2("String.prototype.slice"), f2 = {}, d = Object.getPrototypeOf;
      l2 && o2 && d && r2(h2, function(e5) {
        if ("function" == typeof u2[e5]) {
          var t3 = new u2[e5]();
          if (Symbol.toStringTag in t3) {
            var i4 = d(t3), r3 = o2(i4, Symbol.toStringTag);
            if (!r3) {
              var n3 = d(i4);
              r3 = o2(n3, Symbol.toStringTag);
            }
            f2[e5] = r3.get;
          }
        }
      });
      var p2 = function(e5) {
        var t3 = false;
        return r2(f2, function(i4, r3) {
          if (!t3)
            try {
              var n3 = i4.call(e5);
              n3 === r3 && (t3 = n3);
            } catch (e6) {
            }
        }), t3;
      }, m = e4("is-typed-array");
      t2.exports = function(e5) {
        return !!m(e5) && (l2 && Symbol.toStringTag in e5 ? p2(e5) : c2(s2(e5), 8, -1));
      };
    }).call(this);
  }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
}, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43, "is-typed-array": 50 }] }, {}, [20])(20);
var browserExports = browser$1.exports;
var PNGFilterType;
var PNGFilterType2;
var PNGColorType;
var PNGColorType2;
function png() {
  return { mime: "image/png", hasAlpha: true, encode: (e4, { deflateLevel: t2 = 9, deflateStrategy: i2 = 3, filterType: r2 = PNGFilterType.AUTO, colorType: n2, inputHasAlpha: a2 = true, ...o2 } = {}) => {
    const s2 = new browserExports.PNG({ width: e4.width, height: e4.height });
    return s2.data = e4.data, browserExports.PNG.sync.write(s2, { ...o2, deflateLevel: t2, deflateStrategy: i2, filterType: r2, colorType: void 0 !== n2 ? n2 : a2 ? PNGColorType.COLOR_ALPHA : PNGColorType.COLOR, inputHasAlpha: a2 });
  }, decode: (e4, t2) => {
    const i2 = browserExports.PNG.sync.read(e4, t2);
    return { data: i2.data, width: i2.width, height: i2.height };
  } };
}
PNGFilterType2 = PNGFilterType || (PNGFilterType = {}), PNGFilterType2[PNGFilterType2.AUTO = -1] = "AUTO", PNGFilterType2[PNGFilterType2.NONE = 0] = "NONE", PNGFilterType2[PNGFilterType2.SUB = 1] = "SUB", PNGFilterType2[PNGFilterType2.UP = 2] = "UP", PNGFilterType2[PNGFilterType2.AVERAGE = 3] = "AVERAGE", PNGFilterType2[PNGFilterType2.PATH = 4] = "PATH", PNGColorType2 = PNGColorType || (PNGColorType = {}), PNGColorType2[PNGColorType2.GRAYSCALE = 0] = "GRAYSCALE", PNGColorType2[PNGColorType2.COLOR = 2] = "COLOR", PNGColorType2[PNGColorType2.GRAYSCALE_ALPHA = 4] = "GRAYSCALE_ALPHA", PNGColorType2[PNGColorType2.COLOR_ALPHA = 6] = "COLOR_ALPHA";
var UTIF = { exports: {} };
var common = {};
var hasRequiredCommon;
function requireCommon() {
  return hasRequiredCommon || (hasRequiredCommon = 1, function(e4) {
    var t2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
    function i2(e5, t3) {
      return Object.prototype.hasOwnProperty.call(e5, t3);
    }
    e4.assign = function(e5) {
      for (var t3 = Array.prototype.slice.call(arguments, 1); t3.length; ) {
        var r3 = t3.shift();
        if (r3) {
          if ("object" != typeof r3)
            throw new TypeError(r3 + "must be non-object");
          for (var n3 in r3)
            i2(r3, n3) && (e5[n3] = r3[n3]);
        }
      }
      return e5;
    }, e4.shrinkBuf = function(e5, t3) {
      return e5.length === t3 ? e5 : e5.subarray ? e5.subarray(0, t3) : (e5.length = t3, e5);
    };
    var r2 = { arraySet: function(e5, t3, i3, r3, n3) {
      if (t3.subarray && e5.subarray)
        e5.set(t3.subarray(i3, i3 + r3), n3);
      else
        for (var a2 = 0; a2 < r3; a2++)
          e5[n3 + a2] = t3[i3 + a2];
    }, flattenChunks: function(e5) {
      var t3, i3, r3, n3, a2, o2;
      for (r3 = 0, t3 = 0, i3 = e5.length; t3 < i3; t3++)
        r3 += e5[t3].length;
      for (o2 = new Uint8Array(r3), n3 = 0, t3 = 0, i3 = e5.length; t3 < i3; t3++)
        a2 = e5[t3], o2.set(a2, n3), n3 += a2.length;
      return o2;
    } }, n2 = { arraySet: function(e5, t3, i3, r3, n3) {
      for (var a2 = 0; a2 < r3; a2++)
        e5[n3 + a2] = t3[i3 + a2];
    }, flattenChunks: function(e5) {
      return [].concat.apply([], e5);
    } };
    e4.setTyped = function(t3) {
      t3 ? (e4.Buf8 = Uint8Array, e4.Buf16 = Uint16Array, e4.Buf32 = Int32Array, e4.assign(e4, r2)) : (e4.Buf8 = Array, e4.Buf16 = Array, e4.Buf32 = Array, e4.assign(e4, n2));
    }, e4.setTyped(t2);
  }(common)), common;
}
var deflate$1 = {};
var deflate = {};
var trees = {};
var hasRequiredTrees;
var adler32_1;
var hasRequiredAdler32;
var crc32_1;
var hasRequiredCrc32;
var messages;
var hasRequiredMessages;
var hasRequiredDeflate$1;
function requireTrees() {
  if (hasRequiredTrees)
    return trees;
  hasRequiredTrees = 1;
  var e4 = requireCommon(), t2 = 0, i2 = 1;
  function r2(e5) {
    for (var t3 = e5.length; --t3 >= 0; )
      e5[t3] = 0;
  }
  var n2 = 0, a2 = 29, o2 = 256, s2 = o2 + 1 + a2, l2 = 30, u2 = 19, h2 = 2 * s2 + 1, c2 = 15, f2 = 16, d = 7, p2 = 256, m = 16, _2 = 17, g = 18, b2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], y2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], v2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], x2 = new Array(2 * (s2 + 2));
  r2(x2);
  var E2 = new Array(2 * l2);
  r2(E2);
  var k2 = new Array(512);
  r2(k2);
  var S2 = new Array(256);
  r2(S2);
  var A2 = new Array(a2);
  r2(A2);
  var I, M2, T2, P = new Array(l2);
  function B2(e5, t3, i3, r3, n3) {
    this.static_tree = e5, this.extra_bits = t3, this.extra_base = i3, this.elems = r3, this.max_length = n3, this.has_stree = e5 && e5.length;
  }
  function C2(e5, t3) {
    this.dyn_tree = e5, this.max_code = 0, this.stat_desc = t3;
  }
  function R2(e5) {
    return e5 < 256 ? k2[e5] : k2[256 + (e5 >>> 7)];
  }
  function z2(e5, t3) {
    e5.pending_buf[e5.pending++] = 255 & t3, e5.pending_buf[e5.pending++] = t3 >>> 8 & 255;
  }
  function F(e5, t3, i3) {
    e5.bi_valid > f2 - i3 ? (e5.bi_buf |= t3 << e5.bi_valid & 65535, z2(e5, e5.bi_buf), e5.bi_buf = t3 >> f2 - e5.bi_valid, e5.bi_valid += i3 - f2) : (e5.bi_buf |= t3 << e5.bi_valid & 65535, e5.bi_valid += i3);
  }
  function N2(e5, t3, i3) {
    F(e5, i3[2 * t3], i3[2 * t3 + 1]);
  }
  function O2(e5, t3) {
    var i3 = 0;
    do {
      i3 |= 1 & e5, e5 >>>= 1, i3 <<= 1;
    } while (--t3 > 0);
    return i3 >>> 1;
  }
  function D(e5, t3, i3) {
    var r3, n3, a3 = new Array(c2 + 1), o3 = 0;
    for (r3 = 1; r3 <= c2; r3++)
      a3[r3] = o3 = o3 + i3[r3 - 1] << 1;
    for (n3 = 0; n3 <= t3; n3++) {
      var s3 = e5[2 * n3 + 1];
      0 !== s3 && (e5[2 * n3] = O2(a3[s3]++, s3));
    }
  }
  function $(e5) {
    var t3;
    for (t3 = 0; t3 < s2; t3++)
      e5.dyn_ltree[2 * t3] = 0;
    for (t3 = 0; t3 < l2; t3++)
      e5.dyn_dtree[2 * t3] = 0;
    for (t3 = 0; t3 < u2; t3++)
      e5.bl_tree[2 * t3] = 0;
    e5.dyn_ltree[2 * p2] = 1, e5.opt_len = e5.static_len = 0, e5.last_lit = e5.matches = 0;
  }
  function L2(e5) {
    e5.bi_valid > 8 ? z2(e5, e5.bi_buf) : e5.bi_valid > 0 && (e5.pending_buf[e5.pending++] = e5.bi_buf), e5.bi_buf = 0, e5.bi_valid = 0;
  }
  function U(e5, t3, i3, r3) {
    var n3 = 2 * t3, a3 = 2 * i3;
    return e5[n3] < e5[a3] || e5[n3] === e5[a3] && r3[t3] <= r3[i3];
  }
  function Z(e5, t3, i3) {
    for (var r3 = e5.heap[i3], n3 = i3 << 1; n3 <= e5.heap_len && (n3 < e5.heap_len && U(t3, e5.heap[n3 + 1], e5.heap[n3], e5.depth) && n3++, !U(t3, r3, e5.heap[n3], e5.depth)); )
      e5.heap[i3] = e5.heap[n3], i3 = n3, n3 <<= 1;
    e5.heap[i3] = r3;
  }
  function j(e5, t3, i3) {
    var r3, n3, a3, s3, l3 = 0;
    if (0 !== e5.last_lit)
      do {
        r3 = e5.pending_buf[e5.d_buf + 2 * l3] << 8 | e5.pending_buf[e5.d_buf + 2 * l3 + 1], n3 = e5.pending_buf[e5.l_buf + l3], l3++, 0 === r3 ? N2(e5, n3, t3) : (N2(e5, (a3 = S2[n3]) + o2 + 1, t3), 0 !== (s3 = b2[a3]) && F(e5, n3 -= A2[a3], s3), N2(e5, a3 = R2(--r3), i3), 0 !== (s3 = y2[a3]) && F(e5, r3 -= P[a3], s3));
      } while (l3 < e5.last_lit);
    N2(e5, p2, t3);
  }
  function G(e5, t3) {
    var i3, r3, n3, a3 = t3.dyn_tree, o3 = t3.stat_desc.static_tree, s3 = t3.stat_desc.has_stree, l3 = t3.stat_desc.elems, u3 = -1;
    for (e5.heap_len = 0, e5.heap_max = h2, i3 = 0; i3 < l3; i3++)
      0 !== a3[2 * i3] ? (e5.heap[++e5.heap_len] = u3 = i3, e5.depth[i3] = 0) : a3[2 * i3 + 1] = 0;
    for (; e5.heap_len < 2; )
      a3[2 * (n3 = e5.heap[++e5.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e5.depth[n3] = 0, e5.opt_len--, s3 && (e5.static_len -= o3[2 * n3 + 1]);
    for (t3.max_code = u3, i3 = e5.heap_len >> 1; i3 >= 1; i3--)
      Z(e5, a3, i3);
    n3 = l3;
    do {
      i3 = e5.heap[1], e5.heap[1] = e5.heap[e5.heap_len--], Z(e5, a3, 1), r3 = e5.heap[1], e5.heap[--e5.heap_max] = i3, e5.heap[--e5.heap_max] = r3, a3[2 * n3] = a3[2 * i3] + a3[2 * r3], e5.depth[n3] = (e5.depth[i3] >= e5.depth[r3] ? e5.depth[i3] : e5.depth[r3]) + 1, a3[2 * i3 + 1] = a3[2 * r3 + 1] = n3, e5.heap[1] = n3++, Z(e5, a3, 1);
    } while (e5.heap_len >= 2);
    e5.heap[--e5.heap_max] = e5.heap[1], function(e6, t4) {
      var i4, r4, n4, a4, o4, s4, l4 = t4.dyn_tree, u4 = t4.max_code, f3 = t4.stat_desc.static_tree, d2 = t4.stat_desc.has_stree, p3 = t4.stat_desc.extra_bits, m2 = t4.stat_desc.extra_base, _3 = t4.stat_desc.max_length, g2 = 0;
      for (a4 = 0; a4 <= c2; a4++)
        e6.bl_count[a4] = 0;
      for (l4[2 * e6.heap[e6.heap_max] + 1] = 0, i4 = e6.heap_max + 1; i4 < h2; i4++)
        (a4 = l4[2 * l4[2 * (r4 = e6.heap[i4]) + 1] + 1] + 1) > _3 && (a4 = _3, g2++), l4[2 * r4 + 1] = a4, r4 > u4 || (e6.bl_count[a4]++, o4 = 0, r4 >= m2 && (o4 = p3[r4 - m2]), s4 = l4[2 * r4], e6.opt_len += s4 * (a4 + o4), d2 && (e6.static_len += s4 * (f3[2 * r4 + 1] + o4)));
      if (0 !== g2) {
        do {
          for (a4 = _3 - 1; 0 === e6.bl_count[a4]; )
            a4--;
          e6.bl_count[a4]--, e6.bl_count[a4 + 1] += 2, e6.bl_count[_3]--, g2 -= 2;
        } while (g2 > 0);
        for (a4 = _3; 0 !== a4; a4--)
          for (r4 = e6.bl_count[a4]; 0 !== r4; )
            (n4 = e6.heap[--i4]) > u4 || (l4[2 * n4 + 1] !== a4 && (e6.opt_len += (a4 - l4[2 * n4 + 1]) * l4[2 * n4], l4[2 * n4 + 1] = a4), r4--);
      }
    }(e5, t3), D(a3, u3, e5.bl_count);
  }
  function H(e5, t3, i3) {
    var r3, n3, a3 = -1, o3 = t3[1], s3 = 0, l3 = 7, u3 = 4;
    for (0 === o3 && (l3 = 138, u3 = 3), t3[2 * (i3 + 1) + 1] = 65535, r3 = 0; r3 <= i3; r3++)
      n3 = o3, o3 = t3[2 * (r3 + 1) + 1], ++s3 < l3 && n3 === o3 || (s3 < u3 ? e5.bl_tree[2 * n3] += s3 : 0 !== n3 ? (n3 !== a3 && e5.bl_tree[2 * n3]++, e5.bl_tree[2 * m]++) : s3 <= 10 ? e5.bl_tree[2 * _2]++ : e5.bl_tree[2 * g]++, s3 = 0, a3 = n3, 0 === o3 ? (l3 = 138, u3 = 3) : n3 === o3 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4));
  }
  function Q(e5, t3, i3) {
    var r3, n3, a3 = -1, o3 = t3[1], s3 = 0, l3 = 7, u3 = 4;
    for (0 === o3 && (l3 = 138, u3 = 3), r3 = 0; r3 <= i3; r3++)
      if (n3 = o3, o3 = t3[2 * (r3 + 1) + 1], !(++s3 < l3 && n3 === o3)) {
        if (s3 < u3)
          do {
            N2(e5, n3, e5.bl_tree);
          } while (0 != --s3);
        else
          0 !== n3 ? (n3 !== a3 && (N2(e5, n3, e5.bl_tree), s3--), N2(e5, m, e5.bl_tree), F(e5, s3 - 3, 2)) : s3 <= 10 ? (N2(e5, _2, e5.bl_tree), F(e5, s3 - 3, 3)) : (N2(e5, g, e5.bl_tree), F(e5, s3 - 11, 7));
        s3 = 0, a3 = n3, 0 === o3 ? (l3 = 138, u3 = 3) : n3 === o3 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4);
      }
  }
  r2(P);
  var W = false;
  function q(t3, i3, r3, a3) {
    F(t3, (n2 << 1) + (a3 ? 1 : 0), 3), function(t4, i4, r4, n3) {
      L2(t4), z2(t4, r4), z2(t4, ~r4), e4.arraySet(t4.pending_buf, t4.window, i4, r4, t4.pending), t4.pending += r4;
    }(t3, i3, r3);
  }
  return trees._tr_init = function(e5) {
    W || (!function() {
      var e6, t3, i3, r3, n3, h3 = new Array(c2 + 1);
      for (i3 = 0, r3 = 0; r3 < a2 - 1; r3++)
        for (A2[r3] = i3, e6 = 0; e6 < 1 << b2[r3]; e6++)
          S2[i3++] = r3;
      for (S2[i3 - 1] = r3, n3 = 0, r3 = 0; r3 < 16; r3++)
        for (P[r3] = n3, e6 = 0; e6 < 1 << y2[r3]; e6++)
          k2[n3++] = r3;
      for (n3 >>= 7; r3 < l2; r3++)
        for (P[r3] = n3 << 7, e6 = 0; e6 < 1 << y2[r3] - 7; e6++)
          k2[256 + n3++] = r3;
      for (t3 = 0; t3 <= c2; t3++)
        h3[t3] = 0;
      for (e6 = 0; e6 <= 143; )
        x2[2 * e6 + 1] = 8, e6++, h3[8]++;
      for (; e6 <= 255; )
        x2[2 * e6 + 1] = 9, e6++, h3[9]++;
      for (; e6 <= 279; )
        x2[2 * e6 + 1] = 7, e6++, h3[7]++;
      for (; e6 <= 287; )
        x2[2 * e6 + 1] = 8, e6++, h3[8]++;
      for (D(x2, s2 + 1, h3), e6 = 0; e6 < l2; e6++)
        E2[2 * e6 + 1] = 5, E2[2 * e6] = O2(e6, 5);
      I = new B2(x2, b2, o2 + 1, s2, c2), M2 = new B2(E2, y2, 0, l2, c2), T2 = new B2(new Array(0), w, 0, u2, d);
    }(), W = true), e5.l_desc = new C2(e5.dyn_ltree, I), e5.d_desc = new C2(e5.dyn_dtree, M2), e5.bl_desc = new C2(e5.bl_tree, T2), e5.bi_buf = 0, e5.bi_valid = 0, $(e5);
  }, trees._tr_stored_block = q, trees._tr_flush_block = function(e5, r3, n3, a3) {
    var s3, l3, h3 = 0;
    e5.level > 0 ? (2 === e5.strm.data_type && (e5.strm.data_type = function(e6) {
      var r4, n4 = 4093624447;
      for (r4 = 0; r4 <= 31; r4++, n4 >>>= 1)
        if (1 & n4 && 0 !== e6.dyn_ltree[2 * r4])
          return t2;
      if (0 !== e6.dyn_ltree[18] || 0 !== e6.dyn_ltree[20] || 0 !== e6.dyn_ltree[26])
        return i2;
      for (r4 = 32; r4 < o2; r4++)
        if (0 !== e6.dyn_ltree[2 * r4])
          return i2;
      return t2;
    }(e5)), G(e5, e5.l_desc), G(e5, e5.d_desc), h3 = function(e6) {
      var t3;
      for (H(e6, e6.dyn_ltree, e6.l_desc.max_code), H(e6, e6.dyn_dtree, e6.d_desc.max_code), G(e6, e6.bl_desc), t3 = u2 - 1; t3 >= 3 && 0 === e6.bl_tree[2 * v2[t3] + 1]; t3--)
        ;
      return e6.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
    }(e5), s3 = e5.opt_len + 3 + 7 >>> 3, (l3 = e5.static_len + 3 + 7 >>> 3) <= s3 && (s3 = l3)) : s3 = l3 = n3 + 5, n3 + 4 <= s3 && -1 !== r3 ? q(e5, r3, n3, a3) : 4 === e5.strategy || l3 === s3 ? (F(e5, 2 + (a3 ? 1 : 0), 3), j(e5, x2, E2)) : (F(e5, 4 + (a3 ? 1 : 0), 3), function(e6, t3, i3, r4) {
      var n4;
      for (F(e6, t3 - 257, 5), F(e6, i3 - 1, 5), F(e6, r4 - 4, 4), n4 = 0; n4 < r4; n4++)
        F(e6, e6.bl_tree[2 * v2[n4] + 1], 3);
      Q(e6, e6.dyn_ltree, t3 - 1), Q(e6, e6.dyn_dtree, i3 - 1);
    }(e5, e5.l_desc.max_code + 1, e5.d_desc.max_code + 1, h3 + 1), j(e5, e5.dyn_ltree, e5.dyn_dtree)), $(e5), a3 && L2(e5);
  }, trees._tr_tally = function(e5, t3, i3) {
    return e5.pending_buf[e5.d_buf + 2 * e5.last_lit] = t3 >>> 8 & 255, e5.pending_buf[e5.d_buf + 2 * e5.last_lit + 1] = 255 & t3, e5.pending_buf[e5.l_buf + e5.last_lit] = 255 & i3, e5.last_lit++, 0 === t3 ? e5.dyn_ltree[2 * i3]++ : (e5.matches++, t3--, e5.dyn_ltree[2 * (S2[i3] + o2 + 1)]++, e5.dyn_dtree[2 * R2(t3)]++), e5.last_lit === e5.lit_bufsize - 1;
  }, trees._tr_align = function(e5) {
    F(e5, 2, 3), N2(e5, p2, x2), function(e6) {
      16 === e6.bi_valid ? (z2(e6, e6.bi_buf), e6.bi_buf = 0, e6.bi_valid = 0) : e6.bi_valid >= 8 && (e6.pending_buf[e6.pending++] = 255 & e6.bi_buf, e6.bi_buf >>= 8, e6.bi_valid -= 8);
    }(e5);
  }, trees;
}
function requireAdler32() {
  if (hasRequiredAdler32)
    return adler32_1;
  return hasRequiredAdler32 = 1, adler32_1 = function(e4, t2, i2, r2) {
    for (var n2 = 65535 & e4, a2 = e4 >>> 16 & 65535, o2 = 0; 0 !== i2; ) {
      i2 -= o2 = i2 > 2e3 ? 2e3 : i2;
      do {
        a2 = a2 + (n2 = n2 + t2[r2++] | 0) | 0;
      } while (--o2);
      n2 %= 65521, a2 %= 65521;
    }
    return n2 | a2 << 16;
  }, adler32_1;
}
function requireCrc32() {
  if (hasRequiredCrc32)
    return crc32_1;
  hasRequiredCrc32 = 1;
  var e4 = function() {
    for (var e5, t2 = [], i2 = 0; i2 < 256; i2++) {
      e5 = i2;
      for (var r2 = 0; r2 < 8; r2++)
        e5 = 1 & e5 ? 3988292384 ^ e5 >>> 1 : e5 >>> 1;
      t2[i2] = e5;
    }
    return t2;
  }();
  return crc32_1 = function(t2, i2, r2, n2) {
    var a2 = e4, o2 = n2 + r2;
    t2 ^= -1;
    for (var s2 = n2; s2 < o2; s2++)
      t2 = t2 >>> 8 ^ a2[255 & (t2 ^ i2[s2])];
    return ~t2;
  }, crc32_1;
}
function requireMessages() {
  return hasRequiredMessages ? messages : (hasRequiredMessages = 1, messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" });
}
function requireDeflate$1() {
  if (hasRequiredDeflate$1)
    return deflate;
  hasRequiredDeflate$1 = 1;
  var e4, t2 = requireCommon(), i2 = requireTrees(), r2 = requireAdler32(), n2 = requireCrc32(), a2 = requireMessages(), o2 = 0, s2 = 4, l2 = 0, u2 = -2, h2 = -1, c2 = 4, f2 = 2, d = 8, p2 = 9, m = 286, _2 = 30, g = 19, b2 = 2 * m + 1, y2 = 15, w = 3, v2 = 258, x2 = v2 + w + 1, E2 = 42, k2 = 103, S2 = 113, A2 = 666, I = 1, M2 = 2, T2 = 3, P = 4;
  function B2(e5, t3) {
    return e5.msg = a2[t3], t3;
  }
  function C2(e5) {
    return (e5 << 1) - (e5 > 4 ? 9 : 0);
  }
  function R2(e5) {
    for (var t3 = e5.length; --t3 >= 0; )
      e5[t3] = 0;
  }
  function z2(e5) {
    var i3 = e5.state, r3 = i3.pending;
    r3 > e5.avail_out && (r3 = e5.avail_out), 0 !== r3 && (t2.arraySet(e5.output, i3.pending_buf, i3.pending_out, r3, e5.next_out), e5.next_out += r3, i3.pending_out += r3, e5.total_out += r3, e5.avail_out -= r3, i3.pending -= r3, 0 === i3.pending && (i3.pending_out = 0));
  }
  function F(e5, t3) {
    i2._tr_flush_block(e5, e5.block_start >= 0 ? e5.block_start : -1, e5.strstart - e5.block_start, t3), e5.block_start = e5.strstart, z2(e5.strm);
  }
  function N2(e5, t3) {
    e5.pending_buf[e5.pending++] = t3;
  }
  function O2(e5, t3) {
    e5.pending_buf[e5.pending++] = t3 >>> 8 & 255, e5.pending_buf[e5.pending++] = 255 & t3;
  }
  function D(e5, t3) {
    var i3, r3, n3 = e5.max_chain_length, a3 = e5.strstart, o3 = e5.prev_length, s3 = e5.nice_match, l3 = e5.strstart > e5.w_size - x2 ? e5.strstart - (e5.w_size - x2) : 0, u3 = e5.window, h3 = e5.w_mask, c3 = e5.prev, f3 = e5.strstart + v2, d2 = u3[a3 + o3 - 1], p3 = u3[a3 + o3];
    e5.prev_length >= e5.good_match && (n3 >>= 2), s3 > e5.lookahead && (s3 = e5.lookahead);
    do {
      if (u3[(i3 = t3) + o3] === p3 && u3[i3 + o3 - 1] === d2 && u3[i3] === u3[a3] && u3[++i3] === u3[a3 + 1]) {
        a3 += 2, i3++;
        do {
        } while (u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && a3 < f3);
        if (r3 = v2 - (f3 - a3), a3 = f3 - v2, r3 > o3) {
          if (e5.match_start = t3, o3 = r3, r3 >= s3)
            break;
          d2 = u3[a3 + o3 - 1], p3 = u3[a3 + o3];
        }
      }
    } while ((t3 = c3[t3 & h3]) > l3 && 0 != --n3);
    return o3 <= e5.lookahead ? o3 : e5.lookahead;
  }
  function $(e5) {
    var i3, a3, o3, s3, l3, u3, h3, c3, f3, d2, p3 = e5.w_size;
    do {
      if (s3 = e5.window_size - e5.lookahead - e5.strstart, e5.strstart >= p3 + (p3 - x2)) {
        t2.arraySet(e5.window, e5.window, p3, p3, 0), e5.match_start -= p3, e5.strstart -= p3, e5.block_start -= p3, i3 = a3 = e5.hash_size;
        do {
          o3 = e5.head[--i3], e5.head[i3] = o3 >= p3 ? o3 - p3 : 0;
        } while (--a3);
        i3 = a3 = p3;
        do {
          o3 = e5.prev[--i3], e5.prev[i3] = o3 >= p3 ? o3 - p3 : 0;
        } while (--a3);
        s3 += p3;
      }
      if (0 === e5.strm.avail_in)
        break;
      if (u3 = e5.strm, h3 = e5.window, c3 = e5.strstart + e5.lookahead, f3 = s3, d2 = void 0, (d2 = u3.avail_in) > f3 && (d2 = f3), a3 = 0 === d2 ? 0 : (u3.avail_in -= d2, t2.arraySet(h3, u3.input, u3.next_in, d2, c3), 1 === u3.state.wrap ? u3.adler = r2(u3.adler, h3, d2, c3) : 2 === u3.state.wrap && (u3.adler = n2(u3.adler, h3, d2, c3)), u3.next_in += d2, u3.total_in += d2, d2), e5.lookahead += a3, e5.lookahead + e5.insert >= w)
        for (l3 = e5.strstart - e5.insert, e5.ins_h = e5.window[l3], e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[l3 + 1]) & e5.hash_mask; e5.insert && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[l3 + w - 1]) & e5.hash_mask, e5.prev[l3 & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = l3, l3++, e5.insert--, !(e5.lookahead + e5.insert < w)); )
          ;
    } while (e5.lookahead < x2 && 0 !== e5.strm.avail_in);
  }
  function L2(e5, t3) {
    for (var r3, n3; ; ) {
      if (e5.lookahead < x2) {
        if ($(e5), e5.lookahead < x2 && t3 === o2)
          return I;
        if (0 === e5.lookahead)
          break;
      }
      if (r3 = 0, e5.lookahead >= w && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + w - 1]) & e5.hash_mask, r3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart), 0 !== r3 && e5.strstart - r3 <= e5.w_size - x2 && (e5.match_length = D(e5, r3)), e5.match_length >= w)
        if (n3 = i2._tr_tally(e5, e5.strstart - e5.match_start, e5.match_length - w), e5.lookahead -= e5.match_length, e5.match_length <= e5.max_lazy_match && e5.lookahead >= w) {
          e5.match_length--;
          do {
            e5.strstart++, e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + w - 1]) & e5.hash_mask, r3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart;
          } while (0 != --e5.match_length);
          e5.strstart++;
        } else
          e5.strstart += e5.match_length, e5.match_length = 0, e5.ins_h = e5.window[e5.strstart], e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + 1]) & e5.hash_mask;
      else
        n3 = i2._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++;
      if (n3 && (F(e5, false), 0 === e5.strm.avail_out))
        return I;
    }
    return e5.insert = e5.strstart < w - 1 ? e5.strstart : w - 1, t3 === s2 ? (F(e5, true), 0 === e5.strm.avail_out ? T2 : P) : e5.last_lit && (F(e5, false), 0 === e5.strm.avail_out) ? I : M2;
  }
  function U(e5, t3) {
    for (var r3, n3, a3; ; ) {
      if (e5.lookahead < x2) {
        if ($(e5), e5.lookahead < x2 && t3 === o2)
          return I;
        if (0 === e5.lookahead)
          break;
      }
      if (r3 = 0, e5.lookahead >= w && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + w - 1]) & e5.hash_mask, r3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart), e5.prev_length = e5.match_length, e5.prev_match = e5.match_start, e5.match_length = w - 1, 0 !== r3 && e5.prev_length < e5.max_lazy_match && e5.strstart - r3 <= e5.w_size - x2 && (e5.match_length = D(e5, r3), e5.match_length <= 5 && (1 === e5.strategy || e5.match_length === w && e5.strstart - e5.match_start > 4096) && (e5.match_length = w - 1)), e5.prev_length >= w && e5.match_length <= e5.prev_length) {
        a3 = e5.strstart + e5.lookahead - w, n3 = i2._tr_tally(e5, e5.strstart - 1 - e5.prev_match, e5.prev_length - w), e5.lookahead -= e5.prev_length - 1, e5.prev_length -= 2;
        do {
          ++e5.strstart <= a3 && (e5.ins_h = (e5.ins_h << e5.hash_shift ^ e5.window[e5.strstart + w - 1]) & e5.hash_mask, r3 = e5.prev[e5.strstart & e5.w_mask] = e5.head[e5.ins_h], e5.head[e5.ins_h] = e5.strstart);
        } while (0 != --e5.prev_length);
        if (e5.match_available = 0, e5.match_length = w - 1, e5.strstart++, n3 && (F(e5, false), 0 === e5.strm.avail_out))
          return I;
      } else if (e5.match_available) {
        if ((n3 = i2._tr_tally(e5, 0, e5.window[e5.strstart - 1])) && F(e5, false), e5.strstart++, e5.lookahead--, 0 === e5.strm.avail_out)
          return I;
      } else
        e5.match_available = 1, e5.strstart++, e5.lookahead--;
    }
    return e5.match_available && (n3 = i2._tr_tally(e5, 0, e5.window[e5.strstart - 1]), e5.match_available = 0), e5.insert = e5.strstart < w - 1 ? e5.strstart : w - 1, t3 === s2 ? (F(e5, true), 0 === e5.strm.avail_out ? T2 : P) : e5.last_lit && (F(e5, false), 0 === e5.strm.avail_out) ? I : M2;
  }
  function Z(e5, t3, i3, r3, n3) {
    this.good_length = e5, this.max_lazy = t3, this.nice_length = i3, this.max_chain = r3, this.func = n3;
  }
  function j() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = d, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new t2.Buf16(2 * b2), this.dyn_dtree = new t2.Buf16(2 * (2 * _2 + 1)), this.bl_tree = new t2.Buf16(2 * (2 * g + 1)), R2(this.dyn_ltree), R2(this.dyn_dtree), R2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new t2.Buf16(y2 + 1), this.heap = new t2.Buf16(2 * m + 1), R2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new t2.Buf16(2 * m + 1), R2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  function G(e5) {
    var t3;
    return e5 && e5.state ? (e5.total_in = e5.total_out = 0, e5.data_type = f2, (t3 = e5.state).pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? E2 : S2, e5.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = o2, i2._tr_init(t3), l2) : B2(e5, u2);
  }
  function H(t3) {
    var i3 = G(t3);
    return i3 === l2 && function(t4) {
      t4.window_size = 2 * t4.w_size, R2(t4.head), t4.max_lazy_match = e4[t4.level].max_lazy, t4.good_match = e4[t4.level].good_length, t4.nice_match = e4[t4.level].nice_length, t4.max_chain_length = e4[t4.level].max_chain, t4.strstart = 0, t4.block_start = 0, t4.lookahead = 0, t4.insert = 0, t4.match_length = t4.prev_length = w - 1, t4.match_available = 0, t4.ins_h = 0;
    }(t3.state), i3;
  }
  function Q(e5, i3, r3, n3, a3, o3) {
    if (!e5)
      return u2;
    var s3 = 1;
    if (i3 === h2 && (i3 = 6), n3 < 0 ? (s3 = 0, n3 = -n3) : n3 > 15 && (s3 = 2, n3 -= 16), a3 < 1 || a3 > p2 || r3 !== d || n3 < 8 || n3 > 15 || i3 < 0 || i3 > 9 || o3 < 0 || o3 > c2)
      return B2(e5, u2);
    8 === n3 && (n3 = 9);
    var l3 = new j();
    return e5.state = l3, l3.strm = e5, l3.wrap = s3, l3.gzhead = null, l3.w_bits = n3, l3.w_size = 1 << l3.w_bits, l3.w_mask = l3.w_size - 1, l3.hash_bits = a3 + 7, l3.hash_size = 1 << l3.hash_bits, l3.hash_mask = l3.hash_size - 1, l3.hash_shift = ~~((l3.hash_bits + w - 1) / w), l3.window = new t2.Buf8(2 * l3.w_size), l3.head = new t2.Buf16(l3.hash_size), l3.prev = new t2.Buf16(l3.w_size), l3.lit_bufsize = 1 << a3 + 6, l3.pending_buf_size = 4 * l3.lit_bufsize, l3.pending_buf = new t2.Buf8(l3.pending_buf_size), l3.d_buf = 1 * l3.lit_bufsize, l3.l_buf = 3 * l3.lit_bufsize, l3.level = i3, l3.strategy = o3, l3.method = r3, H(e5);
  }
  return e4 = [new Z(0, 0, 0, 0, function(e5, t3) {
    var i3 = 65535;
    for (i3 > e5.pending_buf_size - 5 && (i3 = e5.pending_buf_size - 5); ; ) {
      if (e5.lookahead <= 1) {
        if ($(e5), 0 === e5.lookahead && t3 === o2)
          return I;
        if (0 === e5.lookahead)
          break;
      }
      e5.strstart += e5.lookahead, e5.lookahead = 0;
      var r3 = e5.block_start + i3;
      if ((0 === e5.strstart || e5.strstart >= r3) && (e5.lookahead = e5.strstart - r3, e5.strstart = r3, F(e5, false), 0 === e5.strm.avail_out))
        return I;
      if (e5.strstart - e5.block_start >= e5.w_size - x2 && (F(e5, false), 0 === e5.strm.avail_out))
        return I;
    }
    return e5.insert = 0, t3 === s2 ? (F(e5, true), 0 === e5.strm.avail_out ? T2 : P) : (e5.strstart > e5.block_start && (F(e5, false), e5.strm.avail_out), I);
  }), new Z(4, 4, 8, 4, L2), new Z(4, 5, 16, 8, L2), new Z(4, 6, 32, 32, L2), new Z(4, 4, 16, 16, U), new Z(8, 16, 32, 32, U), new Z(8, 16, 128, 128, U), new Z(8, 32, 128, 256, U), new Z(32, 128, 258, 1024, U), new Z(32, 258, 258, 4096, U)], deflate.deflateInit = function(e5, t3) {
    return Q(e5, t3, d, 15, 8, 0);
  }, deflate.deflateInit2 = Q, deflate.deflateReset = H, deflate.deflateResetKeep = G, deflate.deflateSetHeader = function(e5, t3) {
    return e5 && e5.state ? 2 !== e5.state.wrap ? u2 : (e5.state.gzhead = t3, l2) : u2;
  }, deflate.deflate = function(t3, r3) {
    var a3, h3, c3, f3;
    if (!t3 || !t3.state || r3 > 5 || r3 < 0)
      return t3 ? B2(t3, u2) : u2;
    if (h3 = t3.state, !t3.output || !t3.input && 0 !== t3.avail_in || h3.status === A2 && r3 !== s2)
      return B2(t3, 0 === t3.avail_out ? -5 : u2);
    if (h3.strm = t3, a3 = h3.last_flush, h3.last_flush = r3, h3.status === E2)
      if (2 === h3.wrap)
        t3.adler = 0, N2(h3, 31), N2(h3, 139), N2(h3, 8), h3.gzhead ? (N2(h3, (h3.gzhead.text ? 1 : 0) + (h3.gzhead.hcrc ? 2 : 0) + (h3.gzhead.extra ? 4 : 0) + (h3.gzhead.name ? 8 : 0) + (h3.gzhead.comment ? 16 : 0)), N2(h3, 255 & h3.gzhead.time), N2(h3, h3.gzhead.time >> 8 & 255), N2(h3, h3.gzhead.time >> 16 & 255), N2(h3, h3.gzhead.time >> 24 & 255), N2(h3, 9 === h3.level ? 2 : h3.strategy >= 2 || h3.level < 2 ? 4 : 0), N2(h3, 255 & h3.gzhead.os), h3.gzhead.extra && h3.gzhead.extra.length && (N2(h3, 255 & h3.gzhead.extra.length), N2(h3, h3.gzhead.extra.length >> 8 & 255)), h3.gzhead.hcrc && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending, 0)), h3.gzindex = 0, h3.status = 69) : (N2(h3, 0), N2(h3, 0), N2(h3, 0), N2(h3, 0), N2(h3, 0), N2(h3, 9 === h3.level ? 2 : h3.strategy >= 2 || h3.level < 2 ? 4 : 0), N2(h3, 3), h3.status = S2);
      else {
        var p3 = d + (h3.w_bits - 8 << 4) << 8;
        p3 |= (h3.strategy >= 2 || h3.level < 2 ? 0 : h3.level < 6 ? 1 : 6 === h3.level ? 2 : 3) << 6, 0 !== h3.strstart && (p3 |= 32), p3 += 31 - p3 % 31, h3.status = S2, O2(h3, p3), 0 !== h3.strstart && (O2(h3, t3.adler >>> 16), O2(h3, 65535 & t3.adler)), t3.adler = 1;
      }
    if (69 === h3.status)
      if (h3.gzhead.extra) {
        for (c3 = h3.pending; h3.gzindex < (65535 & h3.gzhead.extra.length) && (h3.pending !== h3.pending_buf_size || (h3.gzhead.hcrc && h3.pending > c3 && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending - c3, c3)), z2(t3), c3 = h3.pending, h3.pending !== h3.pending_buf_size)); )
          N2(h3, 255 & h3.gzhead.extra[h3.gzindex]), h3.gzindex++;
        h3.gzhead.hcrc && h3.pending > c3 && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending - c3, c3)), h3.gzindex === h3.gzhead.extra.length && (h3.gzindex = 0, h3.status = 73);
      } else
        h3.status = 73;
    if (73 === h3.status)
      if (h3.gzhead.name) {
        c3 = h3.pending;
        do {
          if (h3.pending === h3.pending_buf_size && (h3.gzhead.hcrc && h3.pending > c3 && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending - c3, c3)), z2(t3), c3 = h3.pending, h3.pending === h3.pending_buf_size)) {
            f3 = 1;
            break;
          }
          f3 = h3.gzindex < h3.gzhead.name.length ? 255 & h3.gzhead.name.charCodeAt(h3.gzindex++) : 0, N2(h3, f3);
        } while (0 !== f3);
        h3.gzhead.hcrc && h3.pending > c3 && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending - c3, c3)), 0 === f3 && (h3.gzindex = 0, h3.status = 91);
      } else
        h3.status = 91;
    if (91 === h3.status)
      if (h3.gzhead.comment) {
        c3 = h3.pending;
        do {
          if (h3.pending === h3.pending_buf_size && (h3.gzhead.hcrc && h3.pending > c3 && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending - c3, c3)), z2(t3), c3 = h3.pending, h3.pending === h3.pending_buf_size)) {
            f3 = 1;
            break;
          }
          f3 = h3.gzindex < h3.gzhead.comment.length ? 255 & h3.gzhead.comment.charCodeAt(h3.gzindex++) : 0, N2(h3, f3);
        } while (0 !== f3);
        h3.gzhead.hcrc && h3.pending > c3 && (t3.adler = n2(t3.adler, h3.pending_buf, h3.pending - c3, c3)), 0 === f3 && (h3.status = k2);
      } else
        h3.status = k2;
    if (h3.status === k2 && (h3.gzhead.hcrc ? (h3.pending + 2 > h3.pending_buf_size && z2(t3), h3.pending + 2 <= h3.pending_buf_size && (N2(h3, 255 & t3.adler), N2(h3, t3.adler >> 8 & 255), t3.adler = 0, h3.status = S2)) : h3.status = S2), 0 !== h3.pending) {
      if (z2(t3), 0 === t3.avail_out)
        return h3.last_flush = -1, l2;
    } else if (0 === t3.avail_in && C2(r3) <= C2(a3) && r3 !== s2)
      return B2(t3, -5);
    if (h3.status === A2 && 0 !== t3.avail_in)
      return B2(t3, -5);
    if (0 !== t3.avail_in || 0 !== h3.lookahead || r3 !== o2 && h3.status !== A2) {
      var m2 = 2 === h3.strategy ? function(e5, t4) {
        for (var r4; ; ) {
          if (0 === e5.lookahead && ($(e5), 0 === e5.lookahead)) {
            if (t4 === o2)
              return I;
            break;
          }
          if (e5.match_length = 0, r4 = i2._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++, r4 && (F(e5, false), 0 === e5.strm.avail_out))
            return I;
        }
        return e5.insert = 0, t4 === s2 ? (F(e5, true), 0 === e5.strm.avail_out ? T2 : P) : e5.last_lit && (F(e5, false), 0 === e5.strm.avail_out) ? I : M2;
      }(h3, r3) : 3 === h3.strategy ? function(e5, t4) {
        for (var r4, n3, a4, l3, u3 = e5.window; ; ) {
          if (e5.lookahead <= v2) {
            if ($(e5), e5.lookahead <= v2 && t4 === o2)
              return I;
            if (0 === e5.lookahead)
              break;
          }
          if (e5.match_length = 0, e5.lookahead >= w && e5.strstart > 0 && (n3 = u3[a4 = e5.strstart - 1]) === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4]) {
            l3 = e5.strstart + v2;
            do {
            } while (n3 === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4] && n3 === u3[++a4] && a4 < l3);
            e5.match_length = v2 - (l3 - a4), e5.match_length > e5.lookahead && (e5.match_length = e5.lookahead);
          }
          if (e5.match_length >= w ? (r4 = i2._tr_tally(e5, 1, e5.match_length - w), e5.lookahead -= e5.match_length, e5.strstart += e5.match_length, e5.match_length = 0) : (r4 = i2._tr_tally(e5, 0, e5.window[e5.strstart]), e5.lookahead--, e5.strstart++), r4 && (F(e5, false), 0 === e5.strm.avail_out))
            return I;
        }
        return e5.insert = 0, t4 === s2 ? (F(e5, true), 0 === e5.strm.avail_out ? T2 : P) : e5.last_lit && (F(e5, false), 0 === e5.strm.avail_out) ? I : M2;
      }(h3, r3) : e4[h3.level].func(h3, r3);
      if (m2 !== T2 && m2 !== P || (h3.status = A2), m2 === I || m2 === T2)
        return 0 === t3.avail_out && (h3.last_flush = -1), l2;
      if (m2 === M2 && (1 === r3 ? i2._tr_align(h3) : 5 !== r3 && (i2._tr_stored_block(h3, 0, 0, false), 3 === r3 && (R2(h3.head), 0 === h3.lookahead && (h3.strstart = 0, h3.block_start = 0, h3.insert = 0))), z2(t3), 0 === t3.avail_out))
        return h3.last_flush = -1, l2;
    }
    return r3 !== s2 ? l2 : h3.wrap <= 0 ? 1 : (2 === h3.wrap ? (N2(h3, 255 & t3.adler), N2(h3, t3.adler >> 8 & 255), N2(h3, t3.adler >> 16 & 255), N2(h3, t3.adler >> 24 & 255), N2(h3, 255 & t3.total_in), N2(h3, t3.total_in >> 8 & 255), N2(h3, t3.total_in >> 16 & 255), N2(h3, t3.total_in >> 24 & 255)) : (O2(h3, t3.adler >>> 16), O2(h3, 65535 & t3.adler)), z2(t3), h3.wrap > 0 && (h3.wrap = -h3.wrap), 0 !== h3.pending ? l2 : 1);
  }, deflate.deflateEnd = function(e5) {
    var t3;
    return e5 && e5.state ? (t3 = e5.state.status) !== E2 && 69 !== t3 && 73 !== t3 && 91 !== t3 && t3 !== k2 && t3 !== S2 && t3 !== A2 ? B2(e5, u2) : (e5.state = null, t3 === S2 ? B2(e5, -3) : l2) : u2;
  }, deflate.deflateSetDictionary = function(e5, i3) {
    var n3, a3, o3, s3, h3, c3, f3, d2, p3 = i3.length;
    if (!e5 || !e5.state)
      return u2;
    if (2 === (s3 = (n3 = e5.state).wrap) || 1 === s3 && n3.status !== E2 || n3.lookahead)
      return u2;
    for (1 === s3 && (e5.adler = r2(e5.adler, i3, p3, 0)), n3.wrap = 0, p3 >= n3.w_size && (0 === s3 && (R2(n3.head), n3.strstart = 0, n3.block_start = 0, n3.insert = 0), d2 = new t2.Buf8(n3.w_size), t2.arraySet(d2, i3, p3 - n3.w_size, n3.w_size, 0), i3 = d2, p3 = n3.w_size), h3 = e5.avail_in, c3 = e5.next_in, f3 = e5.input, e5.avail_in = p3, e5.next_in = 0, e5.input = i3, $(n3); n3.lookahead >= w; ) {
      a3 = n3.strstart, o3 = n3.lookahead - (w - 1);
      do {
        n3.ins_h = (n3.ins_h << n3.hash_shift ^ n3.window[a3 + w - 1]) & n3.hash_mask, n3.prev[a3 & n3.w_mask] = n3.head[n3.ins_h], n3.head[n3.ins_h] = a3, a3++;
      } while (--o3);
      n3.strstart = a3, n3.lookahead = w - 1, $(n3);
    }
    return n3.strstart += n3.lookahead, n3.block_start = n3.strstart, n3.insert = n3.lookahead, n3.lookahead = 0, n3.match_length = n3.prev_length = w - 1, n3.match_available = 0, e5.next_in = c3, e5.input = f3, e5.avail_in = h3, n3.wrap = s3, l2;
  }, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
}
var strings = {};
var hasRequiredStrings;
var zstream;
var hasRequiredZstream;
var hasRequiredDeflate;
function requireStrings() {
  if (hasRequiredStrings)
    return strings;
  hasRequiredStrings = 1;
  var e4 = requireCommon(), t2 = true, i2 = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (e5) {
    t2 = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (e5) {
    i2 = false;
  }
  for (var r2 = new e4.Buf8(256), n2 = 0; n2 < 256; n2++)
    r2[n2] = n2 >= 252 ? 6 : n2 >= 248 ? 5 : n2 >= 240 ? 4 : n2 >= 224 ? 3 : n2 >= 192 ? 2 : 1;
  function a2(r3, n3) {
    if (n3 < 65534 && (r3.subarray && i2 || !r3.subarray && t2))
      return String.fromCharCode.apply(null, e4.shrinkBuf(r3, n3));
    for (var a3 = "", o2 = 0; o2 < n3; o2++)
      a3 += String.fromCharCode(r3[o2]);
    return a3;
  }
  return r2[254] = r2[254] = 1, strings.string2buf = function(t3) {
    var i3, r3, n3, a3, o2, s2 = t3.length, l2 = 0;
    for (a3 = 0; a3 < s2; a3++)
      55296 == (64512 & (r3 = t3.charCodeAt(a3))) && a3 + 1 < s2 && 56320 == (64512 & (n3 = t3.charCodeAt(a3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), a3++), l2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
    for (i3 = new e4.Buf8(l2), o2 = 0, a3 = 0; o2 < l2; a3++)
      55296 == (64512 & (r3 = t3.charCodeAt(a3))) && a3 + 1 < s2 && 56320 == (64512 & (n3 = t3.charCodeAt(a3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), a3++), r3 < 128 ? i3[o2++] = r3 : r3 < 2048 ? (i3[o2++] = 192 | r3 >>> 6, i3[o2++] = 128 | 63 & r3) : r3 < 65536 ? (i3[o2++] = 224 | r3 >>> 12, i3[o2++] = 128 | r3 >>> 6 & 63, i3[o2++] = 128 | 63 & r3) : (i3[o2++] = 240 | r3 >>> 18, i3[o2++] = 128 | r3 >>> 12 & 63, i3[o2++] = 128 | r3 >>> 6 & 63, i3[o2++] = 128 | 63 & r3);
    return i3;
  }, strings.buf2binstring = function(e5) {
    return a2(e5, e5.length);
  }, strings.binstring2buf = function(t3) {
    for (var i3 = new e4.Buf8(t3.length), r3 = 0, n3 = i3.length; r3 < n3; r3++)
      i3[r3] = t3.charCodeAt(r3);
    return i3;
  }, strings.buf2string = function(e5, t3) {
    var i3, n3, o2, s2, l2 = t3 || e5.length, u2 = new Array(2 * l2);
    for (n3 = 0, i3 = 0; i3 < l2; )
      if ((o2 = e5[i3++]) < 128)
        u2[n3++] = o2;
      else if ((s2 = r2[o2]) > 4)
        u2[n3++] = 65533, i3 += s2 - 1;
      else {
        for (o2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; s2 > 1 && i3 < l2; )
          o2 = o2 << 6 | 63 & e5[i3++], s2--;
        s2 > 1 ? u2[n3++] = 65533 : o2 < 65536 ? u2[n3++] = o2 : (o2 -= 65536, u2[n3++] = 55296 | o2 >> 10 & 1023, u2[n3++] = 56320 | 1023 & o2);
      }
    return a2(u2, n3);
  }, strings.utf8border = function(e5, t3) {
    var i3;
    for ((t3 = t3 || e5.length) > e5.length && (t3 = e5.length), i3 = t3 - 1; i3 >= 0 && 128 == (192 & e5[i3]); )
      i3--;
    return i3 < 0 || 0 === i3 ? t3 : i3 + r2[e5[i3]] > t3 ? i3 : t3;
  }, strings;
}
function requireZstream() {
  if (hasRequiredZstream)
    return zstream;
  return hasRequiredZstream = 1, zstream = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  };
}
function requireDeflate() {
  if (hasRequiredDeflate)
    return deflate$1;
  hasRequiredDeflate = 1;
  var e4 = requireDeflate$1(), t2 = requireCommon(), i2 = requireStrings(), r2 = requireMessages(), n2 = requireZstream(), a2 = Object.prototype.toString, o2 = 0, s2 = -1, l2 = 0, u2 = 8;
  function h2(c3) {
    if (!(this instanceof h2))
      return new h2(c3);
    this.options = t2.assign({ level: s2, method: u2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: l2, to: "" }, c3 || {});
    var f2 = this.options;
    f2.raw && f2.windowBits > 0 ? f2.windowBits = -f2.windowBits : f2.gzip && f2.windowBits > 0 && f2.windowBits < 16 && (f2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n2(), this.strm.avail_out = 0;
    var d = e4.deflateInit2(this.strm, f2.level, f2.method, f2.windowBits, f2.memLevel, f2.strategy);
    if (d !== o2)
      throw new Error(r2[d]);
    if (f2.header && e4.deflateSetHeader(this.strm, f2.header), f2.dictionary) {
      var p2;
      if (p2 = "string" == typeof f2.dictionary ? i2.string2buf(f2.dictionary) : "[object ArrayBuffer]" === a2.call(f2.dictionary) ? new Uint8Array(f2.dictionary) : f2.dictionary, (d = e4.deflateSetDictionary(this.strm, p2)) !== o2)
        throw new Error(r2[d]);
      this._dict_set = true;
    }
  }
  function c2(e5, t3) {
    var i3 = new h2(t3);
    if (i3.push(e5, true), i3.err)
      throw i3.msg || r2[i3.err];
    return i3.result;
  }
  return h2.prototype.push = function(r3, n3) {
    var s3, l3, u3 = this.strm, h3 = this.options.chunkSize;
    if (this.ended)
      return false;
    l3 = n3 === ~~n3 ? n3 : true === n3 ? 4 : 0, "string" == typeof r3 ? u3.input = i2.string2buf(r3) : "[object ArrayBuffer]" === a2.call(r3) ? u3.input = new Uint8Array(r3) : u3.input = r3, u3.next_in = 0, u3.avail_in = u3.input.length;
    do {
      if (0 === u3.avail_out && (u3.output = new t2.Buf8(h3), u3.next_out = 0, u3.avail_out = h3), 1 !== (s3 = e4.deflate(u3, l3)) && s3 !== o2)
        return this.onEnd(s3), this.ended = true, false;
      0 !== u3.avail_out && (0 !== u3.avail_in || 4 !== l3 && 2 !== l3) || ("string" === this.options.to ? this.onData(i2.buf2binstring(t2.shrinkBuf(u3.output, u3.next_out))) : this.onData(t2.shrinkBuf(u3.output, u3.next_out)));
    } while ((u3.avail_in > 0 || 0 === u3.avail_out) && 1 !== s3);
    return 4 === l3 ? (s3 = e4.deflateEnd(this.strm), this.onEnd(s3), this.ended = true, s3 === o2) : 2 !== l3 || (this.onEnd(o2), u3.avail_out = 0, true);
  }, h2.prototype.onData = function(e5) {
    this.chunks.push(e5);
  }, h2.prototype.onEnd = function(e5) {
    e5 === o2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = t2.flattenChunks(this.chunks)), this.chunks = [], this.err = e5, this.msg = this.strm.msg;
  }, deflate$1.Deflate = h2, deflate$1.deflate = c2, deflate$1.deflateRaw = function(e5, t3) {
    return (t3 = t3 || {}).raw = true, c2(e5, t3);
  }, deflate$1.gzip = function(e5, t3) {
    return (t3 = t3 || {}).gzip = true, c2(e5, t3);
  }, deflate$1;
}
var inflate$1 = {};
var inflate = {};
var inffast;
var hasRequiredInffast;
var inftrees;
var hasRequiredInftrees;
var hasRequiredInflate$1;
var constants;
var hasRequiredConstants;
var gzheader;
var hasRequiredGzheader;
var hasRequiredInflate;
var pako_1;
var hasRequiredPako;
function requireInffast() {
  if (hasRequiredInffast)
    return inffast;
  hasRequiredInffast = 1;
  return inffast = function(e4, t2) {
    var i2, r2, n2, a2, o2, s2, l2, u2, h2, c2, f2, d, p2, m, _2, g, b2, y2, w, v2, x2, E2, k2, S2, A2;
    i2 = e4.state, r2 = e4.next_in, S2 = e4.input, n2 = r2 + (e4.avail_in - 5), a2 = e4.next_out, A2 = e4.output, o2 = a2 - (t2 - e4.avail_out), s2 = a2 + (e4.avail_out - 257), l2 = i2.dmax, u2 = i2.wsize, h2 = i2.whave, c2 = i2.wnext, f2 = i2.window, d = i2.hold, p2 = i2.bits, m = i2.lencode, _2 = i2.distcode, g = (1 << i2.lenbits) - 1, b2 = (1 << i2.distbits) - 1;
    e:
      do {
        p2 < 15 && (d += S2[r2++] << p2, p2 += 8, d += S2[r2++] << p2, p2 += 8), y2 = m[d & g];
        t:
          for (; ; ) {
            if (d >>>= w = y2 >>> 24, p2 -= w, 0 === (w = y2 >>> 16 & 255))
              A2[a2++] = 65535 & y2;
            else {
              if (!(16 & w)) {
                if (64 & w) {
                  if (32 & w) {
                    i2.mode = 12;
                    break e;
                  }
                  e4.msg = "invalid literal/length code", i2.mode = 30;
                  break e;
                }
                y2 = m[(65535 & y2) + (d & (1 << w) - 1)];
                continue t;
              }
              for (v2 = 65535 & y2, (w &= 15) && (p2 < w && (d += S2[r2++] << p2, p2 += 8), v2 += d & (1 << w) - 1, d >>>= w, p2 -= w), p2 < 15 && (d += S2[r2++] << p2, p2 += 8, d += S2[r2++] << p2, p2 += 8), y2 = _2[d & b2]; ; ) {
                if (d >>>= w = y2 >>> 24, p2 -= w, 16 & (w = y2 >>> 16 & 255)) {
                  if (x2 = 65535 & y2, p2 < (w &= 15) && (d += S2[r2++] << p2, (p2 += 8) < w && (d += S2[r2++] << p2, p2 += 8)), (x2 += d & (1 << w) - 1) > l2) {
                    e4.msg = "invalid distance too far back", i2.mode = 30;
                    break e;
                  }
                  if (d >>>= w, p2 -= w, x2 > (w = a2 - o2)) {
                    if ((w = x2 - w) > h2 && i2.sane) {
                      e4.msg = "invalid distance too far back", i2.mode = 30;
                      break e;
                    }
                    if (E2 = 0, k2 = f2, 0 === c2) {
                      if (E2 += u2 - w, w < v2) {
                        v2 -= w;
                        do {
                          A2[a2++] = f2[E2++];
                        } while (--w);
                        E2 = a2 - x2, k2 = A2;
                      }
                    } else if (c2 < w) {
                      if (E2 += u2 + c2 - w, (w -= c2) < v2) {
                        v2 -= w;
                        do {
                          A2[a2++] = f2[E2++];
                        } while (--w);
                        if (E2 = 0, c2 < v2) {
                          v2 -= w = c2;
                          do {
                            A2[a2++] = f2[E2++];
                          } while (--w);
                          E2 = a2 - x2, k2 = A2;
                        }
                      }
                    } else if (E2 += c2 - w, w < v2) {
                      v2 -= w;
                      do {
                        A2[a2++] = f2[E2++];
                      } while (--w);
                      E2 = a2 - x2, k2 = A2;
                    }
                    for (; v2 > 2; )
                      A2[a2++] = k2[E2++], A2[a2++] = k2[E2++], A2[a2++] = k2[E2++], v2 -= 3;
                    v2 && (A2[a2++] = k2[E2++], v2 > 1 && (A2[a2++] = k2[E2++]));
                  } else {
                    E2 = a2 - x2;
                    do {
                      A2[a2++] = A2[E2++], A2[a2++] = A2[E2++], A2[a2++] = A2[E2++], v2 -= 3;
                    } while (v2 > 2);
                    v2 && (A2[a2++] = A2[E2++], v2 > 1 && (A2[a2++] = A2[E2++]));
                  }
                  break;
                }
                if (64 & w) {
                  e4.msg = "invalid distance code", i2.mode = 30;
                  break e;
                }
                y2 = _2[(65535 & y2) + (d & (1 << w) - 1)];
              }
            }
            break;
          }
      } while (r2 < n2 && a2 < s2);
    r2 -= v2 = p2 >> 3, d &= (1 << (p2 -= v2 << 3)) - 1, e4.next_in = r2, e4.next_out = a2, e4.avail_in = r2 < n2 ? n2 - r2 + 5 : 5 - (r2 - n2), e4.avail_out = a2 < s2 ? s2 - a2 + 257 : 257 - (a2 - s2), i2.hold = d, i2.bits = p2;
  }, inffast;
}
function requireInftrees() {
  if (hasRequiredInftrees)
    return inftrees;
  hasRequiredInftrees = 1;
  var e4 = requireCommon(), t2 = 15, i2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], n2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], a2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  return inftrees = function(o2, s2, l2, u2, h2, c2, f2, d) {
    var p2, m, _2, g, b2, y2, w, v2, x2, E2 = d.bits, k2 = 0, S2 = 0, A2 = 0, I = 0, M2 = 0, T2 = 0, P = 0, B2 = 0, C2 = 0, R2 = 0, z2 = null, F = 0, N2 = new e4.Buf16(16), O2 = new e4.Buf16(16), D = null, $ = 0;
    for (k2 = 0; k2 <= t2; k2++)
      N2[k2] = 0;
    for (S2 = 0; S2 < u2; S2++)
      N2[s2[l2 + S2]]++;
    for (M2 = E2, I = t2; I >= 1 && 0 === N2[I]; I--)
      ;
    if (M2 > I && (M2 = I), 0 === I)
      return h2[c2++] = 20971520, h2[c2++] = 20971520, d.bits = 1, 0;
    for (A2 = 1; A2 < I && 0 === N2[A2]; A2++)
      ;
    for (M2 < A2 && (M2 = A2), B2 = 1, k2 = 1; k2 <= t2; k2++)
      if (B2 <<= 1, (B2 -= N2[k2]) < 0)
        return -1;
    if (B2 > 0 && (0 === o2 || 1 !== I))
      return -1;
    for (O2[1] = 0, k2 = 1; k2 < t2; k2++)
      O2[k2 + 1] = O2[k2] + N2[k2];
    for (S2 = 0; S2 < u2; S2++)
      0 !== s2[l2 + S2] && (f2[O2[s2[l2 + S2]]++] = S2);
    if (0 === o2 ? (z2 = D = f2, y2 = 19) : 1 === o2 ? (z2 = i2, F -= 257, D = r2, $ -= 257, y2 = 256) : (z2 = n2, D = a2, y2 = -1), R2 = 0, S2 = 0, k2 = A2, b2 = c2, T2 = M2, P = 0, _2 = -1, g = (C2 = 1 << M2) - 1, 1 === o2 && C2 > 852 || 2 === o2 && C2 > 592)
      return 1;
    for (; ; ) {
      w = k2 - P, f2[S2] < y2 ? (v2 = 0, x2 = f2[S2]) : f2[S2] > y2 ? (v2 = D[$ + f2[S2]], x2 = z2[F + f2[S2]]) : (v2 = 96, x2 = 0), p2 = 1 << k2 - P, A2 = m = 1 << T2;
      do {
        h2[b2 + (R2 >> P) + (m -= p2)] = w << 24 | v2 << 16 | x2;
      } while (0 !== m);
      for (p2 = 1 << k2 - 1; R2 & p2; )
        p2 >>= 1;
      if (0 !== p2 ? (R2 &= p2 - 1, R2 += p2) : R2 = 0, S2++, 0 == --N2[k2]) {
        if (k2 === I)
          break;
        k2 = s2[l2 + f2[S2]];
      }
      if (k2 > M2 && (R2 & g) !== _2) {
        for (0 === P && (P = M2), b2 += A2, B2 = 1 << (T2 = k2 - P); T2 + P < I && !((B2 -= N2[T2 + P]) <= 0); )
          T2++, B2 <<= 1;
        if (C2 += 1 << T2, 1 === o2 && C2 > 852 || 2 === o2 && C2 > 592)
          return 1;
        h2[_2 = R2 & g] = M2 << 24 | T2 << 16 | b2 - c2;
      }
    }
    return 0 !== R2 && (h2[b2 + R2] = k2 - P << 24 | 64 << 16), d.bits = M2, 0;
  };
}
function requireInflate$1() {
  if (hasRequiredInflate$1)
    return inflate;
  hasRequiredInflate$1 = 1;
  var e4 = requireCommon(), t2 = requireAdler32(), i2 = requireCrc32(), r2 = requireInffast(), n2 = requireInftrees(), a2 = 1, o2 = 2, s2 = 0, l2 = -2, u2 = 1, h2 = 12, c2 = 30, f2 = 852, d = 592;
  function p2(e5) {
    return (e5 >>> 24 & 255) + (e5 >>> 8 & 65280) + ((65280 & e5) << 8) + ((255 & e5) << 24);
  }
  function m() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e4.Buf16(320), this.work = new e4.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  function _2(t3) {
    var i3;
    return t3 && t3.state ? (i3 = t3.state, t3.total_in = t3.total_out = i3.total = 0, t3.msg = "", i3.wrap && (t3.adler = 1 & i3.wrap), i3.mode = u2, i3.last = 0, i3.havedict = 0, i3.dmax = 32768, i3.head = null, i3.hold = 0, i3.bits = 0, i3.lencode = i3.lendyn = new e4.Buf32(f2), i3.distcode = i3.distdyn = new e4.Buf32(d), i3.sane = 1, i3.back = -1, s2) : l2;
  }
  function g(e5) {
    var t3;
    return e5 && e5.state ? ((t3 = e5.state).wsize = 0, t3.whave = 0, t3.wnext = 0, _2(e5)) : l2;
  }
  function b2(e5, t3) {
    var i3, r3;
    return e5 && e5.state ? (r3 = e5.state, t3 < 0 ? (i3 = 0, t3 = -t3) : (i3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? l2 : (null !== r3.window && r3.wbits !== t3 && (r3.window = null), r3.wrap = i3, r3.wbits = t3, g(e5))) : l2;
  }
  function y2(e5, t3) {
    var i3, r3;
    return e5 ? (r3 = new m(), e5.state = r3, r3.window = null, (i3 = b2(e5, t3)) !== s2 && (e5.state = null), i3) : l2;
  }
  var w, v2, x2 = true;
  function E2(t3) {
    if (x2) {
      var i3;
      for (w = new e4.Buf32(512), v2 = new e4.Buf32(32), i3 = 0; i3 < 144; )
        t3.lens[i3++] = 8;
      for (; i3 < 256; )
        t3.lens[i3++] = 9;
      for (; i3 < 280; )
        t3.lens[i3++] = 7;
      for (; i3 < 288; )
        t3.lens[i3++] = 8;
      for (n2(a2, t3.lens, 0, 288, w, 0, t3.work, { bits: 9 }), i3 = 0; i3 < 32; )
        t3.lens[i3++] = 5;
      n2(o2, t3.lens, 0, 32, v2, 0, t3.work, { bits: 5 }), x2 = false;
    }
    t3.lencode = w, t3.lenbits = 9, t3.distcode = v2, t3.distbits = 5;
  }
  function k2(t3, i3, r3, n3) {
    var a3, o3 = t3.state;
    return null === o3.window && (o3.wsize = 1 << o3.wbits, o3.wnext = 0, o3.whave = 0, o3.window = new e4.Buf8(o3.wsize)), n3 >= o3.wsize ? (e4.arraySet(o3.window, i3, r3 - o3.wsize, o3.wsize, 0), o3.wnext = 0, o3.whave = o3.wsize) : ((a3 = o3.wsize - o3.wnext) > n3 && (a3 = n3), e4.arraySet(o3.window, i3, r3 - n3, a3, o3.wnext), (n3 -= a3) ? (e4.arraySet(o3.window, i3, r3 - n3, n3, 0), o3.wnext = n3, o3.whave = o3.wsize) : (o3.wnext += a3, o3.wnext === o3.wsize && (o3.wnext = 0), o3.whave < o3.wsize && (o3.whave += a3))), 0;
  }
  return inflate.inflateReset = g, inflate.inflateReset2 = b2, inflate.inflateResetKeep = _2, inflate.inflateInit = function(e5) {
    return y2(e5, 15);
  }, inflate.inflateInit2 = y2, inflate.inflate = function(f3, d2) {
    var m2, _3, g2, b3, y3, w2, v3, x3, S2, A2, I, M2, T2, P, B2, C2, R2, z2, F, N2, O2, D, $, L2, U = 0, Z = new e4.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!f3 || !f3.state || !f3.output || !f3.input && 0 !== f3.avail_in)
      return l2;
    (m2 = f3.state).mode === h2 && (m2.mode = 13), y3 = f3.next_out, g2 = f3.output, v3 = f3.avail_out, b3 = f3.next_in, _3 = f3.input, w2 = f3.avail_in, x3 = m2.hold, S2 = m2.bits, A2 = w2, I = v3, D = s2;
    e:
      for (; ; )
        switch (m2.mode) {
          case u2:
            if (0 === m2.wrap) {
              m2.mode = 13;
              break;
            }
            for (; S2 < 16; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            if (2 & m2.wrap && 35615 === x3) {
              m2.check = 0, Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0), x3 = 0, S2 = 0, m2.mode = 2;
              break;
            }
            if (m2.flags = 0, m2.head && (m2.head.done = false), !(1 & m2.wrap) || (((255 & x3) << 8) + (x3 >> 8)) % 31) {
              f3.msg = "incorrect header check", m2.mode = c2;
              break;
            }
            if (8 != (15 & x3)) {
              f3.msg = "unknown compression method", m2.mode = c2;
              break;
            }
            if (S2 -= 4, O2 = 8 + (15 & (x3 >>>= 4)), 0 === m2.wbits)
              m2.wbits = O2;
            else if (O2 > m2.wbits) {
              f3.msg = "invalid window size", m2.mode = c2;
              break;
            }
            m2.dmax = 1 << O2, f3.adler = m2.check = 1, m2.mode = 512 & x3 ? 10 : h2, x3 = 0, S2 = 0;
            break;
          case 2:
            for (; S2 < 16; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            if (m2.flags = x3, 8 != (255 & m2.flags)) {
              f3.msg = "unknown compression method", m2.mode = c2;
              break;
            }
            if (57344 & m2.flags) {
              f3.msg = "unknown header flags set", m2.mode = c2;
              break;
            }
            m2.head && (m2.head.text = x3 >> 8 & 1), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0)), x3 = 0, S2 = 0, m2.mode = 3;
          case 3:
            for (; S2 < 32; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            m2.head && (m2.head.time = x3), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, Z[2] = x3 >>> 16 & 255, Z[3] = x3 >>> 24 & 255, m2.check = i2(m2.check, Z, 4, 0)), x3 = 0, S2 = 0, m2.mode = 4;
          case 4:
            for (; S2 < 16; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            m2.head && (m2.head.xflags = 255 & x3, m2.head.os = x3 >> 8), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0)), x3 = 0, S2 = 0, m2.mode = 5;
          case 5:
            if (1024 & m2.flags) {
              for (; S2 < 16; ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              m2.length = x3, m2.head && (m2.head.extra_len = x3), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0)), x3 = 0, S2 = 0;
            } else
              m2.head && (m2.head.extra = null);
            m2.mode = 6;
          case 6:
            if (1024 & m2.flags && ((M2 = m2.length) > w2 && (M2 = w2), M2 && (m2.head && (O2 = m2.head.extra_len - m2.length, m2.head.extra || (m2.head.extra = new Array(m2.head.extra_len)), e4.arraySet(m2.head.extra, _3, b3, M2, O2)), 512 & m2.flags && (m2.check = i2(m2.check, _3, M2, b3)), w2 -= M2, b3 += M2, m2.length -= M2), m2.length))
              break e;
            m2.length = 0, m2.mode = 7;
          case 7:
            if (2048 & m2.flags) {
              if (0 === w2)
                break e;
              M2 = 0;
              do {
                O2 = _3[b3 + M2++], m2.head && O2 && m2.length < 65536 && (m2.head.name += String.fromCharCode(O2));
              } while (O2 && M2 < w2);
              if (512 & m2.flags && (m2.check = i2(m2.check, _3, M2, b3)), w2 -= M2, b3 += M2, O2)
                break e;
            } else
              m2.head && (m2.head.name = null);
            m2.length = 0, m2.mode = 8;
          case 8:
            if (4096 & m2.flags) {
              if (0 === w2)
                break e;
              M2 = 0;
              do {
                O2 = _3[b3 + M2++], m2.head && O2 && m2.length < 65536 && (m2.head.comment += String.fromCharCode(O2));
              } while (O2 && M2 < w2);
              if (512 & m2.flags && (m2.check = i2(m2.check, _3, M2, b3)), w2 -= M2, b3 += M2, O2)
                break e;
            } else
              m2.head && (m2.head.comment = null);
            m2.mode = 9;
          case 9:
            if (512 & m2.flags) {
              for (; S2 < 16; ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              if (x3 !== (65535 & m2.check)) {
                f3.msg = "header crc mismatch", m2.mode = c2;
                break;
              }
              x3 = 0, S2 = 0;
            }
            m2.head && (m2.head.hcrc = m2.flags >> 9 & 1, m2.head.done = true), f3.adler = m2.check = 0, m2.mode = h2;
            break;
          case 10:
            for (; S2 < 32; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            f3.adler = m2.check = p2(x3), x3 = 0, S2 = 0, m2.mode = 11;
          case 11:
            if (0 === m2.havedict)
              return f3.next_out = y3, f3.avail_out = v3, f3.next_in = b3, f3.avail_in = w2, m2.hold = x3, m2.bits = S2, 2;
            f3.adler = m2.check = 1, m2.mode = h2;
          case h2:
            if (5 === d2 || 6 === d2)
              break e;
          case 13:
            if (m2.last) {
              x3 >>>= 7 & S2, S2 -= 7 & S2, m2.mode = 27;
              break;
            }
            for (; S2 < 3; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            switch (m2.last = 1 & x3, S2 -= 1, 3 & (x3 >>>= 1)) {
              case 0:
                m2.mode = 14;
                break;
              case 1:
                if (E2(m2), m2.mode = 20, 6 === d2) {
                  x3 >>>= 2, S2 -= 2;
                  break e;
                }
                break;
              case 2:
                m2.mode = 17;
                break;
              case 3:
                f3.msg = "invalid block type", m2.mode = c2;
            }
            x3 >>>= 2, S2 -= 2;
            break;
          case 14:
            for (x3 >>>= 7 & S2, S2 -= 7 & S2; S2 < 32; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            if ((65535 & x3) != (x3 >>> 16 ^ 65535)) {
              f3.msg = "invalid stored block lengths", m2.mode = c2;
              break;
            }
            if (m2.length = 65535 & x3, x3 = 0, S2 = 0, m2.mode = 15, 6 === d2)
              break e;
          case 15:
            m2.mode = 16;
          case 16:
            if (M2 = m2.length) {
              if (M2 > w2 && (M2 = w2), M2 > v3 && (M2 = v3), 0 === M2)
                break e;
              e4.arraySet(g2, _3, b3, M2, y3), w2 -= M2, b3 += M2, v3 -= M2, y3 += M2, m2.length -= M2;
              break;
            }
            m2.mode = h2;
            break;
          case 17:
            for (; S2 < 14; ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            if (m2.nlen = 257 + (31 & x3), x3 >>>= 5, S2 -= 5, m2.ndist = 1 + (31 & x3), x3 >>>= 5, S2 -= 5, m2.ncode = 4 + (15 & x3), x3 >>>= 4, S2 -= 4, m2.nlen > 286 || m2.ndist > 30) {
              f3.msg = "too many length or distance symbols", m2.mode = c2;
              break;
            }
            m2.have = 0, m2.mode = 18;
          case 18:
            for (; m2.have < m2.ncode; ) {
              for (; S2 < 3; ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              m2.lens[j[m2.have++]] = 7 & x3, x3 >>>= 3, S2 -= 3;
            }
            for (; m2.have < 19; )
              m2.lens[j[m2.have++]] = 0;
            if (m2.lencode = m2.lendyn, m2.lenbits = 7, $ = { bits: m2.lenbits }, D = n2(0, m2.lens, 0, 19, m2.lencode, 0, m2.work, $), m2.lenbits = $.bits, D) {
              f3.msg = "invalid code lengths set", m2.mode = c2;
              break;
            }
            m2.have = 0, m2.mode = 19;
          case 19:
            for (; m2.have < m2.nlen + m2.ndist; ) {
              for (; C2 = (U = m2.lencode[x3 & (1 << m2.lenbits) - 1]) >>> 16 & 255, R2 = 65535 & U, !((B2 = U >>> 24) <= S2); ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              if (R2 < 16)
                x3 >>>= B2, S2 -= B2, m2.lens[m2.have++] = R2;
              else {
                if (16 === R2) {
                  for (L2 = B2 + 2; S2 < L2; ) {
                    if (0 === w2)
                      break e;
                    w2--, x3 += _3[b3++] << S2, S2 += 8;
                  }
                  if (x3 >>>= B2, S2 -= B2, 0 === m2.have) {
                    f3.msg = "invalid bit length repeat", m2.mode = c2;
                    break;
                  }
                  O2 = m2.lens[m2.have - 1], M2 = 3 + (3 & x3), x3 >>>= 2, S2 -= 2;
                } else if (17 === R2) {
                  for (L2 = B2 + 3; S2 < L2; ) {
                    if (0 === w2)
                      break e;
                    w2--, x3 += _3[b3++] << S2, S2 += 8;
                  }
                  S2 -= B2, O2 = 0, M2 = 3 + (7 & (x3 >>>= B2)), x3 >>>= 3, S2 -= 3;
                } else {
                  for (L2 = B2 + 7; S2 < L2; ) {
                    if (0 === w2)
                      break e;
                    w2--, x3 += _3[b3++] << S2, S2 += 8;
                  }
                  S2 -= B2, O2 = 0, M2 = 11 + (127 & (x3 >>>= B2)), x3 >>>= 7, S2 -= 7;
                }
                if (m2.have + M2 > m2.nlen + m2.ndist) {
                  f3.msg = "invalid bit length repeat", m2.mode = c2;
                  break;
                }
                for (; M2--; )
                  m2.lens[m2.have++] = O2;
              }
            }
            if (m2.mode === c2)
              break;
            if (0 === m2.lens[256]) {
              f3.msg = "invalid code -- missing end-of-block", m2.mode = c2;
              break;
            }
            if (m2.lenbits = 9, $ = { bits: m2.lenbits }, D = n2(a2, m2.lens, 0, m2.nlen, m2.lencode, 0, m2.work, $), m2.lenbits = $.bits, D) {
              f3.msg = "invalid literal/lengths set", m2.mode = c2;
              break;
            }
            if (m2.distbits = 6, m2.distcode = m2.distdyn, $ = { bits: m2.distbits }, D = n2(o2, m2.lens, m2.nlen, m2.ndist, m2.distcode, 0, m2.work, $), m2.distbits = $.bits, D) {
              f3.msg = "invalid distances set", m2.mode = c2;
              break;
            }
            if (m2.mode = 20, 6 === d2)
              break e;
          case 20:
            m2.mode = 21;
          case 21:
            if (w2 >= 6 && v3 >= 258) {
              f3.next_out = y3, f3.avail_out = v3, f3.next_in = b3, f3.avail_in = w2, m2.hold = x3, m2.bits = S2, r2(f3, I), y3 = f3.next_out, g2 = f3.output, v3 = f3.avail_out, b3 = f3.next_in, _3 = f3.input, w2 = f3.avail_in, x3 = m2.hold, S2 = m2.bits, m2.mode === h2 && (m2.back = -1);
              break;
            }
            for (m2.back = 0; C2 = (U = m2.lencode[x3 & (1 << m2.lenbits) - 1]) >>> 16 & 255, R2 = 65535 & U, !((B2 = U >>> 24) <= S2); ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            if (C2 && !(240 & C2)) {
              for (z2 = B2, F = C2, N2 = R2; C2 = (U = m2.lencode[N2 + ((x3 & (1 << z2 + F) - 1) >> z2)]) >>> 16 & 255, R2 = 65535 & U, !(z2 + (B2 = U >>> 24) <= S2); ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              x3 >>>= z2, S2 -= z2, m2.back += z2;
            }
            if (x3 >>>= B2, S2 -= B2, m2.back += B2, m2.length = R2, 0 === C2) {
              m2.mode = 26;
              break;
            }
            if (32 & C2) {
              m2.back = -1, m2.mode = h2;
              break;
            }
            if (64 & C2) {
              f3.msg = "invalid literal/length code", m2.mode = c2;
              break;
            }
            m2.extra = 15 & C2, m2.mode = 22;
          case 22:
            if (m2.extra) {
              for (L2 = m2.extra; S2 < L2; ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              m2.length += x3 & (1 << m2.extra) - 1, x3 >>>= m2.extra, S2 -= m2.extra, m2.back += m2.extra;
            }
            m2.was = m2.length, m2.mode = 23;
          case 23:
            for (; C2 = (U = m2.distcode[x3 & (1 << m2.distbits) - 1]) >>> 16 & 255, R2 = 65535 & U, !((B2 = U >>> 24) <= S2); ) {
              if (0 === w2)
                break e;
              w2--, x3 += _3[b3++] << S2, S2 += 8;
            }
            if (!(240 & C2)) {
              for (z2 = B2, F = C2, N2 = R2; C2 = (U = m2.distcode[N2 + ((x3 & (1 << z2 + F) - 1) >> z2)]) >>> 16 & 255, R2 = 65535 & U, !(z2 + (B2 = U >>> 24) <= S2); ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              x3 >>>= z2, S2 -= z2, m2.back += z2;
            }
            if (x3 >>>= B2, S2 -= B2, m2.back += B2, 64 & C2) {
              f3.msg = "invalid distance code", m2.mode = c2;
              break;
            }
            m2.offset = R2, m2.extra = 15 & C2, m2.mode = 24;
          case 24:
            if (m2.extra) {
              for (L2 = m2.extra; S2 < L2; ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              m2.offset += x3 & (1 << m2.extra) - 1, x3 >>>= m2.extra, S2 -= m2.extra, m2.back += m2.extra;
            }
            if (m2.offset > m2.dmax) {
              f3.msg = "invalid distance too far back", m2.mode = c2;
              break;
            }
            m2.mode = 25;
          case 25:
            if (0 === v3)
              break e;
            if (M2 = I - v3, m2.offset > M2) {
              if ((M2 = m2.offset - M2) > m2.whave && m2.sane) {
                f3.msg = "invalid distance too far back", m2.mode = c2;
                break;
              }
              M2 > m2.wnext ? (M2 -= m2.wnext, T2 = m2.wsize - M2) : T2 = m2.wnext - M2, M2 > m2.length && (M2 = m2.length), P = m2.window;
            } else
              P = g2, T2 = y3 - m2.offset, M2 = m2.length;
            M2 > v3 && (M2 = v3), v3 -= M2, m2.length -= M2;
            do {
              g2[y3++] = P[T2++];
            } while (--M2);
            0 === m2.length && (m2.mode = 21);
            break;
          case 26:
            if (0 === v3)
              break e;
            g2[y3++] = m2.length, v3--, m2.mode = 21;
            break;
          case 27:
            if (m2.wrap) {
              for (; S2 < 32; ) {
                if (0 === w2)
                  break e;
                w2--, x3 |= _3[b3++] << S2, S2 += 8;
              }
              if (I -= v3, f3.total_out += I, m2.total += I, I && (f3.adler = m2.check = m2.flags ? i2(m2.check, g2, I, y3 - I) : t2(m2.check, g2, I, y3 - I)), I = v3, (m2.flags ? x3 : p2(x3)) !== m2.check) {
                f3.msg = "incorrect data check", m2.mode = c2;
                break;
              }
              x3 = 0, S2 = 0;
            }
            m2.mode = 28;
          case 28:
            if (m2.wrap && m2.flags) {
              for (; S2 < 32; ) {
                if (0 === w2)
                  break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              if (x3 !== (4294967295 & m2.total)) {
                f3.msg = "incorrect length check", m2.mode = c2;
                break;
              }
              x3 = 0, S2 = 0;
            }
            m2.mode = 29;
          case 29:
            D = 1;
            break e;
          case c2:
            D = -3;
            break e;
          case 31:
            return -4;
          default:
            return l2;
        }
    return f3.next_out = y3, f3.avail_out = v3, f3.next_in = b3, f3.avail_in = w2, m2.hold = x3, m2.bits = S2, (m2.wsize || I !== f3.avail_out && m2.mode < c2 && (m2.mode < 27 || 4 !== d2)) && k2(f3, f3.output, f3.next_out, I - f3.avail_out), A2 -= f3.avail_in, I -= f3.avail_out, f3.total_in += A2, f3.total_out += I, m2.total += I, m2.wrap && I && (f3.adler = m2.check = m2.flags ? i2(m2.check, g2, I, f3.next_out - I) : t2(m2.check, g2, I, f3.next_out - I)), f3.data_type = m2.bits + (m2.last ? 64 : 0) + (m2.mode === h2 ? 128 : 0) + (20 === m2.mode || 15 === m2.mode ? 256 : 0), (0 === A2 && 0 === I || 4 === d2) && D === s2 && (D = -5), D;
  }, inflate.inflateEnd = function(e5) {
    if (!e5 || !e5.state)
      return l2;
    var t3 = e5.state;
    return t3.window && (t3.window = null), e5.state = null, s2;
  }, inflate.inflateGetHeader = function(e5, t3) {
    var i3;
    return e5 && e5.state && 2 & (i3 = e5.state).wrap ? (i3.head = t3, t3.done = false, s2) : l2;
  }, inflate.inflateSetDictionary = function(e5, i3) {
    var r3, n3 = i3.length;
    return e5 && e5.state ? 0 !== (r3 = e5.state).wrap && 11 !== r3.mode ? l2 : 11 === r3.mode && t2(1, i3, n3, 0) !== r3.check ? -3 : k2(e5, i3, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, s2) : l2;
  }, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
}
function requireConstants() {
  return hasRequiredConstants ? constants : (hasRequiredConstants = 1, constants = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 });
}
function requireGzheader() {
  if (hasRequiredGzheader)
    return gzheader;
  return hasRequiredGzheader = 1, gzheader = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
  };
}
function requireInflate() {
  if (hasRequiredInflate)
    return inflate$1;
  hasRequiredInflate = 1;
  var e4 = requireInflate$1(), t2 = requireCommon(), i2 = requireStrings(), r2 = requireConstants(), n2 = requireMessages(), a2 = requireZstream(), o2 = requireGzheader(), s2 = Object.prototype.toString;
  function l2(u3) {
    if (!(this instanceof l2))
      return new l2(u3);
    this.options = t2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, u3 || {});
    var h2 = this.options;
    h2.raw && h2.windowBits >= 0 && h2.windowBits < 16 && (h2.windowBits = -h2.windowBits, 0 === h2.windowBits && (h2.windowBits = -15)), !(h2.windowBits >= 0 && h2.windowBits < 16) || u3 && u3.windowBits || (h2.windowBits += 32), h2.windowBits > 15 && h2.windowBits < 48 && (15 & h2.windowBits || (h2.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new a2(), this.strm.avail_out = 0;
    var c2 = e4.inflateInit2(this.strm, h2.windowBits);
    if (c2 !== r2.Z_OK)
      throw new Error(n2[c2]);
    if (this.header = new o2(), e4.inflateGetHeader(this.strm, this.header), h2.dictionary && ("string" == typeof h2.dictionary ? h2.dictionary = i2.string2buf(h2.dictionary) : "[object ArrayBuffer]" === s2.call(h2.dictionary) && (h2.dictionary = new Uint8Array(h2.dictionary)), h2.raw && (c2 = e4.inflateSetDictionary(this.strm, h2.dictionary)) !== r2.Z_OK))
      throw new Error(n2[c2]);
  }
  function u2(e5, t3) {
    var i3 = new l2(t3);
    if (i3.push(e5, true), i3.err)
      throw i3.msg || n2[i3.err];
    return i3.result;
  }
  return l2.prototype.push = function(n3, a3) {
    var o3, l3, u3, h2, c2, f2 = this.strm, d = this.options.chunkSize, p2 = this.options.dictionary, m = false;
    if (this.ended)
      return false;
    l3 = a3 === ~~a3 ? a3 : true === a3 ? r2.Z_FINISH : r2.Z_NO_FLUSH, "string" == typeof n3 ? f2.input = i2.binstring2buf(n3) : "[object ArrayBuffer]" === s2.call(n3) ? f2.input = new Uint8Array(n3) : f2.input = n3, f2.next_in = 0, f2.avail_in = f2.input.length;
    do {
      if (0 === f2.avail_out && (f2.output = new t2.Buf8(d), f2.next_out = 0, f2.avail_out = d), (o3 = e4.inflate(f2, r2.Z_NO_FLUSH)) === r2.Z_NEED_DICT && p2 && (o3 = e4.inflateSetDictionary(this.strm, p2)), o3 === r2.Z_BUF_ERROR && true === m && (o3 = r2.Z_OK, m = false), o3 !== r2.Z_STREAM_END && o3 !== r2.Z_OK)
        return this.onEnd(o3), this.ended = true, false;
      f2.next_out && (0 !== f2.avail_out && o3 !== r2.Z_STREAM_END && (0 !== f2.avail_in || l3 !== r2.Z_FINISH && l3 !== r2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (u3 = i2.utf8border(f2.output, f2.next_out), h2 = f2.next_out - u3, c2 = i2.buf2string(f2.output, u3), f2.next_out = h2, f2.avail_out = d - h2, h2 && t2.arraySet(f2.output, f2.output, u3, h2, 0), this.onData(c2)) : this.onData(t2.shrinkBuf(f2.output, f2.next_out)))), 0 === f2.avail_in && 0 === f2.avail_out && (m = true);
    } while ((f2.avail_in > 0 || 0 === f2.avail_out) && o3 !== r2.Z_STREAM_END);
    return o3 === r2.Z_STREAM_END && (l3 = r2.Z_FINISH), l3 === r2.Z_FINISH ? (o3 = e4.inflateEnd(this.strm), this.onEnd(o3), this.ended = true, o3 === r2.Z_OK) : l3 !== r2.Z_SYNC_FLUSH || (this.onEnd(r2.Z_OK), f2.avail_out = 0, true);
  }, l2.prototype.onData = function(e5) {
    this.chunks.push(e5);
  }, l2.prototype.onEnd = function(e5) {
    e5 === r2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = t2.flattenChunks(this.chunks)), this.chunks = [], this.err = e5, this.msg = this.strm.msg;
  }, inflate$1.Inflate = l2, inflate$1.inflate = u2, inflate$1.inflateRaw = function(e5, t3) {
    return (t3 = t3 || {}).raw = true, u2(e5, t3);
  }, inflate$1.ungzip = u2, inflate$1;
}
function requirePako() {
  if (hasRequiredPako)
    return pako_1;
  hasRequiredPako = 1;
  var e4 = {};
  return (0, requireCommon().assign)(e4, requireDeflate(), requireInflate(), requireConstants()), pako_1 = e4;
}
!function(e4) {
  !function() {
    var t2 = {};
    function i2() {
      "undefined" != typeof process && false || console.log.apply(console, arguments);
    }
    e4.exports = t2, function(e5, t3) {
      !function() {
        var t4 = function() {
          function e6(e7) {
            this.message = "JPEG error: " + e7;
          }
          return e6.prototype = new Error(), e6.prototype.name = "JpegError", e6.constructor = e6, e6;
        }(), i3 = function() {
          var e6 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), i4 = 4017, n2 = 799, a2 = 3406, o2 = 2276, s2 = 1567, l2 = 3784, u2 = 5793, h2 = 2896;
          function c2(e7) {
            null == e7 && (e7 = {}), null == e7.w && (e7.w = -1), this.V = e7.n, this.N = e7.w;
          }
          function f2(e7, t5) {
            for (var i5, r3, n3, a3 = 0, o3 = [], s3 = 16; s3 > 0 && !e7[s3 - 1]; )
              s3--;
            o3.push({ children: [], index: 0 });
            var l3 = o3[0];
            for (i5 = 0; i5 < s3; i5++) {
              for (r3 = 0; r3 < e7[i5]; r3++) {
                for ((l3 = o3.pop()).children[l3.index] = t5[a3]; l3.index > 0; )
                  l3 = o3.pop();
                for (l3.index++, o3.push(l3); o3.length <= i5; )
                  o3.push(n3 = { children: [], index: 0 }), l3.children[l3.index] = n3.children, l3 = n3;
                a3++;
              }
              i5 + 1 < s3 && (o3.push(n3 = { children: [], index: 0 }), l3.children[l3.index] = n3.children, l3 = n3);
            }
            return o3[0].children;
          }
          function d(e7, t5, i5) {
            return 64 * ((e7.P + 1) * t5 + i5);
          }
          function p2(i5, n3, a3, o3, s3, l3, u3, h3, c3, f3) {
            null == f3 && (f3 = false);
            var p3, m2, _3, b2, y2, w, v2, x2, E2, k2, S2, A2 = a3.m, I = a3.Z, M2 = n3, T2 = 0, P = 0, B2 = 0, C2 = 0, R2 = 0, z2 = 0;
            function F() {
              if (P > 0)
                return P--, T2 >> P & 1;
              if (255 === (T2 = i5[n3++])) {
                var e7 = i5[n3++];
                if (e7) {
                  if (220 === e7 && f3) {
                    var o4 = r2(i5, n3 += 2);
                    if (n3 += 2, o4 > 0 && o4 !== a3.s)
                      throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", o4);
                  } else if (217 === e7) {
                    if (f3) {
                      var s4 = 8 * R2;
                      if (s4 > 0 && s4 < a3.s / 10)
                        throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", s4);
                    }
                    throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                  }
                  throw new t4("unexpected marker");
                }
              }
              return P = 7, T2 >>> 7;
            }
            function N2(e7) {
              for (var i6 = e7; ; ) {
                switch (typeof (i6 = i6[F()])) {
                  case "number":
                    return i6;
                  case "object":
                    continue;
                }
                throw new t4("invalid huffman sequence");
              }
            }
            function O2(e7) {
              for (var t5 = 0; e7 > 0; )
                t5 = t5 << 1 | F(), e7--;
              return t5;
            }
            function D(e7) {
              if (1 === e7)
                return 1 === F() ? 1 : -1;
              var t5 = O2(e7);
              return t5 >= 1 << e7 - 1 ? t5 : t5 + (-1 << e7) + 1;
            }
            function $(e7, t5, i6, r3, n4) {
              var a4 = i6 % A2;
              R2 = (i6 / A2 | 0) * e7.A + r3;
              var o4 = a4 * e7.h + n4;
              t5(e7, d(e7, R2, o4));
            }
            function L2(e7, t5, i6) {
              R2 = i6 / e7.P | 0;
              var r3 = i6 % e7.P;
              t5(e7, d(e7, R2, r3));
            }
            var U = o3.length;
            for (v2 = I ? 0 === l3 ? 0 === h3 ? function(e7, t5) {
              var i6 = N2(e7.J), r3 = 0 === i6 ? 0 : D(i6) << c3;
              e7.D[t5] = e7.Q += r3;
            } : function(e7, t5) {
              e7.D[t5] |= F() << c3;
            } : 0 === h3 ? function(t5, i6) {
              if (B2 > 0)
                B2--;
              else
                for (var r3 = l3, n4 = u3; r3 <= n4; ) {
                  var a4 = N2(t5.i), o4 = 15 & a4, s4 = a4 >> 4;
                  if (0 !== o4) {
                    var h4 = e6[r3 += s4];
                    t5.D[i6 + h4] = D(o4) * (1 << c3), r3++;
                  } else {
                    if (s4 < 15) {
                      B2 = O2(s4) + (1 << s4) - 1;
                      break;
                    }
                    r3 += 16;
                  }
                }
            } : function(i6, r3) {
              for (var n4, a4, o4 = l3, s4 = u3, h4 = 0; o4 <= s4; ) {
                var f4 = r3 + e6[o4], d2 = i6.D[f4] < 0 ? -1 : 1;
                switch (C2) {
                  case 0:
                    if (h4 = (a4 = N2(i6.i)) >> 4, 0 == (n4 = 15 & a4))
                      h4 < 15 ? (B2 = O2(h4) + (1 << h4), C2 = 4) : (h4 = 16, C2 = 1);
                    else {
                      if (1 !== n4)
                        throw new t4("invalid ACn encoding");
                      p3 = D(n4), C2 = h4 ? 2 : 3;
                    }
                    continue;
                  case 1:
                  case 2:
                    i6.D[f4] ? i6.D[f4] += d2 * (F() << c3) : 0 == --h4 && (C2 = 2 === C2 ? 3 : 0);
                    break;
                  case 3:
                    i6.D[f4] ? i6.D[f4] += d2 * (F() << c3) : (i6.D[f4] = p3 << c3, C2 = 0);
                    break;
                  case 4:
                    i6.D[f4] && (i6.D[f4] += d2 * (F() << c3));
                }
                o4++;
              }
              4 === C2 && 0 == --B2 && (C2 = 0);
            } : function(t5, i6) {
              var r3 = N2(t5.J), n4 = 0 === r3 ? 0 : D(r3), a4 = 1;
              for (t5.D[i6] = t5.Q += n4; a4 < 64; ) {
                var o4 = N2(t5.i), s4 = 15 & o4, l4 = o4 >> 4;
                if (0 !== s4) {
                  var u4 = e6[a4 += l4];
                  t5.D[i6 + u4] = D(s4), a4++;
                } else {
                  if (l4 < 15)
                    break;
                  a4 += 16;
                }
              }
            }, E2 = 1 === U ? o3[0].P * o3[0].c : A2 * a3.R; z2 <= E2; ) {
              var Z = s3 ? Math.min(E2 - z2, s3) : E2;
              if (Z > 0) {
                for (_3 = 0; _3 < U; _3++)
                  o3[_3].Q = 0;
                if (B2 = 0, 1 === U)
                  for (m2 = o3[0], w = 0; w < Z; w++)
                    L2(m2, v2, z2), z2++;
                else
                  for (w = 0; w < Z; w++) {
                    for (_3 = 0; _3 < U; _3++)
                      for (k2 = (m2 = o3[_3]).h, S2 = m2.A, b2 = 0; b2 < S2; b2++)
                        for (y2 = 0; y2 < k2; y2++)
                          $(m2, v2, z2, b2, y2);
                    z2++;
                  }
              }
              if (P = 0, !(x2 = g(i5, n3)))
                break;
              if (x2.u && (n3 = x2.offset), !(x2.M >= 65488 && x2.M <= 65495))
                break;
              n3 += 2;
            }
            return n3 - M2;
          }
          function m(e7, r3, c3) {
            var f3, d2, p3, m2, _3, g2, b2, y2, w, v2, x2, E2, k2, S2, A2, I, M2, T2 = e7.$, P = e7.D;
            if (!T2)
              throw new t4("missing required Quantization Table.");
            for (var B2 = 0; B2 < 64; B2 += 8)
              w = P[r3 + B2], v2 = P[r3 + B2 + 1], x2 = P[r3 + B2 + 2], E2 = P[r3 + B2 + 3], k2 = P[r3 + B2 + 4], S2 = P[r3 + B2 + 5], A2 = P[r3 + B2 + 6], I = P[r3 + B2 + 7], w *= T2[B2], v2 | x2 | E2 | k2 | S2 | A2 | I ? (v2 *= T2[B2 + 1], x2 *= T2[B2 + 2], E2 *= T2[B2 + 3], k2 *= T2[B2 + 4], S2 *= T2[B2 + 5], A2 *= T2[B2 + 6], I *= T2[B2 + 7], d2 = (f3 = (f3 = u2 * w + 128 >> 8) + (d2 = u2 * k2 + 128 >> 8) + 1 >> 1) - d2, M2 = (p3 = x2) * l2 + (m2 = A2) * s2 + 128 >> 8, p3 = p3 * s2 - m2 * l2 + 128 >> 8, b2 = (_3 = (_3 = h2 * (v2 - I) + 128 >> 8) + (b2 = S2 << 4) + 1 >> 1) - b2, g2 = (y2 = (y2 = h2 * (v2 + I) + 128 >> 8) + (g2 = E2 << 4) + 1 >> 1) - g2, m2 = (f3 = f3 + (m2 = M2) + 1 >> 1) - m2, p3 = (d2 = d2 + p3 + 1 >> 1) - p3, M2 = _3 * o2 + y2 * a2 + 2048 >> 12, _3 = _3 * a2 - y2 * o2 + 2048 >> 12, y2 = M2, M2 = g2 * n2 + b2 * i4 + 2048 >> 12, g2 = g2 * i4 - b2 * n2 + 2048 >> 12, b2 = M2, c3[B2] = f3 + y2, c3[B2 + 7] = f3 - y2, c3[B2 + 1] = d2 + b2, c3[B2 + 6] = d2 - b2, c3[B2 + 2] = p3 + g2, c3[B2 + 5] = p3 - g2, c3[B2 + 3] = m2 + _3, c3[B2 + 4] = m2 - _3) : (M2 = u2 * w + 512 >> 10, c3[B2] = M2, c3[B2 + 1] = M2, c3[B2 + 2] = M2, c3[B2 + 3] = M2, c3[B2 + 4] = M2, c3[B2 + 5] = M2, c3[B2 + 6] = M2, c3[B2 + 7] = M2);
            for (var C2 = 0; C2 < 8; ++C2)
              w = c3[C2], (v2 = c3[C2 + 8]) | (x2 = c3[C2 + 16]) | (E2 = c3[C2 + 24]) | (k2 = c3[C2 + 32]) | (S2 = c3[C2 + 40]) | (A2 = c3[C2 + 48]) | (I = c3[C2 + 56]) ? (d2 = (f3 = 4112 + ((f3 = u2 * w + 2048 >> 12) + (d2 = u2 * k2 + 2048 >> 12) + 1 >> 1)) - d2, M2 = (p3 = x2) * l2 + (m2 = A2) * s2 + 2048 >> 12, p3 = p3 * s2 - m2 * l2 + 2048 >> 12, m2 = M2, b2 = (_3 = (_3 = h2 * (v2 - I) + 2048 >> 12) + (b2 = S2) + 1 >> 1) - b2, g2 = (y2 = (y2 = h2 * (v2 + I) + 2048 >> 12) + (g2 = E2) + 1 >> 1) - g2, M2 = _3 * o2 + y2 * a2 + 2048 >> 12, _3 = _3 * a2 - y2 * o2 + 2048 >> 12, y2 = M2, M2 = g2 * n2 + b2 * i4 + 2048 >> 12, g2 = g2 * i4 - b2 * n2 + 2048 >> 12, (w = (f3 = f3 + m2 + 1 >> 1) + y2) < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4, (v2 = (d2 = d2 + p3 + 1 >> 1) + (b2 = M2)) < 16 ? v2 = 0 : v2 >= 4080 ? v2 = 255 : v2 >>= 4, (x2 = (p3 = d2 - p3) + g2) < 16 ? x2 = 0 : x2 >= 4080 ? x2 = 255 : x2 >>= 4, (E2 = (m2 = f3 - m2) + _3) < 16 ? E2 = 0 : E2 >= 4080 ? E2 = 255 : E2 >>= 4, (k2 = m2 - _3) < 16 ? k2 = 0 : k2 >= 4080 ? k2 = 255 : k2 >>= 4, (S2 = p3 - g2) < 16 ? S2 = 0 : S2 >= 4080 ? S2 = 255 : S2 >>= 4, (A2 = d2 - b2) < 16 ? A2 = 0 : A2 >= 4080 ? A2 = 255 : A2 >>= 4, (I = f3 - y2) < 16 ? I = 0 : I >= 4080 ? I = 255 : I >>= 4, P[r3 + C2] = w, P[r3 + C2 + 8] = v2, P[r3 + C2 + 16] = x2, P[r3 + C2 + 24] = E2, P[r3 + C2 + 32] = k2, P[r3 + C2 + 40] = S2, P[r3 + C2 + 48] = A2, P[r3 + C2 + 56] = I) : (M2 = (M2 = u2 * w + 8192 >> 14) < -2040 ? 0 : M2 >= 2024 ? 255 : M2 + 2056 >> 4, P[r3 + C2] = M2, P[r3 + C2 + 8] = M2, P[r3 + C2 + 16] = M2, P[r3 + C2 + 24] = M2, P[r3 + C2 + 32] = M2, P[r3 + C2 + 40] = M2, P[r3 + C2 + 48] = M2, P[r3 + C2 + 56] = M2);
          }
          function _2(e7, t5) {
            for (var i5 = t5.P, r3 = t5.c, n3 = new Int16Array(64), a3 = 0; a3 < r3; a3++)
              for (var o3 = 0; o3 < i5; o3++) {
                m(t5, d(t5, a3, o3), n3);
              }
            return t5.D;
          }
          function g(e7, t5, i5) {
            null == i5 && (i5 = t5);
            var n3 = e7.length - 1, a3 = i5 < t5 ? i5 : t5;
            if (t5 >= n3)
              return null;
            var o3 = r2(e7, t5);
            if (o3 >= 65472 && o3 <= 65534)
              return { u: null, M: o3, offset: t5 };
            for (var s3 = r2(e7, a3); !(s3 >= 65472 && s3 <= 65534); ) {
              if (++a3 >= n3)
                return null;
              s3 = r2(e7, a3);
            }
            return { u: o3.toString(16), M: s3, offset: a3 };
          }
          return c2.prototype = { parse(i5, n3) {
            null == n3 && (n3 = {});
            var a3, o3, s3 = n3.F, l3 = 0, u3 = null, h3 = null, c3 = 0;
            function d2() {
              var e7 = r2(i5, l3), t5 = (l3 += 2) + e7 - 2, n4 = g(i5, t5, l3);
              n4 && n4.u && (t5 = n4.offset);
              var a4 = i5.subarray(l3, t5);
              return l3 += a4.length, a4;
            }
            function m2(e7) {
              for (var t5 = Math.ceil(e7.o / 8 / e7.X), i6 = Math.ceil(e7.s / 8 / e7.B), r3 = 0; r3 < e7.W.length; r3++) {
                Z = e7.W[r3];
                var n4 = Math.ceil(Math.ceil(e7.o / 8) * Z.h / e7.X), a4 = Math.ceil(Math.ceil(e7.s / 8) * Z.A / e7.B), o4 = t5 * Z.h, s4 = 64 * (i6 * Z.A) * (o4 + 1);
                Z.D = new Int16Array(s4), Z.P = n4, Z.c = a4;
              }
              e7.m = t5, e7.R = i6;
            }
            var b2 = [], y2 = [], w = [], v2 = r2(i5, l3);
            if (l3 += 2, 65496 !== v2)
              throw new t4("SOI not found");
            v2 = r2(i5, l3), l3 += 2;
            e:
              for (; 65497 !== v2; ) {
                var x2, E2, k2;
                switch (v2) {
                  case 65504:
                  case 65505:
                  case 65506:
                  case 65507:
                  case 65508:
                  case 65509:
                  case 65510:
                  case 65511:
                  case 65512:
                  case 65513:
                  case 65514:
                  case 65515:
                  case 65516:
                  case 65517:
                  case 65518:
                  case 65519:
                  case 65534:
                    var S2 = d2();
                    65504 === v2 && 74 === S2[0] && 70 === S2[1] && 73 === S2[2] && 70 === S2[3] && 0 === S2[4] && (u3 = { version: { d: S2[5], T: S2[6] }, K: S2[7], j: S2[8] << 8 | S2[9], H: S2[10] << 8 | S2[11], S: S2[12], I: S2[13], C: S2.subarray(14, 14 + 3 * S2[12] * S2[13]) }), 65518 === v2 && 65 === S2[0] && 100 === S2[1] && 111 === S2[2] && 98 === S2[3] && 101 === S2[4] && (h3 = { version: S2[5] << 8 | S2[6], k: S2[7] << 8 | S2[8], q: S2[9] << 8 | S2[10], a: S2[11] });
                    break;
                  case 65499:
                    for (var A2 = r2(i5, l3) + (l3 += 2) - 2; l3 < A2; ) {
                      var I = i5[l3++], M2 = new Uint16Array(64);
                      if (I >> 4) {
                        if (I >> 4 != 1)
                          throw new t4("DQT - invalid table spec");
                        for (E2 = 0; E2 < 64; E2++)
                          M2[e6[E2]] = r2(i5, l3), l3 += 2;
                      } else
                        for (E2 = 0; E2 < 64; E2++)
                          M2[e6[E2]] = i5[l3++];
                      b2[15 & I] = M2;
                    }
                    break;
                  case 65472:
                  case 65473:
                  case 65474:
                    if (a3)
                      throw new t4("Only single frame JPEGs supported");
                    l3 += 2, (a3 = {}).G = 65473 === v2, a3.Z = 65474 === v2, a3.precision = i5[l3++];
                    var T2, P = r2(i5, l3), B2 = 0, C2 = 0;
                    l3 += 2, a3.s = s3 || P, a3.o = r2(i5, l3), l3 += 2, a3.W = [], a3._ = {};
                    var R2 = i5[l3++];
                    for (x2 = 0; x2 < R2; x2++) {
                      T2 = i5[l3];
                      var z2 = i5[l3 + 1] >> 4, F = 15 & i5[l3 + 1];
                      B2 < z2 && (B2 = z2), C2 < F && (C2 = F);
                      var N2 = i5[l3 + 2];
                      k2 = a3.W.push({ h: z2, A: F, L: N2, $: null }), a3._[T2] = k2 - 1, l3 += 3;
                    }
                    a3.X = B2, a3.B = C2, m2(a3);
                    break;
                  case 65476:
                    var O2 = r2(i5, l3);
                    for (l3 += 2, x2 = 2; x2 < O2; ) {
                      var D = i5[l3++], $ = new Uint8Array(16), L2 = 0;
                      for (E2 = 0; E2 < 16; E2++, l3++)
                        L2 += $[E2] = i5[l3];
                      var U = new Uint8Array(L2);
                      for (E2 = 0; E2 < L2; E2++, l3++)
                        U[E2] = i5[l3];
                      x2 += 17 + L2, (D >> 4 ? y2 : w)[15 & D] = f2($, U);
                    }
                    break;
                  case 65501:
                    o3 = r2(i5, l3 += 2), l3 += 2;
                    break;
                  case 65498:
                    var Z, j = 1 == ++c3 && !s3;
                    l3 += 2;
                    var G = i5[l3++], H = [];
                    for (x2 = 0; x2 < G; x2++) {
                      var Q = i5[l3++], W = a3._[Q];
                      (Z = a3.W[W]).index = Q;
                      var q = i5[l3++];
                      Z.J = w[q >> 4], Z.i = y2[15 & q], H.push(Z);
                    }
                    var V = i5[l3++], Y2 = i5[l3++], K = i5[l3++];
                    try {
                      var J = p2(i5, l3, a3, H, o3, V, Y2, K >> 4, 15 & K, j);
                      l3 += J;
                    } catch (e7) {
                      if (e7 instanceof DNLMarkerError)
                        return this.parse(i5, { F: e7.s });
                      if (e7 instanceof EOIMarkerError)
                        break e;
                      throw e7;
                    }
                    break;
                  case 65500:
                    l3 += 4;
                    break;
                  case 65535:
                    255 !== i5[l3] && l3--;
                    break;
                  default:
                    var X = g(i5, l3 - 2, l3 - 3);
                    if (X && X.u) {
                      l3 = X.offset;
                      break;
                    }
                    if (l3 >= i5.length - 1)
                      break e;
                    throw new t4("JpegImage.parse - unknown marker: " + v2.toString(16));
                }
                v2 = r2(i5, l3), l3 += 2;
              }
            for (this.width = a3.o, this.height = a3.s, this.g = u3, this.b = h3, this.W = [], x2 = 0; x2 < a3.W.length; x2++) {
              var ee = b2[(Z = a3.W[x2]).L];
              ee && (Z.$ = ee), this.W.push({ index: Z.index, e: _2(0, Z), l: Z.h / a3.X, t: Z.A / a3.B, P: Z.P, c: Z.c });
            }
            this.p = this.W.length;
          }, Y(e7, t5, i5) {
            null == i5 && (i5 = false);
            var r3, n3, a3, o3, s3, l3, u3, h3, c3, f3, d2, p3, m2 = this.width / e7, _3 = this.height / t5, g2 = 0, b2 = this.W.length, y2 = e7 * t5 * b2, w = new Uint8ClampedArray(y2), v2 = new Uint32Array(e7), x2 = 4294967288;
            for (u3 = 0; u3 < b2; u3++) {
              if (n3 = (r3 = this.W[u3]).l * m2, a3 = r3.t * _3, g2 = u3, d2 = r3.e, o3 = r3.P + 1 << 3, n3 !== p3) {
                for (s3 = 0; s3 < e7; s3++)
                  h3 = 0 | s3 * n3, v2[s3] = (h3 & x2) << 3 | 7 & h3;
                p3 = n3;
              }
              for (l3 = 0; l3 < t5; l3++)
                for (f3 = o3 * ((h3 = 0 | l3 * a3) & x2) | (7 & h3) << 3, s3 = 0; s3 < e7; s3++)
                  w[g2] = d2[f3 + v2[s3]], g2 += b2;
            }
            var E2 = this.V;
            if (i5 || 4 !== b2 || E2 || (E2 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), E2)
              for (u3 = 0; u3 < y2; )
                for (h3 = 0, c3 = 0; h3 < b2; h3++, u3++, c3 += 2)
                  w[u3] = (w[u3] * E2[c3] >> 8) + E2[c3 + 1];
            return w;
          }, get f() {
            return this.b ? !!this.b.a : 3 === this.p ? 0 !== this.N && (82 !== this.W[0].index || 71 !== this.W[1].index || 66 !== this.W[2].index) : 1 === this.N;
          }, z: function(e7) {
            for (var t5, i5, r3, n3 = 0, a3 = e7.length; n3 < a3; n3 += 3)
              t5 = e7[n3], i5 = e7[n3 + 1], r3 = e7[n3 + 2], e7[n3] = t5 - 179.456 + 1.402 * r3, e7[n3 + 1] = t5 + 135.459 - 0.344 * i5 - 0.714 * r3, e7[n3 + 2] = t5 - 226.816 + 1.772 * i5;
            return e7;
          }, O: function(e7) {
            for (var t5, i5, r3, n3, a3 = 0, o3 = 0, s3 = e7.length; o3 < s3; o3 += 4)
              t5 = e7[o3], i5 = e7[o3 + 1], r3 = e7[o3 + 2], n3 = e7[o3 + 3], e7[a3++] = i5 * (-660635669420364e-19 * i5 + 437130475926232e-18 * r3 - 54080610064599e-18 * t5 + 48449797120281e-17 * n3 - 0.154362151871126) - 122.67195406894 + r3 * (-957964378445773e-18 * r3 + 817076911346625e-18 * t5 - 0.00477271405408747 * n3 + 1.53380253221734) + t5 * (961250184130688e-18 * t5 - 0.00266257332283933 * n3 + 0.48357088451265) + n3 * (-336197177618394e-18 * n3 + 0.484791561490776), e7[a3++] = 107.268039397724 + i5 * (219927104525741e-19 * i5 - 640992018297945e-18 * r3 + 659397001245577e-18 * t5 + 426105652938837e-18 * n3 - 0.176491792462875) + r3 * (-778269941513683e-18 * r3 + 0.00130872261408275 * t5 + 770482631801132e-18 * n3 - 0.151051492775562) + t5 * (0.00126935368114843 * t5 - 0.00265090189010898 * n3 + 0.25802910206845) + n3 * (-318913117588328e-18 * n3 - 0.213742400323665), e7[a3++] = i5 * (-570115196973677e-18 * i5 - 263409051004589e-19 * r3 + 0.0020741088115012 * t5 - 0.00288260236853442 * n3 + 0.814272968359295) - 20.810012546947 + r3 * (-153496057440975e-19 * r3 - 132689043961446e-18 * t5 + 560833691242812e-18 * n3 - 0.195152027534049) + t5 * (0.00174418132927582 * t5 - 0.00255243321439347 * n3 + 0.116935020465145) + n3 * (-343531996510555e-18 * n3 + 0.24165260232407);
            return e7.subarray(0, a3);
          }, r: function(e7) {
            for (var t5, i5, r3, n3 = 0, a3 = e7.length; n3 < a3; n3 += 4)
              t5 = e7[n3], i5 = e7[n3 + 1], r3 = e7[n3 + 2], e7[n3] = 434.456 - t5 - 1.402 * r3, e7[n3 + 1] = 119.541 - t5 + 0.344 * i5 + 0.714 * r3, e7[n3 + 2] = 481.816 - t5 - 1.772 * i5;
            return e7;
          }, U: function(e7) {
            for (var t5, i5, r3, n3, a3 = 0, o3 = 0, s3 = e7.length; o3 < s3; o3 += 4)
              t5 = e7[o3], i5 = e7[o3 + 1], r3 = e7[o3 + 2], n3 = e7[o3 + 3], e7[a3++] = 255 + t5 * (-6747147073602441e-20 * t5 + 8379262121013727e-19 * i5 + 2894718188643294e-19 * r3 + 0.003264231057537806 * n3 - 1.1185611867203937) + i5 * (26374107616089405e-21 * i5 - 8626949158638572e-20 * r3 - 2748769067499491e-19 * n3 - 0.02155688794978967) + r3 * (-3878099212869363e-20 * r3 - 3267808279485286e-19 * n3 + 0.0686742238595345) - n3 * (3361971776183937e-19 * n3 + 0.7430659151342254), e7[a3++] = 255 + t5 * (13596372813588848e-20 * t5 + 924537132573585e-18 * i5 + 10567359618683593e-20 * r3 + 4791864687436512e-19 * n3 - 0.3109689587515875) + i5 * (-23545346108370344e-20 * i5 + 2702845253534714e-19 * r3 + 0.0020200308977307156 * n3 - 0.7488052167015494) + r3 * (6834815998235662e-20 * r3 + 15168452363460973e-20 * n3 - 0.09751927774728933) - n3 * (3189131175883281e-19 * n3 + 0.7364883807733168), e7[a3++] = 255 + t5 * (13598650411385307e-21 * t5 + 12423956175490851e-20 * i5 + 4751985097583589e-19 * r3 - 36729317476630422e-22 * n3 - 0.05562186980264034) + i5 * (16141380598724676e-20 * i5 + 9692239130725186e-19 * r3 + 7782692450036253e-19 * n3 - 0.44015232367526463) + r3 * (5068882914068769e-22 * r3 + 0.0017778369011375071 * n3 - 0.7591454649749609) - n3 * (3435319965105553e-19 * n3 + 0.7063770186160144);
            return e7.subarray(0, a3);
          }, getData: function(e7) {
            var i5 = e7.width, r3 = e7.height, n3 = e7.forceRGB, a3 = e7.isSourcePDF;
            if (this.p > 4)
              throw new t4("Unsupported color mode");
            var o3 = this.Y(i5, r3, a3);
            if (1 === this.p && n3) {
              for (var s3 = o3.length, l3 = new Uint8ClampedArray(3 * s3), u3 = 0, h3 = 0; h3 < s3; h3++) {
                var c3 = o3[h3];
                l3[u3++] = c3, l3[u3++] = c3, l3[u3++] = c3;
              }
              return l3;
            }
            if (3 === this.p && this.f)
              return this.z(o3);
            if (4 === this.p) {
              if (this.f)
                return n3 ? this.O(o3) : this.r(o3);
              if (n3)
                return this.U(o3);
            }
            return o3;
          } }, c2;
        }();
        function r2(e6, t5) {
          return e6[t5] << 8 | e6[t5 + 1];
        }
        e5.JpegDecoder = i3;
      }(), e5.encodeImage = function(t4, i3, r2, n2) {
        var a2 = { t256: [i3], t257: [r2], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1e3], t277: [4], t278: [r2], t279: [i3 * r2 * 4], t282: [[72, 1]], t283: [[72, 1]], t284: [1], t286: [[0, 1]], t287: [[0, 1]], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] };
        if (n2)
          for (var o2 in n2)
            a2[o2] = n2[o2];
        var s2 = new Uint8Array(e5.encode([a2])), l2 = new Uint8Array(t4), u2 = new Uint8Array(1e3 + i3 * r2 * 4);
        for (o2 = 0; o2 < s2.length; o2++)
          u2[o2] = s2[o2];
        for (o2 = 0; o2 < l2.length; o2++)
          u2[1e3 + o2] = l2[o2];
        return u2.buffer;
      }, e5.encode = function(t4) {
        var i3 = new Uint8Array(2e4), r2 = 4, n2 = e5._binBE;
        i3[0] = i3[1] = 77, n2.writeUshort(i3, 2, 42);
        var a2 = 8;
        n2.writeUint(i3, r2, a2), r2 += 4;
        for (var o2 = 0; o2 < t4.length; o2++) {
          var s2 = e5._writeIFD(n2, e5._types.basic, i3, a2, t4[o2]);
          a2 = s2[1], o2 < t4.length - 1 && (3 & a2 && (a2 += 4 - (3 & a2)), n2.writeUint(i3, s2[0], a2));
        }
        return i3.slice(0, a2).buffer;
      }, e5.decode = function(t4, r2) {
        null == r2 && (r2 = { parseMN: true, debug: false });
        var n2 = new Uint8Array(t4), a2 = 0, o2 = e5._binBE.readASCII(n2, a2, 2);
        a2 += 2;
        var s2 = "II" == o2 ? e5._binLE : e5._binBE;
        s2.readUshort(n2, a2), a2 += 2;
        var l2 = s2.readUint(n2, a2);
        a2 += 4;
        for (var u2 = []; ; ) {
          var h2 = s2.readUshort(n2, l2), c2 = s2.readUshort(n2, l2 + 4);
          if (0 != h2 && (c2 < 1 || 13 < c2)) {
            i2("error in TIFF");
            break;
          }
          if (e5._readIFD(s2, n2, l2, u2, 0, r2), 0 == (l2 = s2.readUint(n2, l2 + 2 + 12 * h2)))
            break;
        }
        return u2;
      }, e5.decodeImage = function(t4, r2, n2) {
        if (!r2.data) {
          var a2 = new Uint8Array(t4), o2 = e5._binBE.readASCII(a2, 0, 2);
          if (null != r2.t256) {
            r2.isLE = "II" == o2, r2.width = r2.t256[0], r2.height = r2.t257[0];
            var s2 = r2.t259 ? r2.t259[0] : 1, l2 = r2.t266 ? r2.t266[0] : 1;
            r2.t284 && 2 == r2.t284[0] && i2("PlanarConfiguration 2 should not be used!"), 7 == s2 && r2.t258 && r2.t258.length > 3 && (r2.t258 = r2.t258.slice(0, 3));
            var u2 = r2.t277 ? r2.t277[0] : 1, h2 = (r2.t258 ? r2.t258[0] : 1) * u2;
            1 == s2 && null != r2.t279 && r2.t278 && 32803 == r2.t262[0] && (h2 = Math.round(8 * r2.t279[0] / (r2.width * r2.t278[0]))), r2.t50885 && 4 == r2.t50885[0] && (h2 = 3 * r2.t258[0]);
            var c2 = 8 * Math.ceil(r2.width * h2 / 8), f2 = r2.t273;
            (null == f2 || r2.t322) && (f2 = r2.t324);
            var d = r2.t279;
            1 == s2 && 1 == f2.length && (d = [r2.height * (c2 >>> 3)]), (null == d || r2.t322) && (d = r2.t325);
            var p2 = new Uint8Array(r2.height * (c2 >>> 3)), m = 0;
            if (null != r2.t322) {
              var _2 = r2.t322[0], g = r2.t323[0], b2 = Math.floor((r2.width + _2 - 1) / _2), y2 = Math.floor((r2.height + g - 1) / g), w = new Uint8Array(0 | Math.ceil(_2 * g * h2 / 8));
              console.log("====", b2, y2);
              for (var v2 = 0; v2 < y2; v2++)
                for (var x2 = 0; x2 < b2; x2++) {
                  var E2 = v2 * b2 + x2;
                  w.fill(0), e5.decode._decompress(r2, n2, a2, f2[E2], d[E2], s2, w, 0, l2, _2, g), 6 == s2 ? p2 = w : e5._copyTile(w, 0 | Math.ceil(_2 * h2 / 8), g, p2, 0 | Math.ceil(r2.width * h2 / 8), r2.height, 0 | Math.ceil(x2 * _2 * h2 / 8), v2 * g);
                }
              m = 8 * p2.length;
            } else {
              if (null == f2)
                return;
              var k2 = r2.t278 ? r2.t278[0] : r2.height;
              k2 = Math.min(k2, r2.height);
              for (E2 = 0; E2 < f2.length; E2++)
                e5.decode._decompress(r2, n2, a2, f2[E2], d[E2], s2, p2, 0 | Math.ceil(m / 8), l2, r2.width, k2), m += c2 * k2;
              m = Math.min(m, 8 * p2.length);
            }
            r2.data = new Uint8Array(p2.buffer, 0, 0 | Math.ceil(m / 8));
          }
        }
      }, e5.decode._decompress = function(r2, n2, a2, o2, s2, l2, u2, h2, c2, f2, d) {
        if (r2.t271 && "Panasonic" == r2.t271[0] && r2.t45 && 6 == r2.t45[0] && (l2 = 34316), 1 == l2)
          for (var p2 = 0; p2 < s2; p2++)
            u2[h2 + p2] = a2[o2 + p2];
        else if (2 == l2)
          e5.decode._decodeG2(a2, o2, s2, u2, h2, f2, c2);
        else if (3 == l2)
          e5.decode._decodeG3(a2, o2, s2, u2, h2, f2, c2, !!r2.t292 && !(1 & ~r2.t292[0]));
        else if (4 == l2)
          e5.decode._decodeG4(a2, o2, s2, u2, h2, f2, c2);
        else if (5 == l2)
          e5.decode._decodeLZW(a2, o2, s2, u2, h2, 8);
        else if (6 == l2)
          e5.decode._decodeOldJPEG(r2, a2, o2, s2, u2, h2);
        else if (7 == l2 || 34892 == l2)
          e5.decode._decodeNewJPEG(r2, a2, o2, s2, u2, h2);
        else if (8 == l2 || 32946 == l2) {
          var m = new Uint8Array(a2.buffer, o2 + 2, s2 - 6), _2 = t3.inflateRaw(m);
          h2 + _2.length <= u2.length && u2.set(_2, h2);
        } else
          9 == l2 ? e5.decode._decodeVC5(a2, o2, s2, u2, h2, r2.t33422) : 32767 == l2 ? e5.decode._decodeARW(r2, a2, o2, s2, u2, h2) : 32773 == l2 ? e5.decode._decodePackBits(a2, o2, s2, u2, h2) : 32809 == l2 ? e5.decode._decodeThunder(a2, o2, s2, u2, h2) : 34316 == l2 ? e5.decode._decodePanasonic(r2, a2, o2, s2, u2, h2) : 34713 == l2 ? e5.decode._decodeNikon(r2, n2, a2, o2, s2, u2, h2) : 34676 == l2 ? e5.decode._decodeLogLuv32(r2, a2, o2, s2, u2, h2) : i2("Unknown compression", l2);
        var g = r2.t258 ? Math.min(32, r2.t258[0]) : 1, b2 = r2.t277 ? r2.t277[0] : 1, y2 = g * b2 >>> 3, w = Math.ceil(g * b2 * f2 / 8);
        if (16 == g && !r2.isLE && null == r2.t33422)
          for (var v2 = 0; v2 < d; v2++)
            for (var x2 = h2 + v2 * w, E2 = 1; E2 < w; E2 += 2) {
              var k2 = u2[x2 + E2];
              u2[x2 + E2] = u2[x2 + E2 - 1], u2[x2 + E2 - 1] = k2;
            }
        if (r2.t317 && 2 == r2.t317[0])
          for (v2 = 0; v2 < d; v2++) {
            var S2 = h2 + v2 * w;
            if (16 == g)
              for (p2 = y2; p2 < w; p2 += 2) {
                var A2 = (u2[S2 + p2 + 1] << 8 | u2[S2 + p2]) + (u2[S2 + p2 - y2 + 1] << 8 | u2[S2 + p2 - y2]);
                u2[S2 + p2] = 255 & A2, u2[S2 + p2 + 1] = A2 >>> 8 & 255;
              }
            else if (3 == b2)
              for (p2 = 3; p2 < w; p2 += 3)
                u2[S2 + p2] = u2[S2 + p2] + u2[S2 + p2 - 3] & 255, u2[S2 + p2 + 1] = u2[S2 + p2 + 1] + u2[S2 + p2 - 2] & 255, u2[S2 + p2 + 2] = u2[S2 + p2 + 2] + u2[S2 + p2 - 1] & 255;
            else
              for (p2 = y2; p2 < w; p2++)
                u2[S2 + p2] = u2[S2 + p2] + u2[S2 + p2 - y2] & 255;
          }
      }, e5.decode._decodePanasonic = function(e6, t4, i3, r2, n2, a2) {
        var o2, s2, l2, u2, h2, c2, f2, d, p2 = t4.buffer, m = e6.t2[0], _2 = e6.t3[0], g = e6.t10[0], b2 = e6.t45[0], y2 = 0, w = 0, v2 = 0, x2 = 0, E2 = 6 == b2 ? new Uint32Array(18) : new Uint8Array(16), k2 = [0, 0], S2 = [0, 0], A2 = 0, I = new Uint8Array(16384), M2 = new Uint16Array(n2.buffer);
        function T2(e7) {
          if (0 == v2) {
            var t5 = new Uint8Array(p2, i3 + w + 8184, 8200), r3 = new Uint8Array(p2, i3 + w, 8184);
            I.set(t5), I.set(r3, t5.length), w += 16384;
          }
          if (5 != b2)
            return (I[x2 = (v2 = v2 - e7 & 131071) >> 3 ^ 16368] | I[x2 + 1] << 8) >> (7 & v2) & ~(-1 << e7);
          for (o2 = 0; o2 < 16; o2++)
            E2[o2] = I[v2++], v2 &= 16383;
        }
        function P(e7) {
          return I[v2 + 15 - e7];
        }
        function B2() {
          k2[0] = 0, k2[1] = 0, S2[0] = 0, S2[1] = 0;
        }
        if (7 == b2)
          throw b2;
        if (6 == b2) {
          var C2 = 12 == g, R2 = C2 ? function() {
            E2[0] = P(0) << 4 | P(1) >> 4, E2[1] = 4095 & ((15 & P(1)) << 8 | P(2)), E2[2] = P(3) >> 6 & 3, E2[3] = (63 & P(3)) << 2 | P(4) >> 6, E2[4] = (63 & P(4)) << 2 | P(5) >> 6, E2[5] = (63 & P(5)) << 2 | P(6) >> 6, E2[6] = P(6) >> 4 & 3, E2[7] = (15 & P(6)) << 4 | P(7) >> 4, E2[8] = (15 & P(7)) << 4 | P(8) >> 4, E2[9] = (15 & P(8)) << 4 | P(9) >> 4, E2[10] = P(9) >> 2 & 3, E2[11] = (3 & P(9)) << 6 | P(10) >> 2, E2[12] = (3 & P(10)) << 6 | P(11) >> 2, E2[13] = (3 & P(11)) << 6 | P(12) >> 2, E2[14] = 3 & P(12), E2[15] = P(13), E2[16] = P(14), E2[17] = P(15), v2 += 16, x2 = 0;
          } : function() {
            E2[0] = P(0) << 6 | P(1) >> 2, E2[1] = 16383 & ((3 & P(1)) << 12 | P(2) << 4 | P(3) >> 4), E2[2] = P(3) >> 2 & 3, E2[3] = (3 & P(3)) << 8 | P(4), E2[4] = P(5) << 2 | P(6) >> 6, E2[5] = (63 & P(6)) << 4 | P(7) >> 4, E2[6] = P(7) >> 2 & 3, E2[7] = (3 & P(7)) << 8 | P(8), E2[8] = P(9) << 2 & 1020 | P(10) >> 6, E2[9] = 1023 & (P(10) << 4 | P(11) >> 4), E2[10] = P(11) >> 2 & 3, E2[11] = (3 & P(11)) << 8 | P(12), E2[12] = 1023 & (P(13) << 2 & 1020 | P(14) >> 6), E2[13] = 1023 & (P(14) << 4 | P(15) >> 4), v2 += 16, x2 = 0;
          }, z2 = C2 ? 14 : 11, F = C2 ? 128 : 512, N2 = C2 ? 2048 : 8192, O2 = C2 ? 16383 : 65535, D = C2 ? 4095 : 16383, $ = m / z2, L2 = 16 * $, U = C2 ? 18 : 14;
          for (c2 = 0; c2 < _2 - 15; c2 += 16) {
            var Z = Math.min(16, _2 - c2), j = L2 * Z;
            for (I = new Uint8Array(p2, i3 + y2, j), v2 = 0, y2 += j, d = 0, f2 = 0; d < Z; d++, f2 = 0) {
              A2 = (c2 + d) * m;
              for (var G = 0; G < $; G++)
                for (R2(), B2(), l2 = 0, h2 = 0, o2 = 0; o2 < z2; o2++) {
                  if (u2 = 1 & o2, o2 % 3 == 2) {
                    var H = x2 < U ? E2[x2++] : 0;
                    3 == H && (H = 4), h2 = F << H, l2 = 1 << H;
                  }
                  var Q = x2 < U ? E2[x2++] : 0;
                  k2[u2] ? (Q *= l2, h2 < N2 && S2[u2] > h2 && (Q += S2[u2] - h2), S2[u2] = Q) : (k2[u2] = Q, Q ? S2[u2] = Q : Q = S2[u2]), M2[A2 + f2++] = Q - 15 <= O2 ? Q - 15 & O2 : Q + 2147483633 >> 31 & D;
                }
            }
          }
        } else if (5 == b2) {
          var W = 12 == g ? 10 : 9;
          for (c2 = 0; c2 < _2; c2++)
            for (f2 = 0; f2 < m; f2 += W)
              T2(0), 12 == g ? (M2[A2++] = ((15 & E2[1]) << 8) + E2[0], M2[A2++] = 16 * E2[2] + (E2[1] >> 4), M2[A2++] = ((15 & E2[4]) << 8) + E2[3], M2[A2++] = 16 * E2[5] + (E2[4] >> 4), M2[A2++] = ((15 & E2[7]) << 8) + E2[6], M2[A2++] = 16 * E2[8] + (E2[7] >> 4), M2[A2++] = ((15 & E2[10]) << 8) + E2[9], M2[A2++] = 16 * E2[11] + (E2[10] >> 4), M2[A2++] = ((15 & E2[13]) << 8) + E2[12], M2[A2++] = 16 * E2[14] + (E2[13] >> 4)) : 14 == g && (M2[A2++] = E2[0] + ((63 & E2[1]) << 8), M2[A2++] = (E2[1] >> 6) + 4 * E2[2] + ((15 & E2[3]) << 10), M2[A2++] = (E2[3] >> 4) + 16 * E2[4] + ((3 & E2[5]) << 12), M2[A2++] = ((252 & E2[5]) >> 2) + (E2[6] << 6), M2[A2++] = E2[7] + ((63 & E2[8]) << 8), M2[A2++] = (E2[8] >> 6) + 4 * E2[9] + ((15 & E2[10]) << 10), M2[A2++] = (E2[10] >> 4) + 16 * E2[11] + ((3 & E2[12]) << 12), M2[A2++] = ((252 & E2[12]) >> 2) + (E2[13] << 6), M2[A2++] = E2[14] + ((63 & E2[15]) << 8));
        } else {
          if (4 != b2)
            throw b2;
          for (c2 = 0; c2 < _2; c2++)
            for (f2 = 0; f2 < m; f2++)
              u2 = 1 & (o2 = f2 % 14), 0 == o2 && B2(), o2 % 3 == 2 && (l2 = 4 >> 3 - T2(2)), S2[u2] ? 0 != (s2 = T2(8)) && (k2[u2] -= 128 << l2, (k2[u2] < 0 || 4 == l2) && (k2[u2] &= ~(-1 << l2)), k2[u2] += s2 << l2) : (S2[u2] = T2(8), (S2[u2] || o2 > 11) && (k2[u2] = S2[u2] << 4 | T2(4))), M2[A2++] = k2[1 & f2];
        }
      }, e5.decode._decodeVC5 = function() {
        var t4, i3, r2, n2 = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], a2 = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1];
        function o2(e6) {
          var t5 = e6[1], i4 = e6[0][t5 >>> 3] >>> 7 - (7 & t5) & 1;
          return e6[1]++, i4;
        }
        function s2(e6, i4) {
          if (null == t4) {
            t4 = {};
            for (var r3 = 0; r3 < n2.length; r3 += 4)
              t4[n2[r3 + 1]] = n2.slice(r3, r3 + 4);
          }
          for (var a3 = o2(e6), s3 = t4[a3]; null == s3; )
            a3 = a3 << 1 | o2(e6), s3 = t4[a3];
          var l3 = s3[3];
          0 != l3 && (l3 = 0 == o2(e6) ? l3 : -l3), i4[0] = s3[2], i4[1] = l3;
        }
        function l2(e6, t5) {
          for (var i4 = 0; i4 < t5; i4++)
            1 & ~e6 || e6++, e6 >>>= 1;
          return e6;
        }
        function u2(e6, t5) {
          return e6 >> t5;
        }
        function h2(e6, t5, i4, r3, n3, a3) {
          t5[i4] = u2(u2(11 * e6[n3] - 4 * e6[n3 + a3] + e6[n3 + a3 + a3] + 4, 3) + e6[r3], 1), t5[i4 + a3] = u2(u2(5 * e6[n3] + 4 * e6[n3 + a3] - e6[n3 + a3 + a3] + 4, 3) - e6[r3], 1);
        }
        function c2(e6, t5, i4, r3, n3, a3) {
          var o3 = e6[n3 - a3] - e6[n3 + a3], s3 = e6[n3], l3 = e6[r3];
          t5[i4] = u2(u2(o3 + 4, 3) + s3 + l3, 1), t5[i4 + a3] = u2(u2(4 - o3, 3) + s3 - l3, 1);
        }
        function f2(e6, t5, i4, r3, n3, a3) {
          t5[i4] = u2(u2(5 * e6[n3] + 4 * e6[n3 - a3] - e6[n3 - a3 - a3] + 4, 3) + e6[r3], 1), t5[i4 + a3] = u2(u2(11 * e6[n3] - 4 * e6[n3 - a3] + e6[n3 - a3 - a3] + 4, 3) - e6[r3], 1);
        }
        function d(e6) {
          return e6 = r2[e6 = e6 < 0 ? 0 : e6 > 4095 ? 4095 : e6] >>> 2;
        }
        return function(t5, n3, o3, u3, p2, m) {
          u3 = new Uint16Array(u3.buffer);
          var _2, g, b2, y2, w, v2, x2, E2, k2 = Date.now(), S2 = e5._binBE, A2 = n3 + o3;
          n3 += 4;
          for (var I = 1 == m[0]; n3 < A2; ) {
            var M2 = S2.readShort(t5, n3), T2 = S2.readUshort(t5, n3 + 2);
            if (n3 += 4, 12 == M2)
              N2 = T2;
            else if (20 == M2)
              _2 = T2;
            else if (21 == M2)
              g = T2;
            else if (48 == M2)
              b2 = T2;
            else if (53 == M2)
              y2 = T2;
            else if (35 == M2)
              ;
            else if (62 == M2)
              w = T2;
            else if (101 == M2)
              ;
            else if (109 == M2)
              v2 = T2;
            else if (84 == M2)
              ;
            else if (106 == M2)
              ;
            else if (107 == M2)
              ;
            else if (108 == M2)
              ;
            else if (102 == M2)
              ;
            else if (104 == M2)
              ie = T2;
            else if (105 == M2)
              ;
            else {
              var P = M2 < 0 ? -M2 : M2, B2 = 65280 & P, C2 = 0;
              if (24576 & P && (8192 & P ? (C2 = 65535 & T2, C2 += (255 & P) << 16) : C2 = 65535 & T2), 24576 & ~P) {
                if (16388 == P)
                  n3 += 4 * C2;
                else if (8192 != B2 && 8448 != B2 && 9216 != B2)
                  throw P.toString(16);
              } else {
                if (null == x2) {
                  x2 = [];
                  for (var R2 = 0; R2 < 4; R2++)
                    x2[R2] = new Int16Array((_2 >>> 1) * (g >>> 1));
                  E2 = new Int16Array((_2 >>> 1) * (g >>> 1)), i3 = new Int16Array(1024);
                  for (R2 = 0; R2 < 1024; R2++) {
                    var z2 = R2 - 512, F = Math.abs(z2), N2 = Math.floor(768 * F * F * F / 16581375) + F;
                    i3[R2] = Math.sign(z2) * N2;
                  }
                  r2 = new Uint16Array(4096);
                  for (R2 = 0; R2 < 4096; R2++) {
                    var O2 = R2, D = 65535 * (Math.pow(113, O2 / 4095) - 1) / 112;
                    r2[R2] = Math.min(D, 65535);
                  }
                }
                var $ = x2[w], L2 = l2(_2, 1 + a2[b2]), U = l2(g, 1 + a2[b2]);
                if (0 == b2)
                  for (var Z = 0; Z < U; Z++)
                    for (var j = 0; j < L2; j++) {
                      var G = n3 + 2 * (Z * L2 + j);
                      $[Z * (_2 >>> 1) + j] = t5[G] << 8 | t5[G + 1];
                    }
                else {
                  var H = [t5, 8 * n3], Q = [], W = 0, q = L2 * U, V = [0, 0], Y2 = 0;
                  for (T2 = 0; W < q; )
                    for (s2(H, V), Y2 = V[0], T2 = V[1]; Y2 > 0; )
                      Q[W++] = T2, Y2--;
                  var K = (b2 - 1) % 3, J = 1 != K ? L2 : 0, X = 0 != K ? U : 0;
                  for (Z = 0; Z < U; Z++) {
                    var ee = (Z + X) * (_2 >>> 1) + J, te = Z * L2;
                    for (j = 0; j < L2; j++)
                      $[ee + j] = i3[Q[te + j] + 512] * y2;
                  }
                  if (2 == K) {
                    var ie = _2 >>> 1, re = 2 * L2, ne = 2 * U;
                    for (Z = 0; Z < U; Z++)
                      for (j = 0; j < re; j++) {
                        R2 = 2 * Z * ie + j;
                        var ae = U * ie + (se = Z * ie + j);
                        0 == Z ? h2($, E2, R2, ae, se, ie) : Z == U - 1 ? f2($, E2, R2, ae, se, ie) : c2($, E2, R2, ae, se, ie);
                      }
                    var oe = $;
                    $ = E2, E2 = oe;
                    for (Z = 0; Z < ne; Z++)
                      for (j = 0; j < L2; j++) {
                        var se;
                        R2 = Z * ie + 2 * j, ae = L2 + (se = Z * ie + j);
                        0 == j ? h2($, E2, R2, ae, se, 1) : j == L2 - 1 ? f2($, E2, R2, ae, se, 1) : c2($, E2, R2, ae, se, 1);
                      }
                    oe = $;
                    $ = E2, E2 = oe;
                    for (var le = [], ue = 2 - ~~((b2 - 1) / 3), he = 0; he < 3; he++)
                      le[he] = v2 >> 14 - 2 * he & 3;
                    var ce = le[ue];
                    if (0 != ce)
                      for (Z = 0; Z < ne; Z++)
                        for (j = 0; j < re; j++) {
                          $[R2 = Z * ie + j] = $[R2] << ce;
                        }
                  }
                }
                if (9 == b2 && 3 == w) {
                  var fe = x2[0], de = x2[1], pe = x2[2], me = x2[3];
                  for (Z = 0; Z < g; Z += 2)
                    for (j = 0; j < _2; j += 2) {
                      var _e = Z * _2 + j, ge = fe[G = (Z >>> 1) * (_2 >>> 1) + (j >>> 1)], be = de[G] - 2048, ye = pe[G] - 2048, we = me[G] - 2048, ve = (be << 1) + ge, xe = (ye << 1) + ge, Ee = ge + we, ke = ge - we;
                      I ? (u3[_e] = d(Ee), u3[_e + 1] = d(xe), u3[_e + _2] = d(ve), u3[_e + _2 + 1] = d(ke)) : (u3[_e] = d(ve), u3[_e + 1] = d(Ee), u3[_e + _2] = d(ke), u3[_e + _2 + 1] = d(xe));
                    }
                }
                n3 += 4 * C2;
              }
            }
          }
          console.log(Date.now() - k2);
        };
      }(), e5.decode._decodeLogLuv32 = function(e6, t4, i3, r2, n2, a2) {
        for (var o2 = e6.width, s2 = 4 * o2, l2 = 0, u2 = new Uint8Array(s2); l2 < r2; ) {
          for (var h2 = 0; h2 < s2; ) {
            var c2 = t4[i3 + l2];
            if (l2++, c2 < 128) {
              for (var f2 = 0; f2 < c2; f2++)
                u2[h2 + f2] = t4[i3 + l2 + f2];
              h2 += c2, l2 += c2;
            } else {
              c2 -= 126;
              for (f2 = 0; f2 < c2; f2++)
                u2[h2 + f2] = t4[i3 + l2];
              h2 += c2, l2++;
            }
          }
          for (var d = 0; d < o2; d++)
            n2[a2 + 0] = u2[d], n2[a2 + 1] = u2[d + o2], n2[a2 + 2] = u2[d + 2 * o2], n2[a2 + 4] = u2[d + 3 * o2], a2 += 6;
        }
      }, e5.decode._ljpeg_diff = function(t4, i3, r2) {
        var n2, a2, o2 = e5.decode._getbithuff;
        return n2 = o2(t4, i3, r2[0], r2), (a2 = o2(t4, i3, n2, 0)) & 1 << n2 - 1 || (a2 -= (1 << n2) - 1), a2;
      }, e5.decode._decodeARW = function(t4, i3, r2, n2, a2, o2) {
        var s2 = t4.t256[0], l2 = t4.t257[0], u2 = t4.t258[0], h2 = t4.isLE ? e5._binLE : e5._binBE;
        if (s2 * l2 == n2 || s2 * l2 * 1.5 == n2)
          if (s2 * l2 * 1.5 != n2) {
            var c2, f2, d, p2, m, _2, g, b2, y2 = new Uint16Array(16), w = new Uint8Array(s2 + 1);
            for (M2 = 0; M2 < l2; M2++) {
              for (var v2 = 0; v2 < s2; v2++)
                w[v2] = i3[r2++];
              for (b2 = 0, I = 0; I < s2 - 30; b2 += 16) {
                for (f2 = 2047 & (c2 = h2.readUint(w, b2)), d = 2047 & c2 >>> 11, p2 = 15 & c2 >>> 22, m = 15 & c2 >>> 26, _2 = 0; _2 < 4 && 128 << _2 <= f2 - d; _2++)
                  ;
                for (g = 30, x2 = 0; x2 < 16; x2++)
                  x2 == p2 ? y2[x2] = f2 : x2 == m ? y2[x2] = d : (y2[x2] = ((h2.readUshort(w, b2 + (g >> 3)) >>> (7 & g) & 127) << _2) + d, y2[x2] > 2047 && (y2[x2] = 2047), g += 7);
                for (x2 = 0; x2 < 16; x2++, I += 2) {
                  N2 = y2[x2] << 1;
                  e5.decode._putsF(a2, (M2 * s2 + I) * u2, N2 << 16 - u2);
                }
                I -= 1 & I ? 1 : 31;
              }
            }
          } else
            for (var x2 = 0; x2 < n2; x2 += 3) {
              var E2 = i3[r2 + x2 + 0], k2 = i3[r2 + x2 + 1], S2 = i3[r2 + x2 + 2];
              a2[o2 + x2] = k2 << 4 | E2 >>> 4, a2[o2 + x2 + 1] = E2 << 4 | S2 >>> 4, a2[o2 + x2 + 2] = S2 << 4 | k2 >>> 4;
            }
        else {
          l2 += 8;
          var A2, I, M2, T2 = [r2, 0, 0, 0], P = new Uint16Array(32770), B2 = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], C2 = 0, R2 = e5.decode._ljpeg_diff;
          for (P[0] = 15, A2 = x2 = 0; x2 < 18; x2++)
            for (var z2 = 32768 >>> (B2[x2] >>> 8), F = 0; F < z2; F++)
              P[++A2] = B2[x2];
          for (I = s2; I--; )
            for (M2 = 0; M2 < l2 + 1; M2 += 2)
              if (M2 == l2 && (M2 = 1), C2 += R2(i3, T2, P), M2 < l2) {
                var N2 = 4095 & C2;
                e5.decode._putsF(a2, (M2 * s2 + I) * u2, N2 << 16 - u2);
              }
        }
      }, e5.decode._decodeNikon = function(t4, i3, r2, n2, a2, o2, s2) {
        var l2 = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], u2 = t4.t256[0], h2 = t4.t257[0], c2 = t4.t258[0], f2 = 0, d = 0, p2 = e5.decode._make_decoder, m = e5.decode._getbithuff, _2 = i3[0].exifIFD.makerNote, g = _2.t150 ? _2.t150 : _2.t140, b2 = 0, y2 = g[b2++], w = g[b2++];
        73 != y2 && 88 != w || (b2 += 2110), 70 == y2 && (f2 = 2), 14 == c2 && (f2 += 3);
        for (var v2 = [[0, 0], [0, 0]], x2 = t4.isLE ? e5._binLE : e5._binBE, E2 = 0; E2 < 2; E2++)
          for (var k2 = 0; k2 < 2; k2++)
            v2[E2][k2] = x2.readShort(g, b2), b2 += 2;
        var S2, A2, I, M2, T2, P = 1 << c2 & 32767, B2 = 0, C2 = x2.readShort(g, b2);
        b2 += 2, C2 > 1 && (B2 = Math.floor(P / (C2 - 1))), 68 == y2 && 32 == w && B2 > 0 && (d = x2.readShort(g, 562));
        var R2 = [0, 0], z2 = p2(l2[f2]), F = [n2, 0, 0, 0];
        for (S2 = 0; S2 < h2; S2++)
          for (d && S2 == d && (z2 = p2(l2[f2 + 1])), A2 = 0; A2 < u2; A2++) {
            E2 = m(r2, F, z2[0], z2), (T2 = 1 + (m(r2, F, (I = 15 & E2) - (M2 = E2 >>> 4), 0) << 1) << M2 >>> 1) & 1 << I - 1 || (T2 -= (1 << I) - (0 == M2 ? 1 : 0)), A2 < 2 ? R2[A2] = v2[1 & S2][A2] += T2 : R2[1 & A2] += T2;
            var N2 = Math.min(Math.max(R2[1 & A2], 0), (1 << c2) - 1), O2 = (S2 * u2 + A2) * c2;
            e5.decode._putsF(o2, O2, N2 << 16 - c2);
          }
      }, e5.decode._putsF = function(e6, t4, i3) {
        i3 <<= 8 - (7 & t4);
        var r2 = t4 >>> 3;
        e6[r2] |= i3 >>> 16, e6[r2 + 1] |= i3 >>> 8, e6[r2 + 2] |= i3;
      }, e5.decode._getbithuff = function(t4, i3, r2, n2) {
        var a2;
        e5.decode._get_byte;
        var o2 = i3[0], s2 = i3[1], l2 = i3[2], u2 = i3[3];
        if (0 == r2 || l2 < 0)
          return 0;
        for (; !u2 && l2 < r2 && -1 != (a2 = t4[o2++]) && !(u2 = 0); )
          s2 = (s2 << 8) + a2, l2 += 8;
        if (a2 = s2 << 32 - l2 >>> 32 - r2, n2 ? (l2 -= n2[a2 + 1] >>> 8, a2 = 255 & n2[a2 + 1]) : l2 -= r2, l2 < 0)
          throw "e";
        return i3[0] = o2, i3[1] = s2, i3[2] = l2, i3[3] = u2, a2;
      }, e5.decode._make_decoder = function(e6) {
        var t4, i3, r2, n2, a2, o2 = [];
        for (t4 = 16; 0 != t4 && !e6[t4]; t4--)
          ;
        var s2 = 17;
        for (o2[0] = t4, r2 = i3 = 1; i3 <= t4; i3++)
          for (n2 = 0; n2 < e6[i3]; n2++, ++s2)
            for (a2 = 0; a2 < 1 << t4 - i3; a2++)
              r2 <= 1 << t4 && (o2[r2++] = i3 << 8 | e6[s2]);
        return o2;
      }, e5.decode._decodeNewJPEG = function(t4, i3, r2, n2, a2, o2) {
        n2 = Math.min(n2, i3.length - r2);
        var s2 = t4.t347, l2 = s2 ? s2.length : 0, u2 = new Uint8Array(l2 + n2);
        if (s2) {
          for (var h2 = 0, c2 = 0; c2 < l2 - 1 && (255 != s2[c2] || 217 != s2[c2 + 1]); c2++)
            u2[h2++] = s2[c2];
          var f2 = i3[r2], d = i3[r2 + 1];
          255 == f2 && 216 == d || (u2[h2++] = f2, u2[h2++] = d);
          for (c2 = 2; c2 < n2; c2++)
            u2[h2++] = i3[r2 + c2];
        } else
          for (c2 = 0; c2 < n2; c2++)
            u2[c2] = i3[r2 + c2];
        if (32803 == t4.t262[0] || 7 == t4.t259[0] && 34892 == t4.t262[0]) {
          var p2 = t4.t258[0], m = e5.LosslessJpegDecode(u2), _2 = m.length;
          if (16 == p2)
            if (t4.isLE)
              for (c2 = 0; c2 < _2; c2++)
                a2[o2 + (c2 << 1)] = 255 & m[c2], a2[o2 + (c2 << 1) + 1] = m[c2] >>> 8;
            else
              for (c2 = 0; c2 < _2; c2++)
                a2[o2 + (c2 << 1)] = m[c2] >>> 8, a2[o2 + (c2 << 1) + 1] = 255 & m[c2];
          else if (14 == p2 || 12 == p2 || 10 == p2) {
            var g = 16 - p2;
            for (c2 = 0; c2 < _2; c2++)
              e5.decode._putsF(a2, c2 * p2, m[c2] << g);
          } else {
            if (8 != p2)
              throw new Error("unsupported bit depth " + p2);
            for (c2 = 0; c2 < _2; c2++)
              a2[o2 + c2] = m[c2];
          }
        } else {
          var b2 = new e5.JpegDecoder();
          b2.parse(u2);
          var y2 = b2.getData({ width: b2.width, height: b2.height, forceRGB: true, isSourcePDF: false });
          for (c2 = 0; c2 < y2.length; c2++)
            a2[o2 + c2] = y2[c2];
        }
        6 == t4.t262[0] && (t4.t262[0] = 2);
      }, e5.decode._decodeOldJPEGInit = function(e6, t4, r2, n2) {
        var a2, o2, s2, l2, u2, h2 = 216, c2 = 0, f2 = 0, d = false, p2 = e6.t513, m = p2 ? p2[0] : 0, _2 = e6.t514, g = _2 ? _2[0] : 0, b2 = e6.t324 || e6.t273 || p2, y2 = e6.t530, w = 0, v2 = 0, x2 = e6.t277 ? e6.t277[0] : 1, E2 = e6.t515;
        if (b2 && (f2 = b2[0], d = b2.length > 1), !d) {
          if (255 == t4[r2] && t4[r2 + 1] == h2)
            return { jpegOffset: r2 };
          if (null != p2 && (255 == t4[r2 + m] && t4[r2 + m + 1] == h2 ? c2 = r2 + m : i2("JPEGInterchangeFormat does not point to SOI"), null == _2 ? i2("JPEGInterchangeFormatLength field is missing") : (m >= f2 || m + g <= f2) && i2("JPEGInterchangeFormatLength field value is invalid"), null != c2))
            return { jpegOffset: c2 };
        }
        if (null != y2 && (w = y2[0], v2 = y2[1]), null != p2 && null != _2)
          if (g >= 2 && m + g <= f2) {
            for (a2 = 255 == t4[r2 + m + g - 2] && t4[r2 + m + g - 1] == h2 ? new Uint8Array(g - 2) : new Uint8Array(g), s2 = 0; s2 < a2.length; s2++)
              a2[s2] = t4[r2 + m + s2];
            i2("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
          } else
            i2("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
        if (null == a2) {
          var k2 = 0, S2 = [];
          S2[k2++] = 255, S2[k2++] = h2;
          var A2 = e6.t519;
          if (null == A2)
            throw new Error("JPEGQTables tag is missing");
          for (s2 = 0; s2 < A2.length; s2++)
            for (S2[k2++] = 255, S2[k2++] = 219, S2[k2++] = 0, S2[k2++] = 67, S2[k2++] = s2, l2 = 0; l2 < 64; l2++)
              S2[k2++] = t4[r2 + A2[s2] + l2];
          for (u2 = 0; u2 < 2; u2++) {
            var I = e6[0 == u2 ? "t520" : "t521"];
            if (null == I)
              throw new Error((0 == u2 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
            for (s2 = 0; s2 < I.length; s2++) {
              S2[k2++] = 255, S2[k2++] = 196;
              var M2 = 19;
              for (l2 = 0; l2 < 16; l2++)
                M2 += t4[r2 + I[s2] + l2];
              for (S2[k2++] = M2 >>> 8, S2[k2++] = 255 & M2, S2[k2++] = s2 | u2 << 4, l2 = 0; l2 < 16; l2++)
                S2[k2++] = t4[r2 + I[s2] + l2];
              for (l2 = 0; l2 < M2; l2++)
                S2[k2++] = t4[r2 + I[s2] + 16 + l2];
            }
          }
          if (S2[k2++] = 255, S2[k2++] = 192, S2[k2++] = 0, S2[k2++] = 8 + 3 * x2, S2[k2++] = 8, S2[k2++] = e6.height >>> 8 & 255, S2[k2++] = 255 & e6.height, S2[k2++] = e6.width >>> 8 & 255, S2[k2++] = 255 & e6.width, S2[k2++] = x2, 1 == x2)
            S2[k2++] = 1, S2[k2++] = 17, S2[k2++] = 0;
          else
            for (s2 = 0; s2 < 3; s2++)
              S2[k2++] = s2 + 1, S2[k2++] = 0 != s2 ? 17 : (15 & w) << 4 | 15 & v2, S2[k2++] = s2;
          null != E2 && 0 != E2[0] && (S2[k2++] = 255, S2[k2++] = 221, S2[k2++] = 0, S2[k2++] = 4, S2[k2++] = E2[0] >>> 8 & 255, S2[k2++] = 255 & E2[0]), a2 = new Uint8Array(S2);
        }
        var T2 = -1;
        for (s2 = 0; s2 < a2.length - 1; ) {
          if (255 == a2[s2] && 192 == a2[s2 + 1]) {
            T2 = s2;
            break;
          }
          s2++;
        }
        if (-1 == T2) {
          var P = new Uint8Array(a2.length + 10 + 3 * x2);
          P.set(a2);
          var B2 = a2.length;
          if (T2 = a2.length, (a2 = P)[B2++] = 255, a2[B2++] = 192, a2[B2++] = 0, a2[B2++] = 8 + 3 * x2, a2[B2++] = 8, a2[B2++] = e6.height >>> 8 & 255, a2[B2++] = 255 & e6.height, a2[B2++] = e6.width >>> 8 & 255, a2[B2++] = 255 & e6.width, a2[B2++] = x2, 1 == x2)
            a2[B2++] = 1, a2[B2++] = 17, a2[B2++] = 0;
          else
            for (s2 = 0; s2 < 3; s2++)
              a2[B2++] = s2 + 1, a2[B2++] = 0 != s2 ? 17 : (15 & w) << 4 | 15 & v2, a2[B2++] = s2;
        }
        if (255 == t4[f2] && 218 == t4[f2 + 1]) {
          var C2 = t4[f2 + 2] << 8 | t4[f2 + 3];
          for ((o2 = new Uint8Array(C2 + 2))[0] = t4[f2], o2[1] = t4[f2 + 1], o2[2] = t4[f2 + 2], o2[3] = t4[f2 + 3], s2 = 0; s2 < C2 - 2; s2++)
            o2[s2 + 4] = t4[f2 + s2 + 4];
        } else {
          var R2 = 0;
          if ((o2 = new Uint8Array(8 + 2 * x2))[R2++] = 255, o2[R2++] = 218, o2[R2++] = 0, o2[R2++] = 6 + 2 * x2, o2[R2++] = x2, 1 == x2)
            o2[R2++] = 1, o2[R2++] = 0;
          else
            for (s2 = 0; s2 < 3; s2++)
              o2[R2++] = s2 + 1, o2[R2++] = s2 << 4 | s2;
          o2[R2++] = 0, o2[R2++] = 63, o2[R2++] = 0;
        }
        return { jpegOffset: r2, tables: a2, sosMarker: o2, sofPosition: T2 };
      }, e5.decode._decodeOldJPEG = function(t4, i3, r2, n2, a2, o2) {
        var s2, l2, u2, h2, c2 = e5.decode._decodeOldJPEGInit(t4, i3, r2, n2);
        if (null != c2.jpegOffset)
          for (s2 = r2 + n2 - c2.jpegOffset, u2 = new Uint8Array(s2), p2 = 0; p2 < s2; p2++)
            u2[p2] = i3[c2.jpegOffset + p2];
        else {
          for (l2 = c2.tables.length, (u2 = new Uint8Array(l2 + c2.sosMarker.length + n2 + 2)).set(c2.tables), h2 = l2, u2[c2.sofPosition + 5] = t4.height >>> 8 & 255, u2[c2.sofPosition + 6] = 255 & t4.height, u2[c2.sofPosition + 7] = t4.width >>> 8 & 255, u2[c2.sofPosition + 8] = 255 & t4.width, 255 == i3[r2] && i3[r2 + 1] == SOS || (u2.set(c2.sosMarker, h2), h2 += sosMarker.length), p2 = 0; p2 < n2; p2++)
            u2[h2++] = i3[r2 + p2];
          u2[h2++] = 255, u2[h2++] = EOI;
        }
        var f2 = new e5.JpegDecoder();
        f2.parse(u2);
        for (var d = f2.getData({ width: f2.width, height: f2.height, forceRGB: true, isSourcePDF: false }), p2 = 0; p2 < d.length; p2++)
          a2[o2 + p2] = d[p2];
        t4.t262 && 6 == t4.t262[0] && (t4.t262[0] = 2);
      }, e5.decode._decodePackBits = function(e6, t4, i3, r2, n2) {
        for (var a2 = new Int8Array(e6.buffer), o2 = new Int8Array(r2.buffer), s2 = t4 + i3; t4 < s2; ) {
          var l2 = a2[t4];
          if (t4++, l2 >= 0 && l2 < 128)
            for (var u2 = 0; u2 < l2 + 1; u2++)
              o2[n2] = a2[t4], n2++, t4++;
          if (l2 >= -127 && l2 < 0) {
            for (u2 = 0; u2 < 1 - l2; u2++)
              o2[n2] = a2[t4], n2++;
            t4++;
          }
        }
        return n2;
      }, e5.decode._decodeThunder = function(e6, t4, i3, r2, n2) {
        for (var a2 = [0, 1, 0, -1], o2 = [0, 1, 2, 3, 0, -3, -2, -1], s2 = t4 + i3, l2 = 2 * n2, u2 = 0; t4 < s2; ) {
          var h2 = e6[t4], c2 = h2 >>> 6, f2 = 63 & h2;
          if (t4++, 3 == c2 && (u2 = 15 & f2, r2[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++), 0 == c2)
            for (var d = 0; d < f2; d++)
              r2[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++;
          if (2 == c2)
            for (d = 0; d < 2; d++) {
              4 != (p2 = f2 >>> 3 * (1 - d) & 7) && (u2 += o2[p2], r2[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++);
            }
          if (1 == c2)
            for (d = 0; d < 3; d++) {
              var p2;
              2 != (p2 = f2 >>> 2 * (2 - d) & 3) && (u2 += a2[p2], r2[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++);
            }
        }
      }, e5.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, e5.decode._lens = function() {
        var e6 = function(e7, t5, i4, r3) {
          for (var n3 = 0; n3 < t5.length; n3++)
            e7[t5[n3]] = i4 + n3 * r3;
        }, t4 = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", i3 = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", r2 = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", n2 = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", a2 = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
        t4 = t4.split(","), i3 = i3.split(","), r2 = r2.split(","), n2 = n2.split(","), a2 = a2.split(",");
        var o2 = {}, s2 = {};
        return e6(o2, t4, 0, 1), e6(o2, r2, 64, 64), e6(o2, a2, 1792, 64), e6(s2, i3, 0, 1), e6(s2, n2, 64, 64), e6(s2, a2, 1792, 64), [o2, s2];
      }(), e5.decode._decodeG4 = function(t4, i3, r2, n2, a2, o2, s2) {
        for (var l2 = e5.decode, u2 = i3 << 3, h2 = 0, c2 = "", f2 = [], d = [], p2 = 0; p2 < o2; p2++)
          d.push(0);
        d = l2._makeDiff(d);
        for (var m = 0, _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0, v2 = "", x2 = 0, E2 = 8 * Math.ceil(o2 / 8); u2 >>> 3 < i3 + r2; ) {
          g = l2._findDiff(d, m + (0 == m ? 0 : 1), 1 - y2), b2 = l2._findDiff(d, g, y2);
          var k2 = 0;
          if (1 == s2 && (k2 = t4[u2 >>> 3] >>> 7 - (7 & u2) & 1), 2 == s2 && (k2 = t4[u2 >>> 3] >>> (7 & u2) & 1), u2++, c2 += k2, "H" == v2) {
            if (null != l2._lens[y2][c2]) {
              var S2 = l2._lens[y2][c2];
              c2 = "", h2 += S2, S2 < 64 && (l2._addNtimes(f2, h2, y2), m += h2, y2 = 1 - y2, h2 = 0, 0 == --x2 && (v2 = ""));
            }
          } else
            "0001" == c2 && (c2 = "", l2._addNtimes(f2, b2 - m, y2), m = b2), "001" == c2 && (c2 = "", v2 = "H", x2 = 2), null != l2._dmap[c2] && (_2 = g + l2._dmap[c2], l2._addNtimes(f2, _2 - m, y2), m = _2, c2 = "", y2 = 1 - y2);
          f2.length == o2 && "" == v2 && (l2._writeBits(f2, n2, 8 * a2 + w * E2), y2 = 0, w++, m = 0, d = l2._makeDiff(f2), f2 = []);
        }
      }, e5.decode._findDiff = function(e6, t4, i3) {
        for (var r2 = 0; r2 < e6.length; r2 += 2)
          if (e6[r2] >= t4 && e6[r2 + 1] == i3)
            return e6[r2];
      }, e5.decode._makeDiff = function(e6) {
        var t4 = [];
        1 == e6[0] && t4.push(0, 1);
        for (var i3 = 1; i3 < e6.length; i3++)
          e6[i3 - 1] != e6[i3] && t4.push(i3, e6[i3]);
        return t4.push(e6.length, 0, e6.length, 1), t4;
      }, e5.decode._decodeG2 = function(t4, i3, r2, n2, a2, o2, s2) {
        for (var l2 = e5.decode, u2 = i3 << 3, h2 = 0, c2 = "", f2 = [], d = 0, p2 = 0, m = 8 * Math.ceil(o2 / 8); u2 >>> 3 < i3 + r2; ) {
          var _2 = 0;
          1 == s2 && (_2 = t4[u2 >>> 3] >>> 7 - (7 & u2) & 1), 2 == s2 && (_2 = t4[u2 >>> 3] >>> (7 & u2) & 1), u2++, c2 += _2, null != (h2 = l2._lens[d][c2]) && (l2._addNtimes(f2, h2, d), c2 = "", h2 < 64 && (d = 1 - d), f2.length == o2 && (l2._writeBits(f2, n2, 8 * a2 + p2 * m), f2 = [], p2++, d = 0, 7 & u2 && (u2 += 8 - (7 & u2)), h2 >= 64 && (u2 += 8)));
        }
      }, e5.decode._decodeG3 = function(t4, i3, r2, n2, a2, o2, s2, l2) {
        for (var u2 = e5.decode, h2 = i3 << 3, c2 = 0, f2 = "", d = [], p2 = [], m = 0; m < o2; m++)
          d.push(0);
        for (var _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0, v2 = -1, x2 = "", E2 = 0, k2 = true, S2 = 8 * Math.ceil(o2 / 8); h2 >>> 3 < i3 + r2; ) {
          b2 = u2._findDiff(p2, _2 + (0 == _2 ? 0 : 1), 1 - w), y2 = u2._findDiff(p2, b2, w);
          var A2 = 0;
          if (1 == s2 && (A2 = t4[h2 >>> 3] >>> 7 - (7 & h2) & 1), 2 == s2 && (A2 = t4[h2 >>> 3] >>> (7 & h2) & 1), h2++, f2 += A2, k2) {
            if (null != u2._lens[w][f2]) {
              var I = u2._lens[w][f2];
              f2 = "", c2 += I, I < 64 && (u2._addNtimes(d, c2, w), w = 1 - w, c2 = 0);
            }
          } else if ("H" == x2) {
            if (null != u2._lens[w][f2]) {
              I = u2._lens[w][f2];
              f2 = "", c2 += I, I < 64 && (u2._addNtimes(d, c2, w), _2 += c2, w = 1 - w, c2 = 0, 0 == --E2 && (x2 = ""));
            }
          } else
            "0001" == f2 && (f2 = "", u2._addNtimes(d, y2 - _2, w), _2 = y2), "001" == f2 && (f2 = "", x2 = "H", E2 = 2), null != u2._dmap[f2] && (g = b2 + u2._dmap[f2], u2._addNtimes(d, g - _2, w), _2 = g, f2 = "", w = 1 - w);
          f2.endsWith("000000000001") && (v2 >= 0 && u2._writeBits(d, n2, 8 * a2 + v2 * S2), l2 && (1 == s2 && (k2 = 1 == (t4[h2 >>> 3] >>> 7 - (7 & h2) & 1)), 2 == s2 && (k2 = 1 == (t4[h2 >>> 3] >>> (7 & h2) & 1)), h2++), f2 = "", w = 0, v2++, _2 = 0, p2 = u2._makeDiff(d), d = []);
        }
        d.length == o2 && u2._writeBits(d, n2, 8 * a2 + v2 * S2);
      }, e5.decode._addNtimes = function(e6, t4, i3) {
        for (var r2 = 0; r2 < t4; r2++)
          e6.push(i3);
      }, e5.decode._writeBits = function(e6, t4, i3) {
        for (var r2 = 0; r2 < e6.length; r2++)
          t4[i3 + r2 >>> 3] |= e6[r2] << 7 - (i3 + r2 & 7);
      }, e5.decode._decodeLZW = e5.decode._decodeLZW = function() {
        var e6, t4, i3, r2, n2 = 0, a2 = 0, o2 = 0, s2 = 0, l2 = function() {
          var i4 = e6 >>> 3, r3 = (t4[i4] << 16 | t4[i4 + 1] << 8 | t4[i4 + 2]) >>> 24 - (7 & e6) - a2 & (1 << a2) - 1;
          return e6 += a2, r3;
        }, u2 = new Uint32Array(16384), h2 = 0, c2 = function(e7) {
          a2 = e7 + 1, n2 = s2 + 1;
        }, f2 = function(e7) {
          for (var t5 = e7 << 2, n3 = u2[t5 + 2], a3 = r2 + n3 - 1; 65535 != t5; )
            i3[a3--] = u2[t5], t5 = u2[t5 + 1];
          r2 += n3;
        }, d = function(e7, t5) {
          var i4 = n2 << 2, r3 = e7 << 2;
          u2[i4] = u2[3 + (t5 << 2)], u2[i4 + 1] = r3, u2[i4 + 2] = u2[r3 + 2] + 1, u2[i4 + 3] = u2[r3 + 3], ++n2 + 1 == 1 << a2 && 12 != a2 && a2++;
        };
        return function(a3, p2, m, _2, g, b2) {
          e6 = p2 << 3, t4 = a3, i3 = _2, r2 = g;
          var y2 = p2 + m << 3, w = 0, v2 = 0;
          for (!function(e7) {
            if (e7 != h2) {
              h2 = e7, s2 = 1 + (o2 = 1 << e7);
              for (var t5 = 0; t5 < s2 + 1; t5++)
                u2[4 * t5] = u2[4 * t5 + 3] = t5, u2[4 * t5 + 1] = 65535, u2[4 * t5 + 2] = 1;
            }
          }(b2), c2(b2); e6 < y2 && (w = l2()) != s2; ) {
            if (w == o2) {
              if (c2(b2), (w = l2()) == s2)
                break;
              f2(w);
            } else
              w < n2 ? (f2(w), d(v2, w)) : (d(v2, v2), f2(n2 - 1));
            v2 = w;
          }
          return r2;
        };
      }(), e5.tags = {}, e5._types = function() {
        var e6 = new Array(250);
        e6.fill(0);
        return { basic: { main: e6 = e6.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), rest: { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 } }, gps: { main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9], rest: { 18: 2, 29: 2 } } };
      }(), e5._readIFD = function(t4, r2, n2, a2, o2, s2) {
        var l2 = t4.readUshort(r2, n2);
        n2 += 2;
        var u2 = {};
        s2.debug && i2("   ".repeat(o2), a2.length - 1, ">>>----------------");
        for (var h2 = 0; h2 < l2; h2++) {
          var c2 = t4.readUshort(r2, n2);
          n2 += 2;
          var f2 = t4.readUshort(r2, n2);
          n2 += 2;
          var d = t4.readUint(r2, n2);
          n2 += 4;
          var p2 = t4.readUint(r2, n2);
          n2 += 4;
          var m = [];
          if (1 == f2 || 7 == f2) {
            var _2 = d < 5 ? n2 - 4 : p2;
            _2 + d > r2.buffer.byteLength && (d = r2.buffer.byteLength - _2), m = new Uint8Array(r2.buffer, _2, d);
          }
          if (2 == f2) {
            var g = d < 5 ? n2 - 4 : p2, b2 = r2[g], y2 = Math.max(0, Math.min(d - 1, r2.length - g));
            b2 < 128 || 0 == y2 ? m.push(t4.readASCII(r2, g, y2)) : m = new Uint8Array(r2.buffer, g, y2);
          }
          if (3 == f2)
            for (var w = 0; w < d; w++)
              m.push(t4.readUshort(r2, (d < 3 ? n2 - 4 : p2) + 2 * w));
          if (4 == f2 || 13 == f2)
            for (w = 0; w < d; w++)
              m.push(t4.readUint(r2, (d < 2 ? n2 - 4 : p2) + 4 * w));
          if (5 == f2 || 10 == f2) {
            var v2 = 5 == f2 ? t4.readUint : t4.readInt;
            for (w = 0; w < d; w++)
              m.push([v2(r2, p2 + 8 * w), v2(r2, p2 + 8 * w + 4)]);
          }
          if (8 == f2)
            for (w = 0; w < d; w++)
              m.push(t4.readShort(r2, (d < 3 ? n2 - 4 : p2) + 2 * w));
          if (9 == f2)
            for (w = 0; w < d; w++)
              m.push(t4.readInt(r2, (d < 2 ? n2 - 4 : p2) + 4 * w));
          if (11 == f2)
            for (w = 0; w < d; w++)
              m.push(t4.readFloat(r2, p2 + 4 * w));
          if (12 == f2)
            for (w = 0; w < d; w++)
              m.push(t4.readDouble(r2, p2 + 8 * w));
          if (0 == d || 0 != m.length) {
            if (s2.debug && i2("   ".repeat(o2), c2, f2, e5.tags[c2], m), u2["t" + c2] = m, 330 == c2 && u2.t272 && "DSLR-A100" == u2.t272[0])
              ;
            else if (330 == c2 || 34665 == c2 || 34853 == c2 || 50740 == c2 && t4.readUshort(r2, t4.readUint(m, 0)) < 300 || 61440 == c2) {
              var x2 = 50740 == c2 ? [t4.readUint(m, 0)] : m, E2 = [];
              for (w = 0; w < x2.length; w++)
                e5._readIFD(t4, r2, x2[w], E2, o2 + 1, s2);
              330 == c2 && (u2.subIFD = E2), 34665 == c2 && (u2.exifIFD = E2[0]), 34853 == c2 && (u2.gpsiIFD = E2[0]), 50740 == c2 && (u2.dngPrvt = E2[0]), 61440 == c2 && (u2.fujiIFD = E2[0]);
            }
            if (37500 == c2 && s2.parseMN) {
              var k2 = m;
              if ("Nikon" == t4.readASCII(k2, 0, 5))
                u2.makerNote = e5.decode(k2.slice(10).buffer)[0];
              else if ("OLYMP" == t4.readASCII(k2, 0, 5) || "OM SYSTEM" == t4.readASCII(k2, 0, 9)) {
                var S2 = [8208, 8224, 8240, 8256, 8272], A2 = [];
                e5._readIFD(t4, k2, 77 == k2[1] ? 16 : 85 == k2[5] ? 12 : 8, A2, o2 + 1, s2);
                var I = u2.makerNote = A2.pop();
                for (w = 0; w < S2.length; w++) {
                  var M2 = "t" + S2[w];
                  null != I[M2] && (e5._readIFD(t4, k2, I[M2][0], A2, o2 + 1, s2), I[M2] = A2.pop());
                }
                I.t12288 && (e5._readIFD(t4, I.t12288, 0, A2, o2 + 1, s2), I.t12288 = A2.pop());
              } else if (t4.readUshort(r2, p2) < 300 && t4.readUshort(r2, p2 + 4) <= 12) {
                A2 = [];
                e5._readIFD(t4, r2, p2, A2, o2 + 1, s2), u2.makerNote = A2[0];
              }
            }
          } else if (i2(c2, "unknown TIFF tag type: ", f2, "num:", d), 0 == h2)
            return;
        }
        return a2.push(u2), s2.debug && i2("   ".repeat(o2), "<<<---------------"), n2;
      }, e5._writeIFD = function(t4, i3, r2, n2, a2) {
        var o2 = Object.keys(a2), s2 = o2.length;
        a2.exifIFD && s2--, a2.gpsiIFD && s2--, t4.writeUshort(r2, n2, s2);
        for (var l2 = (n2 += 2) + 12 * s2 + 4, u2 = 0; u2 < o2.length; u2++) {
          var h2 = o2[u2];
          if ("t34665" != h2 && "t34853" != h2) {
            "exifIFD" == h2 && (h2 = "t34665"), "gpsiIFD" == h2 && (h2 = "t34853");
            var c2 = parseInt(h2.slice(1)), f2 = i3.main[c2];
            if (null == f2 && (f2 = i3.rest[c2]), null == f2 || 0 == f2)
              throw new Error("unknown type of tag: " + c2);
            var d = a2[h2];
            if (34665 == c2)
              d = [l2], l2 = e5._writeIFD(t4, i3, r2, l2, a2.exifIFD)[1];
            if (34853 == c2)
              d = [l2], l2 = e5._writeIFD(t4, e5._types.gps, r2, l2, a2.gpsiIFD)[1];
            2 == f2 && (d = d[0] + "\0");
            var p2 = d.length;
            t4.writeUshort(r2, n2, c2), n2 += 2, t4.writeUshort(r2, n2, f2), n2 += 2, t4.writeUint(r2, n2, p2);
            var m = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][f2] * p2, _2 = n2 += 4;
            if (m > 4 && (t4.writeUint(r2, n2, l2), _2 = l2), 1 == f2 || 7 == f2)
              for (var g = 0; g < p2; g++)
                r2[_2 + g] = d[g];
            else if (2 == f2)
              t4.writeASCII(r2, _2, d);
            else if (3 == f2)
              for (g = 0; g < p2; g++)
                t4.writeUshort(r2, _2 + 2 * g, d[g]);
            else if (4 == f2)
              for (g = 0; g < p2; g++)
                t4.writeUint(r2, _2 + 4 * g, d[g]);
            else if (5 == f2 || 10 == f2) {
              var b2 = 5 == f2 ? t4.writeUint : t4.writeInt;
              for (g = 0; g < p2; g++) {
                var y2 = d[g], w = y2[0], v2 = y2[1];
                if (null == w)
                  throw "e";
                b2(r2, _2 + 8 * g, w), b2(r2, _2 + 8 * g + 4, v2);
              }
            } else if (9 == f2)
              for (g = 0; g < p2; g++)
                t4.writeInt(r2, _2 + 4 * g, d[g]);
            else {
              if (12 != f2)
                throw f2;
              for (g = 0; g < p2; g++)
                t4.writeDouble(r2, _2 + 8 * g, d[g]);
            }
            m > 4 && (l2 += m += 1 & m), n2 += 4;
          }
        }
        return [n2, l2];
      }, e5.toRGBA8 = function(e6, t4) {
        function r2(e7) {
          return e7 < 31308e-7 ? 12.92 * e7 : 1.055 * Math.pow(e7, 1 / 2.4) - 0.055;
        }
        var n2 = e6.width, a2 = e6.height, o2 = n2 * a2, s2 = e6.data, l2 = new Uint8Array(4 * o2), u2 = e6.t262 ? e6.t262[0] : 2, h2 = e6.t258 ? Math.min(32, e6.t258[0]) : 1;
        null == e6.t262 && 1 == h2 && (u2 = 0);
        var c2 = e6.t277 ? e6.t277[0] : e6.t258 ? e6.t258.length : [1, 1, 3, 1, 1, 4, 3][u2], f2 = e6.t339 ? e6.t339[0] : null;
        if (1 == u2 && 32 == h2 && 3 != f2)
          throw "e";
        var d = Math.ceil(c2 * h2 * n2 / 8);
        if (0 == u2) {
          t4 = 1 / 256;
          for (var p2 = 0; p2 < a2; p2++) {
            var m = p2 * d, _2 = p2 * n2;
            if (1 == h2)
              for (var g = 0; g < n2; g++) {
                var b2 = _2 + g << 2, y2 = s2[m + (g >> 3)] >> 7 - (7 & g) & 1;
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 255 * (1 - y2), l2[b2 + 3] = 255;
              }
            if (4 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[m + (g >> 1)] >> 4 - 4 * (1 & g) & 15;
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 17 * (15 - y2), l2[b2 + 3] = 255;
              }
            if (8 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[m + g];
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 255 - y2, l2[b2 + 3] = 255;
              }
            if (16 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[(v2 = m + 2 * g) + 1] << 8 | s2[v2];
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = Math.min(255, 255 - ~~(y2 * t4)), l2[b2 + 3] = 255;
              }
          }
        } else if (1 == u2) {
          null == t4 && (t4 = 1 / 256);
          var w = 3 & s2.length ? null : new Float32Array(s2.buffer);
          for (p2 = 0; p2 < a2; p2++) {
            m = p2 * d, _2 = p2 * n2;
            if (1 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[m + (g >> 3)] >> 7 - (7 & g) & 1;
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 255 * y2, l2[b2 + 3] = 255;
              }
            if (2 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[m + (g >> 2)] >> 6 - 2 * (3 & g) & 3;
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 85 * y2, l2[b2 + 3] = 255;
              }
            if (8 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[m + g * c2];
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = y2, l2[b2 + 3] = 255;
              }
            if (16 == h2)
              for (g = 0; g < n2; g++) {
                b2 = _2 + g << 2, y2 = s2[(v2 = m + 2 * g) + 1] << 8 | s2[v2];
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = Math.min(255, ~~(y2 * t4)), l2[b2 + 3] = 255;
              }
            if (32 == h2)
              for (g = 0; g < n2; g++) {
                var v2;
                b2 = _2 + g << 2, y2 = w[v2 = (m >>> 2) + g];
                l2[b2] = l2[b2 + 1] = l2[b2 + 2] = ~~(0.5 + 255 * y2), l2[b2 + 3] = 255;
              }
          }
        } else if (2 == u2)
          if (8 == h2) {
            if (1 == c2)
              for (g = 0; g < o2; g++)
                l2[4 * g] = l2[4 * g + 1] = l2[4 * g + 2] = s2[g], l2[4 * g + 3] = 255;
            if (3 == c2)
              for (g = 0; g < o2; g++) {
                var x2 = 3 * g;
                l2[b2 = g << 2] = s2[x2], l2[b2 + 1] = s2[x2 + 1], l2[b2 + 2] = s2[x2 + 2], l2[b2 + 3] = 255;
              }
            if (c2 >= 4)
              for (g = 0; g < o2; g++) {
                x2 = g * c2;
                l2[b2 = g << 2] = s2[x2], l2[b2 + 1] = s2[x2 + 1], l2[b2 + 2] = s2[x2 + 2], l2[b2 + 3] = s2[x2 + 3];
              }
          } else if (16 == h2) {
            if (4 == c2)
              for (g = 0; g < o2; g++) {
                x2 = 8 * g + 1;
                l2[b2 = g << 2] = s2[x2], l2[b2 + 1] = s2[x2 + 2], l2[b2 + 2] = s2[x2 + 4], l2[b2 + 3] = s2[x2 + 6];
              }
            if (3 == c2)
              for (g = 0; g < o2; g++) {
                x2 = 6 * g + 1;
                l2[b2 = g << 2] = s2[x2], l2[b2 + 1] = s2[x2 + 2], l2[b2 + 2] = s2[x2 + 4], l2[b2 + 3] = 255;
              }
          } else {
            if (32 != h2)
              throw h2;
            var E2 = new Float32Array(s2.buffer), k2 = 0;
            for (g = 0; g < E2.length; g++)
              k2 = Math.min(k2, E2[g]);
            if (k2 < 0)
              for (g = 0; g < s2.length; g += 4) {
                var S2 = s2[g];
                s2[g] = s2[g + 3], s2[g + 3] = S2, S2 = s2[g + 1], s2[g + 1] = s2[g + 2], s2[g + 2] = S2;
              }
            var A2 = [];
            for (g = 0; g < 65536; g++)
              A2.push(r2(g / 65535));
            for (g = 0; g < E2.length; g++) {
              var I = Math.max(0, Math.min(1, E2[g]));
              E2[g] = A2[~~(0.5 + 65535 * I)];
            }
            if (3 == c2)
              for (g = 0; g < o2; g++) {
                x2 = 3 * g;
                l2[b2 = g << 2] = ~~(0.5 + 255 * E2[x2]), l2[b2 + 1] = ~~(0.5 + 255 * E2[x2 + 1]), l2[b2 + 2] = ~~(0.5 + 255 * E2[x2 + 2]), l2[b2 + 3] = 255;
              }
            else {
              if (4 != c2)
                throw c2;
              for (g = 0; g < o2; g++) {
                x2 = 4 * g;
                l2[b2 = g << 2] = ~~(0.5 + 255 * E2[x2]), l2[b2 + 1] = ~~(0.5 + 255 * E2[x2 + 1]), l2[b2 + 2] = ~~(0.5 + 255 * E2[x2 + 2]), l2[b2 + 3] = ~~(0.5 + 255 * E2[x2 + 3]);
              }
            }
          }
        else if (3 == u2) {
          var M2 = e6.t320, T2 = 1 << h2, P = 8 == h2 && c2 > 1 && e6.t338 && 0 != e6.t338[0];
          for (p2 = 0; p2 < a2; p2++)
            for (var B2 = 0; B2 < n2; B2++) {
              b2 = (g = p2 * n2 + B2) << 2;
              var C2 = 0, R2 = p2 * d;
              if (1 == h2)
                C2 = s2[R2 + (B2 >>> 3)] >>> 7 - (7 & B2) & 1;
              else if (2 == h2)
                C2 = s2[R2 + (B2 >>> 2)] >>> 6 - 2 * (3 & B2) & 3;
              else if (4 == h2)
                C2 = s2[R2 + (B2 >>> 1)] >>> 4 - 4 * (1 & B2) & 15;
              else {
                if (8 != h2)
                  throw h2;
                C2 = s2[R2 + B2 * c2];
              }
              l2[b2] = M2[C2] >> 8, l2[b2 + 1] = M2[T2 + C2] >> 8, l2[b2 + 2] = M2[T2 + T2 + C2] >> 8, l2[b2 + 3] = P ? s2[R2 + B2 * c2 + 1] : 255;
            }
        } else if (5 == u2) {
          var z2 = c2 > 4 ? 1 : 0;
          for (g = 0; g < o2; g++) {
            b2 = g << 2;
            var F = g * c2;
            if (window.UDOC) {
              var N2 = s2[F], O2 = s2[F + 1], D = s2[F + 2], $ = s2[F + 3], L2 = UDOC.C.cmykToRgb([N2 * (1 / 255), O2 * (1 / 255), D * (1 / 255), $ * (1 / 255)]);
              l2[b2] = ~~(0.5 + 255 * L2[0]), l2[b2 + 1] = ~~(0.5 + 255 * L2[1]), l2[b2 + 2] = ~~(0.5 + 255 * L2[2]);
            } else {
              N2 = 255 - s2[F], O2 = 255 - s2[F + 1], D = 255 - s2[F + 2], $ = (255 - s2[F + 3]) * (1 / 255);
              l2[b2] = ~~(N2 * $ + 0.5), l2[b2 + 1] = ~~(O2 * $ + 0.5), l2[b2 + 2] = ~~(D * $ + 0.5);
            }
            l2[b2 + 3] = 255 * (1 - z2) + s2[F + 4] * z2;
          }
        } else if (6 == u2 && e6.t278) {
          var U = e6.t278[0];
          for (p2 = 0; p2 < a2; p2 += U) {
            g = p2 * n2;
            for (var Z = U * n2, j = 0; j < Z; j++) {
              b2 = 4 * (g + j), D = s2[(F = 3 * g + 4 * (j >>> 1)) + (1 & j)];
              var G = s2[F + 2] - 128, H = s2[F + 3] - 128, Q = D + ((H >> 2) + (H >> 3) + (H >> 5)), W = D - ((G >> 2) + (G >> 4) + (G >> 5)) - ((H >> 1) + (H >> 3) + (H >> 4) + (H >> 5)), q = D + (G + (G >> 1) + (G >> 2) + (G >> 6));
              l2[b2] = Math.max(0, Math.min(255, Q)), l2[b2 + 1] = Math.max(0, Math.min(255, W)), l2[b2 + 2] = Math.max(0, Math.min(255, q)), l2[b2 + 3] = 255;
            }
          }
        } else if (32845 == u2)
          for (p2 = 0; p2 < a2; p2++)
            for (B2 = 0; B2 < n2; B2++) {
              b2 = 4 * (p2 * n2 + B2);
              var V = s2[(F = 6 * (p2 * n2 + B2)) + 1] << 8 | s2[F], Y2 = (V = Math.pow(2, (V + 0.5) / 256 - 64), (s2[F + 3] + 0.5) / 410), K = (s2[F + 5] + 0.5) / 410, J = 9 * Y2 / (6 * Y2 - 16 * K + 12), X = 4 * K / (6 * Y2 - 16 * K + 12), ee = J * V / X, te = (1 - J - X) * V / X;
              Q = 2.69 * ee - 1.276 * (D = V) - 0.414 * te, W = -1.022 * ee + 1.978 * D + 0.044 * te, q = 0.061 * ee - 0.224 * D + 1.163 * te;
              l2[b2] = 255 * r2(Math.min(Q, 1)), l2[b2 + 1] = 255 * r2(Math.min(W, 1)), l2[b2 + 2] = 255 * r2(Math.min(q, 1)), l2[b2 + 3] = 255;
            }
        else
          i2("Unknown Photometric interpretation: " + u2);
        return l2;
      }, e5.replaceIMG = function(t4) {
        null == t4 && (t4 = document.getElementsByTagName("img"));
        for (var i3 = ["tif", "tiff", "dng", "cr2", "nef"], r2 = 0; r2 < t4.length; r2++) {
          var n2 = t4[r2], a2 = n2.getAttribute("src");
          if (null != a2) {
            var o2 = a2.split(".").pop().toLowerCase();
            if (-1 != i3.indexOf(o2)) {
              var s2 = new XMLHttpRequest();
              e5._xhrs.push(s2), e5._imgs.push(n2), s2.open("GET", a2), s2.responseType = "arraybuffer", s2.onload = e5._imgLoaded, s2.send();
            }
          }
        }
      }, e5._xhrs = [], e5._imgs = [], e5._imgLoaded = function(t4) {
        var i3 = e5._xhrs.indexOf(t4.target), r2 = e5._imgs[i3];
        e5._xhrs.splice(i3, 1), e5._imgs.splice(i3, 1), r2.setAttribute("src", e5.bufferToURI(t4.target.response));
      }, e5.bufferToURI = function(t4) {
        var i3 = e5.decode(t4), r2 = i3, n2 = 0, a2 = r2[0];
        i3[0].subIFD && (r2 = r2.concat(i3[0].subIFD));
        for (var o2 = 0; o2 < r2.length; o2++) {
          var s2 = r2[o2];
          if (!(null == s2.t258 || s2.t258.length < 3)) {
            var l2 = s2.t256 * s2.t257;
            l2 > n2 && (n2 = l2, a2 = s2);
          }
        }
        e5.decodeImage(t4, a2, i3);
        var u2 = e5.toRGBA8(a2), h2 = a2.width, c2 = a2.height, f2 = document.createElement("canvas");
        f2.width = h2, f2.height = c2;
        var d = f2.getContext("2d"), p2 = new ImageData(new Uint8ClampedArray(u2.buffer), h2, c2);
        return d.putImageData(p2, 0, 0), f2.toDataURL();
      }, e5._binBE = { nextZero: function(e6, t4) {
        for (; 0 != e6[t4]; )
          t4++;
        return t4;
      }, readUshort: function(e6, t4) {
        return e6[t4] << 8 | e6[t4 + 1];
      }, readShort: function(t4, i3) {
        var r2 = e5._binBE.ui8;
        return r2[0] = t4[i3 + 1], r2[1] = t4[i3 + 0], e5._binBE.i16[0];
      }, readInt: function(t4, i3) {
        var r2 = e5._binBE.ui8;
        return r2[0] = t4[i3 + 3], r2[1] = t4[i3 + 2], r2[2] = t4[i3 + 1], r2[3] = t4[i3 + 0], e5._binBE.i32[0];
      }, readUint: function(t4, i3) {
        var r2 = e5._binBE.ui8;
        return r2[0] = t4[i3 + 3], r2[1] = t4[i3 + 2], r2[2] = t4[i3 + 1], r2[3] = t4[i3 + 0], e5._binBE.ui32[0];
      }, readASCII: function(e6, t4, i3) {
        for (var r2 = "", n2 = 0; n2 < i3; n2++)
          r2 += String.fromCharCode(e6[t4 + n2]);
        return r2;
      }, readFloat: function(t4, i3) {
        for (var r2 = e5._binBE.ui8, n2 = 0; n2 < 4; n2++)
          r2[n2] = t4[i3 + 3 - n2];
        return e5._binBE.fl32[0];
      }, readDouble: function(t4, i3) {
        for (var r2 = e5._binBE.ui8, n2 = 0; n2 < 8; n2++)
          r2[n2] = t4[i3 + 7 - n2];
        return e5._binBE.fl64[0];
      }, writeUshort: function(e6, t4, i3) {
        e6[t4] = i3 >> 8 & 255, e6[t4 + 1] = 255 & i3;
      }, writeInt: function(t4, i3, r2) {
        var n2 = e5._binBE.ui8;
        e5._binBE.i32[0] = r2, t4[i3 + 3] = n2[0], t4[i3 + 2] = n2[1], t4[i3 + 1] = n2[2], t4[i3 + 0] = n2[3];
      }, writeUint: function(e6, t4, i3) {
        e6[t4] = i3 >> 24 & 255, e6[t4 + 1] = i3 >> 16 & 255, e6[t4 + 2] = i3 >> 8 & 255, e6[t4 + 3] = 255 & i3;
      }, writeASCII: function(e6, t4, i3) {
        for (var r2 = 0; r2 < i3.length; r2++)
          e6[t4 + r2] = i3.charCodeAt(r2);
      }, writeDouble: function(t4, i3, r2) {
        e5._binBE.fl64[0] = r2;
        for (var n2 = 0; n2 < 8; n2++)
          t4[i3 + n2] = e5._binBE.ui8[7 - n2];
      } }, e5._binBE.ui8 = new Uint8Array(8), e5._binBE.i16 = new Int16Array(e5._binBE.ui8.buffer), e5._binBE.i32 = new Int32Array(e5._binBE.ui8.buffer), e5._binBE.ui32 = new Uint32Array(e5._binBE.ui8.buffer), e5._binBE.fl32 = new Float32Array(e5._binBE.ui8.buffer), e5._binBE.fl64 = new Float64Array(e5._binBE.ui8.buffer), e5._binLE = { nextZero: e5._binBE.nextZero, readUshort: function(e6, t4) {
        return e6[t4 + 1] << 8 | e6[t4];
      }, readShort: function(t4, i3) {
        var r2 = e5._binBE.ui8;
        return r2[0] = t4[i3 + 0], r2[1] = t4[i3 + 1], e5._binBE.i16[0];
      }, readInt: function(t4, i3) {
        var r2 = e5._binBE.ui8;
        return r2[0] = t4[i3 + 0], r2[1] = t4[i3 + 1], r2[2] = t4[i3 + 2], r2[3] = t4[i3 + 3], e5._binBE.i32[0];
      }, readUint: function(t4, i3) {
        var r2 = e5._binBE.ui8;
        return r2[0] = t4[i3 + 0], r2[1] = t4[i3 + 1], r2[2] = t4[i3 + 2], r2[3] = t4[i3 + 3], e5._binBE.ui32[0];
      }, readASCII: e5._binBE.readASCII, readFloat: function(t4, i3) {
        for (var r2 = e5._binBE.ui8, n2 = 0; n2 < 4; n2++)
          r2[n2] = t4[i3 + n2];
        return e5._binBE.fl32[0];
      }, readDouble: function(t4, i3) {
        for (var r2 = e5._binBE.ui8, n2 = 0; n2 < 8; n2++)
          r2[n2] = t4[i3 + n2];
        return e5._binBE.fl64[0];
      }, writeUshort: function(e6, t4, i3) {
        e6[t4] = 255 & i3, e6[t4 + 1] = i3 >> 8 & 255;
      }, writeInt: function(t4, i3, r2) {
        var n2 = e5._binBE.ui8;
        e5._binBE.i32[0] = r2, t4[i3 + 0] = n2[0], t4[i3 + 1] = n2[1], t4[i3 + 2] = n2[2], t4[i3 + 3] = n2[3];
      }, writeUint: function(e6, t4, i3) {
        e6[t4] = i3 >>> 0 & 255, e6[t4 + 1] = i3 >>> 8 & 255, e6[t4 + 2] = i3 >>> 16 & 255, e6[t4 + 3] = i3 >>> 24 & 255;
      }, writeASCII: e5._binBE.writeASCII }, e5._copyTile = function(e6, t4, i3, r2, n2, a2, o2, s2) {
        for (var l2 = Math.min(t4, n2 - o2), u2 = Math.min(i3, a2 - s2), h2 = 0; h2 < u2; h2++)
          for (var c2 = (s2 + h2) * n2 + o2, f2 = h2 * t4, d = 0; d < l2; d++)
            r2[c2 + d] = e6[f2 + d];
      }, e5.LosslessJpegDecode = function() {
        var e6, t4;
        function i3() {
          return e6[t4++];
        }
        function r2() {
          return e6[t4++] << 8 | e6[t4++];
        }
        function n2(e7) {
          for (var t5 = i3(), r3 = [0, 0, 0, 255], n3 = [], o3 = 0; o3 < 16; o3++)
            n3[o3] = i3();
          for (o3 = 0; o3 < 16; o3++)
            for (var s3 = 0; s3 < n3[o3]; s3++) {
              r3[a2(r3, 0, o3 + 1, 1) + 3] = i3();
            }
          var l3 = new Uint8Array(256);
          e7[t5] = [new Uint8Array(r3), l3];
          for (o3 = 0; o3 < 256; o3++) {
            for (var u3 = 8, h3 = o3, c3 = 0; 255 == r3[c3 + 3] && 0 != u3; )
              c3 = r3[c3 + (h3 >> --u3 & 1)];
            l3[o3] = c3;
          }
        }
        function a2(e7, t5, i4, r3) {
          if (255 != e7[t5 + 3])
            return 0;
          if (0 == i4)
            return t5;
          for (var n3 = 0; n3 < 2; n3++) {
            0 == e7[t5 + n3] && (e7[t5 + n3] = e7.length, e7.push(0, 0, r3, 255));
            var o3 = a2(e7, e7[t5 + n3], i4 - 1, r3 + 1);
            if (0 != o3)
              return o3;
          }
          return 0;
        }
        function o2(e7) {
          for (var t5 = e7.b, i4 = e7.f; t5 < 25 && e7.a < e7.d; ) {
            var r3 = e7.data[e7.a++];
            255 != r3 || e7.c || e7.a++, i4 = i4 << 8 | r3, t5 += 8;
          }
          if (t5 < 0)
            throw "e";
          e7.b = t5, e7.f = i4;
        }
        function s2(e7, t5) {
          return t5.b < e7 && o2(t5), t5.f >> (t5.b -= e7) & 65535 >> 16 - e7;
        }
        function l2(e7, t5) {
          var i4 = e7[0], r3 = 0, n3 = 255;
          t5.b < 16 && o2(t5);
          var a3 = t5.f >> t5.b - 8 & 255;
          for (n3 = i4[(r3 = e7[1][a3]) + 3], t5.b -= i4[r3 + 2]; 255 == n3; )
            n3 = i4[(r3 = i4[r3 + (t5.f >> --t5.b & 1)]) + 3];
          return n3;
        }
        function u2(e7, t5) {
          return e7 < 32768 >> 16 - t5 && (e7 += 1 - (1 << t5)), e7;
        }
        function h2(e7, t5) {
          var i4 = l2(e7, t5);
          return 0 == i4 ? 0 : 16 == i4 ? -32768 : u2(s2(i4, t5), i4);
        }
        function c2(e7, t5, i4, r3, n3, a3) {
          for (var o3 = 0, s3 = 0; s3 < a3; s3++) {
            for (var l3 = s3 * t5, u3 = 0; u3 < t5; u3 += n3) {
              o3++;
              for (var c3 = 0; c3 < n3; c3++)
                e7[l3 + u3 + c3] = h2(r3[c3], i4);
            }
            if (0 != i4.e && o3 % i4.e == 0 && 0 != s3) {
              for (var f3 = i4.a, d2 = i4.data; 255 != d2[f3] || !(208 <= d2[f3 + 1] && d2[f3 + 1] <= 215); )
                f3--;
              i4.a = f3 + 2, i4.f = 0, i4.b = 0;
            }
          }
        }
        function f2(e7, t5) {
          return u2(s2(e7, t5), e7);
        }
        function d(e7, t5, i4, r3, n3, a3, o3, s3) {
          for (var l3 = i4 * o3, u3 = n3; u3 < a3; u3++)
            e7[u3] += 1 << s3 - 1;
          for (var h3 = o3; h3 < l3; h3 += o3)
            for (u3 = n3; u3 < a3; u3++)
              e7[h3 + u3] += e7[h3 + u3 - o3];
          for (var c3 = 1; c3 < r3; c3++) {
            var f3 = c3 * l3;
            for (u3 = n3; u3 < a3; u3++)
              e7[f3 + u3] += e7[f3 + u3 - l3];
            for (h3 = o3; h3 < l3; h3 += o3)
              for (u3 = n3; u3 < a3; u3++) {
                var d2 = f3 + h3 + u3, p2 = d2 - l3, m = e7[d2 - o3], _2 = 0;
                if (0 == t5)
                  _2 = 0;
                else if (1 == t5)
                  _2 = m;
                else if (2 == t5)
                  _2 = e7[p2];
                else if (3 == t5)
                  _2 = e7[p2 - o3];
                else if (4 == t5)
                  _2 = m + (e7[p2] - e7[p2 - o3]);
                else if (5 == t5)
                  _2 = m + (e7[p2] - e7[p2 - o3] >>> 1);
                else if (6 == t5)
                  _2 = e7[p2] + (m - e7[p2 - o3] >>> 1);
                else {
                  if (7 != t5)
                    throw t5;
                  _2 = m + e7[p2] >>> 1;
                }
                e7[d2] += _2;
              }
          }
        }
        return function(a3) {
          if (e6 = a3, t4 = 0, 65496 != r2())
            throw "e";
          for (var o3 = [], s3 = 0, u3 = 0, h3 = 0, p2 = [], m = [], _2 = [], g = 0, b2 = 0, y2 = 0; ; ) {
            var w = r2();
            if (65535 != w) {
              var v2 = r2();
              if (65475 == w) {
                u3 = i3(), b2 = r2(), y2 = r2(), g = i3();
                for (var x2 = 0; x2 < g; x2++) {
                  var E2 = i3(), k2 = i3();
                  if (0 != i3())
                    throw "e";
                  o3[E2] = [x2, k2 >> 4, 15 & k2];
                }
              } else if (65476 == w)
                for (var S2 = t4 + v2 - 2; t4 < S2; )
                  n2(m);
              else {
                if (65498 == w) {
                  t4++;
                  for (x2 = 0; x2 < g; x2++) {
                    var A2 = o3[i3()];
                    _2[A2[0]] = m[i3() >>> 4], p2[A2[0]] = A2.slice(1);
                  }
                  s3 = i3(), t4 += 2;
                  break;
                }
                65501 == w ? h3 = r2() : t4 += v2 - 2;
              }
            } else
              t4--;
          }
          var I = new (u3 > 8 ? Uint16Array : Uint8Array)(b2 * y2 * g), M2 = { b: 0, f: 0, c: 8 == s3, a: t4, data: e6, d: e6.length, e: h3 };
          if (M2.c)
            !function(i4, r3, n3, a4, o4) {
              for (var s4 = e6.length - t4, u4 = 0; u4 < s4; u4 += 4) {
                var h4 = e6[t4 + u4];
                e6[t4 + u4] = e6[t4 + u4 + 3], e6[t4 + u4 + 3] = h4, h4 = e6[t4 + u4 + 1], e6[t4 + u4 + 1] = e6[t4 + u4 + 2], e6[t4 + u4 + 2] = h4;
              }
              for (var c3 = 0; c3 < o4; c3++)
                for (var d2 = 32768, p3 = 32768, m2 = 0; m2 < r3; m2 += 2) {
                  var _3 = l2(a4, n3), g2 = l2(a4, n3);
                  0 != _3 && (d2 += f2(_3, n3)), 0 != g2 && (p3 += f2(g2, n3)), i4[c3 * r3 + m2] = 65535 & d2, i4[c3 * r3 + m2 + 1] = 65535 & p3;
                }
            }(I, y2 * g, M2, _2[0], b2);
          else {
            var T2 = [], P = 0, B2 = 0;
            for (x2 = 0; x2 < g; x2++) {
              var C2 = p2[x2];
              (Z = C2[0]) > P && (P = Z), (U = C2[1]) > B2 && (B2 = U), T2.push(Z * U);
            }
            if (1 != P || 1 != B2) {
              if (3 != g || 1 != T2[1] || 1 != T2[2])
                throw "e";
              if (2 != P || 1 != B2 && 2 != B2)
                throw "e";
              var R2 = [], z2 = 0;
              for (x2 = 0; x2 < g; x2++) {
                for (var F = 0; F < T2[x2]; F++)
                  R2.push(_2[x2]);
                z2 += T2[x2];
              }
              var N2 = y2 / P, O2 = b2 / B2, D = N2 * O2;
              c2(I, N2 * z2, M2, R2, z2, O2), d(I, s3, N2, O2, z2 - 2, z2, z2, u3);
              var $ = new Uint16Array(D * T2[0]);
              if (2 == P && 2 == B2) {
                for (x2 = 0; x2 < D; x2++)
                  $[4 * x2] = I[6 * x2], $[4 * x2 + 1] = I[6 * x2 + 1], $[4 * x2 + 2] = I[6 * x2 + 2], $[4 * x2 + 3] = I[6 * x2 + 3];
                d($, s3, 4 * N2, O2, 0, 1, 1, u3);
                for (x2 = 0; x2 < D; x2++)
                  I[6 * x2] = $[4 * x2], I[6 * x2 + 1] = $[4 * x2 + 1], I[6 * x2 + 2] = $[4 * x2 + 2], I[6 * x2 + 3] = $[4 * x2 + 3];
              }
              if (2 == P && 1 == B2) {
                for (x2 = 0; x2 < D; x2++)
                  $[2 * x2] = I[4 * x2], $[2 * x2 + 1] = I[4 * x2 + 1];
                d($, s3, 2 * N2, O2, 0, 1, 1, u3);
                for (x2 = 0; x2 < D; x2++)
                  I[4 * x2] = $[2 * x2], I[4 * x2 + 1] = $[2 * x2 + 1];
              }
              for (var L2 = I.slice(0), U = 0; U < b2; U++)
                if (2 == B2)
                  for (var Z = 0; Z < y2; Z++) {
                    var j = ((U >>> 1) * N2 + (Z >>> 1)) * z2, G = 2 * (1 & U) + (1 & Z);
                    I[H = (U * y2 + Z) * g] = L2[j + G], I[H + 1] = L2[j + 4], I[H + 2] = L2[j + 5];
                  }
                else
                  for (Z = 0; Z < y2; Z++) {
                    var H;
                    j = (U * N2 + (Z >>> 1)) * z2, G = 1 & Z;
                    I[H = (U * y2 + Z) * g] = L2[j + G], I[H + 1] = L2[j + 2], I[H + 2] = L2[j + 3];
                  }
            } else if (c2(I, y2 * g, M2, _2, g, b2), 0 == h3)
              d(I, s3, y2, b2, 0, g, g, u3);
            else {
              var Q = Math.floor(h3 / y2);
              for (U = 0; U < b2; U += Q) {
                var W = I.slice(U * y2 * g, (U + Q) * y2 * g);
                d(W, s3, y2, Q, 0, g, g, u3), I.set(W, U * y2 * g);
              }
            }
          }
          return I;
        };
      }(), function() {
        var t4 = 2, i3 = 4, r2 = 5, n2 = 6, a2 = 7, o2 = 12, s2 = 13, l2 = 14, u2 = 15, h2 = 17;
        function c2(e6) {
          var t5 = { c: new Int8Array(2 << e6.u) };
          return function(e7, t6, i4) {
            var r3 = [t6, 3 * t6 + 18, 5 * t6 + 67, 7 * t6 + 276, i4];
            e7.o = t6, e7.w = (r3[4] + 2 * t6) / (2 * t6 + 1) + 1 | 0, e7.v = Math.ceil(Math.log2(e7.w)), e7.t = 9, function(e8, t7) {
              for (var i5 = -t7[4], r4 = 0; i5 <= t7[4]; r4++, i5++)
                e8[r4] = i5 <= -t7[3] ? -4 : i5 <= -t7[2] ? -3 : i5 <= -t7[1] ? -2 : i5 < -t7[0] ? -1 : i5 <= t7[0] ? 0 : i5 < t7[1] ? 1 : i5 < t7[2] ? 2 : i5 < t7[3] ? 3 : 4;
            }(e7.c, r3);
          }(t5, 0, e6.g), t5;
        }
        function f2(e6) {
          for (var t5 = [[], [], []], i4 = Math.max(2, e6.w + 32 >>> 6), r3 = 0; r3 < 3; r3++)
            for (var n3 = 0; n3 < 41; n3++)
              t5[r3][n3] = [i4, 1];
          return t5;
        }
        function d(e6, t5) {
          var i4 = 0, r3 = 8 - e6.a;
          if (e6.j, e6.a, t5) {
            if (t5 >= r3)
              do {
                i4 <<= r3, t5 -= r3, i4 |= e6[e6.j] & (1 << r3) - 1, e6.j++, r3 = 8;
              } while (t5 >= 8);
            t5 && (i4 <<= t5, r3 -= t5, i4 |= e6[e6.j] >>> r3 & (1 << t5) - 1), e6.a = 8 - r3;
          }
          return i4;
        }
        function p2(e6, t5, i4, r3, n3, a3, o3, s3) {
          null == s3 && (s3 = 0);
          var l3, u3, h3, c3, f3, p3, m2 = a3 + 1, _3 = m2 % 2, g2 = 0, b3 = r3[n3], y3 = r3[n3 - 1], w = r3[n3 - 2][m2], v2 = y3[m2 - 1], x2 = y3[m2], E2 = y3[m2 + 1], k2 = b3[m2 - 1], S2 = b3[m2 + 1], A2 = Math.abs;
          if (_3 && (h3 = A2(E2 - x2), c3 = A2(w - x2), f3 = A2(v2 - x2)), _3) {
            if (p3 = (p3 = h3 > f3 && c3 < h3 ? w + v2 : h3 < f3 && c3 < f3 ? w + E2 : E2 + v2) + 2 * x2 >>> 2, s3)
              return void (b3[m2] = p3);
            l3 = t5.t * t5.c[e6.g + x2 - w] + t5.c[e6.g + v2 - x2];
          } else
            p3 = x2 > v2 && x2 > E2 || x2 < v2 && x2 < E2 ? S2 + k2 + 2 * x2 >>> 2 : k2 + S2 >>> 1, l3 = t5.t * t5.c[e6.g + x2 - v2] + t5.c[e6.g + v2 - k2];
          u3 = A2(l3);
          var I = function(e7) {
            for (var t6 = -1, i5 = 0; !i5; t6++)
              i5 = e7[e7.j] >>> 7 - e7.a & 1, e7.a++, e7.a &= 7, e7.a || e7.j++;
            return t6;
          }(i4);
          if (I < e6.n - t5.v - 1) {
            var M2 = function(e7, t6) {
              var i5 = 0;
              if (t6 < e7)
                for (; i5 <= 14 && t6 << ++i5 < e7; )
                  ;
              return i5;
            }(o3[u3][0], o3[u3][1]);
            g2 = d(i4, M2) + (I << M2);
          } else
            g2 = d(i4, t5.v) + 1;
          g2 = 1 & g2 ? -1 - (g2 >>> 1) : g2 >>> 1, o3[u3][0] += A2(g2), o3[u3][1] == e6.f && (o3[u3][0] >>>= 1, o3[u3][1] >>>= 1), o3[u3][1]++, p3 = l3 < 0 ? p3 - g2 : p3 + g2, e6.i && (p3 < 0 ? p3 += t5.w : p3 > e6.g && (p3 -= t5.w)), b3[m2] = p3 >= 0 ? Math.min(p3, e6.g) : 0;
        }
        function m(e6, t5, i4) {
          for (var r3 = e6[0].length, n3 = t5; n3 <= i4; n3++)
            e6[n3][0] = e6[n3 - 1][1], e6[n3][r3 - 1] = e6[n3 - 1][r3 - 2];
        }
        function _2(e6) {
          m(e6, a2, o2), m(e6, t4, i3), m(e6, u2, h2);
        }
        function g(e6, t5, r3, n3, a3, o3, l3, u3, h3, c3, f3, d2, m2) {
          for (var g2 = 0, b3 = 1, y3 = a3 < s2 && a3 > i3; b3 < e6.m; )
            g2 < e6.m && (p2(e6, t5, r3, n3, a3, g2, l3[h3], e6.h && (y3 && c3 || !y3 && (f3 || (g2 & d2) == m2))), p2(e6, t5, r3, n3, o3, g2, l3[h3], e6.h && (!y3 && c3 || y3 && (f3 || (g2 & d2) == m2))), g2 += 2), g2 > 8 && (p2(e6, t5, r3, n3, a3, b3, u3[h3]), p2(e6, t5, r3, n3, o3, b3, u3[h3]), b3 += 2);
          _2(n3);
        }
        function b2(e6, r3, n3, s3, l3, c3) {
          g(e6, r3, n3, s3, t4, a2, l3, c3, 0, 0, 1, 0, 8), g(e6, r3, n3, s3, 8, u2, l3, c3, 1, 0, 1, 0, 8), g(e6, r3, n3, s3, 3, 9, l3, c3, 2, 1, 0, 3, 0), g(e6, r3, n3, s3, 10, 16, l3, c3, 0, 0, 0, 3, 2), g(e6, r3, n3, s3, i3, 11, l3, c3, 1, 0, 0, 3, 2), g(e6, r3, n3, s3, o2, h2, l3, c3, 2, 1, 0, 3, 0);
        }
        function y2(e6, i4, r3, n3, o3, s3) {
          var l3 = s3.length, h3 = e6.l;
          o3 + 1 == e6.s && (h3 = e6.e - o3 * e6.l);
          for (var c3 = 6 * e6.e * n3 + o3 * e6.l, f3 = 0; f3 < 6; f3++) {
            for (var d2 = 0; d2 < h3; d2++) {
              var p3, m2 = s3[f3 % l3][d2 % l3];
              p3 = 0 == m2 ? t4 + (f3 >>> 1) : 2 == m2 ? u2 + (f3 >>> 1) : a2 + f3;
              var _3 = e6.h ? (2 * d2 / 3 & 2147483646 | d2 % 3 & 1) + (d2 % 3 >>> 1) : d2 >>> 1;
              i4[c3 + d2] = r3[p3][_3 + 1];
            }
            c3 += e6.e;
          }
        }
        e5._decompressRAF = function(a3, u3) {
          var d2 = function(t5) {
            var i4 = e5._binBE.readUshort, r3 = { b: i4(t5, 0), i: t5[2], C: t5[3], u: t5[4], q: i4(t5, 5), k: i4(t5, 7), e: i4(t5, 9), l: i4(t5, 11), s: t5[13], d: i4(t5, 14) };
            if (18771 != r3.b || r3.i > 1 || r3.q < 6 || r3.q % 6 || r3.e < 768 || r3.e % 24 || 768 != r3.l || r3.k < r3.l || r3.k % r3.l || r3.k - r3.e >= r3.l || r3.s > 16 || r3.s != r3.k / r3.l || r3.s != Math.ceil(r3.e / r3.l) || r3.d != r3.q / 6 || 12 != r3.u && 14 != r3.u && 16 != r3.u || 16 != r3.C && 0 != r3.C)
              throw "Invalid data";
            if (0 == r3.i)
              throw "Not implemented. We need this file!";
            return r3.h = 16 == r3.C, r3.m = 0 | (r3.h ? 2 * r3.l / 3 : r3.l >>> 1), r3.A = r3.m + 2, r3.f = 64, r3.g = (1 << r3.u) - 1, r3.n = 4 * r3.u, r3;
          }(a3), p3 = function(t5, i4) {
            var r3 = new Array(i4.s), n3 = 4 * i4.s, a4 = 16 + n3;
            12 & n3 && (a4 += 16 - (12 & n3));
            for (var o3 = 0, s3 = 16; o3 < i4.s; s3 += 4) {
              var l3 = e5._binBE.readUint(t5, s3);
              r3[o3] = t5.slice(a4, a4 + l3), r3[o3].j = 0, r3[o3].a = 0, a4 += l3, o3++;
            }
            if (a4 != t5.length)
              throw "Invalid data";
            return r3;
          }(a3, d2), m2 = c2(d2), g2 = new Int16Array(d2.e * d2.q);
          null == u3 && (u3 = d2.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]]);
          for (var w = [[0, 3], [1, i3], [r2, 11], [n2, o2], [s2, 16], [l2, h2]], v2 = [], x2 = 0; x2 < 18; x2++)
            v2[x2] = new Uint16Array(d2.A);
          for (var E2 = 0; E2 < d2.s; E2++) {
            var k2 = f2(m2), S2 = f2(m2);
            for (x2 = 0; x2 < 18; x2++)
              for (var A2 = 0; A2 < d2.A; A2++)
                v2[x2][A2] = 0;
            for (var I = 0; I < d2.d; I++) {
              b2(d2, m2, p3[E2], v2, k2, S2);
              for (x2 = 0; x2 < 6; x2++)
                for (A2 = 0; A2 < d2.A; A2++)
                  v2[w[x2][0]][A2] = v2[w[x2][1]][A2];
              y2(d2, g2, v2, I, E2, u3);
              for (x2 = t4; x2 < 18; x2++)
                if (-1 == [r2, n2, s2, l2].indexOf(x2))
                  for (A2 = 0; A2 < d2.A; A2++)
                    v2[x2][A2] = 0;
              _2(v2);
            }
          }
          return g2;
        };
      }();
    }(t2, "function" == typeof commonjsRequire ? requirePako() : self.pako);
  }();
}(UTIF);
var UTIFExports = UTIF.exports;
var utif = getDefaultExportFromCjs(UTIFExports);
var util$1;
var objectUtil;
function getDimensionValue(e4) {
  return "number" == typeof e4 ? e4 : e4 instanceof Uint8Array ? e4[0] : "string" == typeof e4[0] ? parseInt(e4[0]) : e4[0];
}
function tiff() {
  return { mime: "image/tiff", encode: (e4) => {
    const t2 = utif.encodeImage(e4.data, e4.width, e4.height);
    return Buffer2.from(t2);
  }, decode: (e4) => {
    const t2 = utif.decode(e4), i2 = t2[0];
    if (!i2)
      throw new Error("No page found in TIFF");
    if (!i2.t256)
      throw new Error("No image width found in TIFF");
    if (!i2.t257)
      throw new Error("No image height found in TIFF");
    t2.forEach((t3) => {
      utif.decodeImage(e4, t3);
    });
    const r2 = utif.toRGBA8(i2);
    return { data: Buffer2.from(r2), width: getDimensionValue(i2.t256), height: getDimensionValue(i2.t257) };
  } };
}
!function(e4) {
  e4.assertEqual = (e5) => e5, e4.assertIs = function(e5) {
  }, e4.assertNever = function(e5) {
    throw new Error();
  }, e4.arrayToEnum = (e5) => {
    const t2 = {};
    for (const i2 of e5)
      t2[i2] = i2;
    return t2;
  }, e4.getValidEnumValues = (t2) => {
    const i2 = e4.objectKeys(t2).filter((e5) => "number" != typeof t2[t2[e5]]), r2 = {};
    for (const e5 of i2)
      r2[e5] = t2[e5];
    return e4.objectValues(r2);
  }, e4.objectValues = (t2) => e4.objectKeys(t2).map(function(e5) {
    return t2[e5];
  }), e4.objectKeys = "function" == typeof Object.keys ? (e5) => Object.keys(e5) : (e5) => {
    const t2 = [];
    for (const i2 in e5)
      Object.prototype.hasOwnProperty.call(e5, i2) && t2.push(i2);
    return t2;
  }, e4.find = (e5, t2) => {
    for (const i2 of e5)
      if (t2(i2))
        return i2;
  }, e4.isInteger = "function" == typeof Number.isInteger ? (e5) => Number.isInteger(e5) : (e5) => "number" == typeof e5 && isFinite(e5) && Math.floor(e5) === e5, e4.joinValues = function(e5, t2 = " | ") {
    return e5.map((e6) => "string" == typeof e6 ? `'${e6}'` : e6).join(t2);
  }, e4.jsonStringifyReplacer = (e5, t2) => "bigint" == typeof t2 ? t2.toString() : t2;
}(util$1 || (util$1 = {})), function(e4) {
  e4.mergeShapes = (e5, t2) => ({ ...e5, ...t2 });
}(objectUtil || (objectUtil = {}));
var ZodParsedType = util$1.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var getParsedType = (e4) => {
  switch (typeof e4) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(e4) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(e4) ? ZodParsedType.array : null === e4 ? ZodParsedType.null : e4.then && "function" == typeof e4.then && e4.catch && "function" == typeof e4.catch ? ZodParsedType.promise : "undefined" != typeof Map && e4 instanceof Map ? ZodParsedType.map : "undefined" != typeof Set && e4 instanceof Set ? ZodParsedType.set : "undefined" != typeof Date && e4 instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util$1.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var quotelessJson = (e4) => JSON.stringify(e4, null, 2).replace(/"([^"]+)":/g, "$1:");
var ZodError = class extends Error {
  constructor(e4) {
    super(), this.issues = [], this.addIssue = (e5) => {
      this.issues = [...this.issues, e5];
    }, this.addIssues = (e5 = []) => {
      this.issues = [...this.issues, ...e5];
    };
    const t2 = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t2) : this.__proto__ = t2, this.name = "ZodError", this.issues = e4;
  }
  get errors() {
    return this.issues;
  }
  format(e4) {
    const t2 = e4 || function(e5) {
      return e5.message;
    }, i2 = { _errors: [] }, r2 = (e5) => {
      for (const n2 of e5.issues)
        if ("invalid_union" === n2.code)
          n2.unionErrors.map(r2);
        else if ("invalid_return_type" === n2.code)
          r2(n2.returnTypeError);
        else if ("invalid_arguments" === n2.code)
          r2(n2.argumentsError);
        else if (0 === n2.path.length)
          i2._errors.push(t2(n2));
        else {
          let e6 = i2, r3 = 0;
          for (; r3 < n2.path.length; ) {
            const i3 = n2.path[r3];
            r3 === n2.path.length - 1 ? (e6[i3] = e6[i3] || { _errors: [] }, e6[i3]._errors.push(t2(n2))) : e6[i3] = e6[i3] || { _errors: [] }, e6 = e6[i3], r3++;
          }
        }
    };
    return r2(this), i2;
  }
  static assert(e4) {
    if (!(e4 instanceof ZodError))
      throw new Error(`Not a ZodError: ${e4}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return 0 === this.issues.length;
  }
  flatten(e4 = (e5) => e5.message) {
    const t2 = {}, i2 = [];
    for (const r2 of this.issues)
      r2.path.length > 0 ? (t2[r2.path[0]] = t2[r2.path[0]] || [], t2[r2.path[0]].push(e4(r2))) : i2.push(e4(r2));
    return { formErrors: i2, fieldErrors: t2 };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (e4) => new ZodError(e4);
var errorMap = (e4, t2) => {
  let i2;
  switch (e4.code) {
    case ZodIssueCode.invalid_type:
      i2 = e4.received === ZodParsedType.undefined ? "Required" : `Expected ${e4.expected}, received ${e4.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      i2 = `Invalid literal value, expected ${JSON.stringify(e4.expected, util$1.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      i2 = `Unrecognized key(s) in object: ${util$1.joinValues(e4.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      i2 = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      i2 = `Invalid discriminator value. Expected ${util$1.joinValues(e4.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      i2 = `Invalid enum value. Expected ${util$1.joinValues(e4.options)}, received '${e4.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      i2 = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      i2 = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      i2 = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      "object" == typeof e4.validation ? "includes" in e4.validation ? (i2 = `Invalid input: must include "${e4.validation.includes}"`, "number" == typeof e4.validation.position && (i2 = `${i2} at one or more positions greater than or equal to ${e4.validation.position}`)) : "startsWith" in e4.validation ? i2 = `Invalid input: must start with "${e4.validation.startsWith}"` : "endsWith" in e4.validation ? i2 = `Invalid input: must end with "${e4.validation.endsWith}"` : util$1.assertNever(e4.validation) : i2 = "regex" !== e4.validation ? `Invalid ${e4.validation}` : "Invalid";
      break;
    case ZodIssueCode.too_small:
      i2 = "array" === e4.type ? `Array must contain ${e4.exact ? "exactly" : e4.inclusive ? "at least" : "more than"} ${e4.minimum} element(s)` : "string" === e4.type ? `String must contain ${e4.exact ? "exactly" : e4.inclusive ? "at least" : "over"} ${e4.minimum} character(s)` : "number" === e4.type ? `Number must be ${e4.exact ? "exactly equal to " : e4.inclusive ? "greater than or equal to " : "greater than "}${e4.minimum}` : "date" === e4.type ? `Date must be ${e4.exact ? "exactly equal to " : e4.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e4.minimum))}` : "Invalid input";
      break;
    case ZodIssueCode.too_big:
      i2 = "array" === e4.type ? `Array must contain ${e4.exact ? "exactly" : e4.inclusive ? "at most" : "less than"} ${e4.maximum} element(s)` : "string" === e4.type ? `String must contain ${e4.exact ? "exactly" : e4.inclusive ? "at most" : "under"} ${e4.maximum} character(s)` : "number" === e4.type ? `Number must be ${e4.exact ? "exactly" : e4.inclusive ? "less than or equal to" : "less than"} ${e4.maximum}` : "bigint" === e4.type ? `BigInt must be ${e4.exact ? "exactly" : e4.inclusive ? "less than or equal to" : "less than"} ${e4.maximum}` : "date" === e4.type ? `Date must be ${e4.exact ? "exactly" : e4.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e4.maximum))}` : "Invalid input";
      break;
    case ZodIssueCode.custom:
      i2 = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      i2 = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      i2 = `Number must be a multiple of ${e4.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      i2 = "Number must be finite";
      break;
    default:
      i2 = t2.defaultError, util$1.assertNever(e4);
  }
  return { message: i2 };
};
var overrideErrorMap = errorMap;
function setErrorMap(e4) {
  overrideErrorMap = e4;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (e4) => {
  const { data: t2, path: i2, errorMaps: r2, issueData: n2 } = e4, a2 = [...i2, ...n2.path || []], o2 = { ...n2, path: a2 };
  if (void 0 !== n2.message)
    return { ...n2, path: a2, message: n2.message };
  let s2 = "";
  const l2 = r2.filter((e5) => !!e5).slice().reverse();
  for (const e5 of l2)
    s2 = e5(o2, { data: t2, defaultError: s2 }).message;
  return { ...n2, path: a2, message: s2 };
};
var EMPTY_PATH = [];
function addIssueToContext(e4, t2) {
  const i2 = getErrorMap(), r2 = makeIssue({ issueData: t2, data: e4.data, path: e4.path, errorMaps: [e4.common.contextualErrorMap, e4.schemaErrorMap, i2, i2 === errorMap ? void 0 : errorMap].filter((e5) => !!e5) });
  e4.common.issues.push(r2);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    "valid" === this.value && (this.value = "dirty");
  }
  abort() {
    "aborted" !== this.value && (this.value = "aborted");
  }
  static mergeArray(e4, t2) {
    const i2 = [];
    for (const r2 of t2) {
      if ("aborted" === r2.status)
        return INVALID;
      "dirty" === r2.status && e4.dirty(), i2.push(r2.value);
    }
    return { status: e4.value, value: i2 };
  }
  static async mergeObjectAsync(e4, t2) {
    const i2 = [];
    for (const e5 of t2) {
      const t3 = await e5.key, r2 = await e5.value;
      i2.push({ key: t3, value: r2 });
    }
    return ParseStatus.mergeObjectSync(e4, i2);
  }
  static mergeObjectSync(e4, t2) {
    const i2 = {};
    for (const r2 of t2) {
      const { key: t3, value: n2 } = r2;
      if ("aborted" === t3.status)
        return INVALID;
      if ("aborted" === n2.status)
        return INVALID;
      "dirty" === t3.status && e4.dirty(), "dirty" === n2.status && e4.dirty(), "__proto__" === t3.value || void 0 === n2.value && !r2.alwaysSet || (i2[t3.value] = n2.value);
    }
    return { status: e4.value, value: i2 };
  }
};
var INVALID = Object.freeze({ status: "aborted" });
var DIRTY = (e4) => ({ status: "dirty", value: e4 });
var OK = (e4) => ({ status: "valid", value: e4 });
var isAborted = (e4) => "aborted" === e4.status;
var isDirty = (e4) => "dirty" === e4.status;
var isValid = (e4) => "valid" === e4.status;
var isAsync = (e4) => "undefined" != typeof Promise && e4 instanceof Promise;
function __classPrivateFieldGet(e4, t2, i2, r2) {
  if ("function" == typeof t2 ? e4 !== t2 || !r2 : !t2.has(e4))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t2.get(e4);
}
function __classPrivateFieldSet(e4, t2, i2, r2, n2) {
  if ("function" == typeof t2 ? e4 !== t2 || !n2 : !t2.has(e4))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t2.set(e4, i2), i2;
}
var errorUtil;
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
"function" == typeof SuppressedError && SuppressedError, function(e4) {
  e4.errToObj = (e5) => "string" == typeof e5 ? { message: e5 } : e5 || {}, e4.toString = (e5) => "string" == typeof e5 ? e5 : null == e5 ? void 0 : e5.message;
}(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(e4, t2, i2, r2) {
    this._cachedPath = [], this.parent = e4, this.data = t2, this._path = i2, this._key = r2;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var handleResult = (e4, t2) => {
  if (isValid(t2))
    return { success: true, data: t2.value };
  if (!e4.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: false, get error() {
    if (this._error)
      return this._error;
    const t3 = new ZodError(e4.common.issues);
    return this._error = t3, this._error;
  } };
};
function processCreateParams(e4) {
  if (!e4)
    return {};
  const { errorMap: t2, invalid_type_error: i2, required_error: r2, description: n2 } = e4;
  if (t2 && (i2 || r2))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (t2)
    return { errorMap: t2, description: n2 };
  return { errorMap: (t3, n3) => {
    var a2, o2;
    const { message: s2 } = e4;
    return "invalid_enum_value" === t3.code ? { message: null != s2 ? s2 : n3.defaultError } : void 0 === n3.data ? { message: null !== (a2 = null != s2 ? s2 : r2) && void 0 !== a2 ? a2 : n3.defaultError } : "invalid_type" !== t3.code ? { message: n3.defaultError } : { message: null !== (o2 = null != s2 ? s2 : i2) && void 0 !== o2 ? o2 : n3.defaultError };
  }, description: n2 };
}
var ZodType = class {
  constructor(e4) {
    this.spa = this.safeParseAsync, this._def = e4, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e4) {
    return getParsedType(e4.data);
  }
  _getOrReturnCtx(e4, t2) {
    return t2 || { common: e4.parent.common, data: e4.data, parsedType: getParsedType(e4.data), schemaErrorMap: this._def.errorMap, path: e4.path, parent: e4.parent };
  }
  _processInputParams(e4) {
    return { status: new ParseStatus(), ctx: { common: e4.parent.common, data: e4.data, parsedType: getParsedType(e4.data), schemaErrorMap: this._def.errorMap, path: e4.path, parent: e4.parent } };
  }
  _parseSync(e4) {
    const t2 = this._parse(e4);
    if (isAsync(t2))
      throw new Error("Synchronous parse encountered promise.");
    return t2;
  }
  _parseAsync(e4) {
    const t2 = this._parse(e4);
    return Promise.resolve(t2);
  }
  parse(e4, t2) {
    const i2 = this.safeParse(e4, t2);
    if (i2.success)
      return i2.data;
    throw i2.error;
  }
  safeParse(e4, t2) {
    var i2;
    const r2 = { common: { issues: [], async: null !== (i2 = null == t2 ? void 0 : t2.async) && void 0 !== i2 && i2, contextualErrorMap: null == t2 ? void 0 : t2.errorMap }, path: (null == t2 ? void 0 : t2.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e4, parsedType: getParsedType(e4) }, n2 = this._parseSync({ data: e4, path: r2.path, parent: r2 });
    return handleResult(r2, n2);
  }
  async parseAsync(e4, t2) {
    const i2 = await this.safeParseAsync(e4, t2);
    if (i2.success)
      return i2.data;
    throw i2.error;
  }
  async safeParseAsync(e4, t2) {
    const i2 = { common: { issues: [], contextualErrorMap: null == t2 ? void 0 : t2.errorMap, async: true }, path: (null == t2 ? void 0 : t2.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e4, parsedType: getParsedType(e4) }, r2 = this._parse({ data: e4, path: i2.path, parent: i2 }), n2 = await (isAsync(r2) ? r2 : Promise.resolve(r2));
    return handleResult(i2, n2);
  }
  refine(e4, t2) {
    const i2 = (e5) => "string" == typeof t2 || void 0 === t2 ? { message: t2 } : "function" == typeof t2 ? t2(e5) : t2;
    return this._refinement((t3, r2) => {
      const n2 = e4(t3), a2 = () => r2.addIssue({ code: ZodIssueCode.custom, ...i2(t3) });
      return "undefined" != typeof Promise && n2 instanceof Promise ? n2.then((e5) => !!e5 || (a2(), false)) : !!n2 || (a2(), false);
    });
  }
  refinement(e4, t2) {
    return this._refinement((i2, r2) => !!e4(i2) || (r2.addIssue("function" == typeof t2 ? t2(i2, r2) : t2), false));
  }
  _refinement(e4) {
    return new ZodEffects({ schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "refinement", refinement: e4 } });
  }
  superRefine(e4) {
    return this._refinement(e4);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(e4) {
    return ZodUnion.create([this, e4], this._def);
  }
  and(e4) {
    return ZodIntersection.create(this, e4, this._def);
  }
  transform(e4) {
    return new ZodEffects({ ...processCreateParams(this._def), schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "transform", transform: e4 } });
  }
  default(e4) {
    const t2 = "function" == typeof e4 ? e4 : () => e4;
    return new ZodDefault({ ...processCreateParams(this._def), innerType: this, defaultValue: t2, typeName: ZodFirstPartyTypeKind.ZodDefault });
  }
  brand() {
    return new ZodBranded({ typeName: ZodFirstPartyTypeKind.ZodBranded, type: this, ...processCreateParams(this._def) });
  }
  catch(e4) {
    const t2 = "function" == typeof e4 ? e4 : () => e4;
    return new ZodCatch({ ...processCreateParams(this._def), innerType: this, catchValue: t2, typeName: ZodFirstPartyTypeKind.ZodCatch });
  }
  describe(e4) {
    return new (0, this.constructor)({ ...this._def, description: e4 });
  }
  pipe(e4) {
    return ZodPipeline.create(this, e4);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(e4) {
  let t2 = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e4.precision ? t2 = `${t2}\\.\\d{${e4.precision}}` : null == e4.precision && (t2 = `${t2}(\\.\\d+)?`), t2;
}
function timeRegex(e4) {
  return new RegExp(`^${timeRegexSource(e4)}$`);
}
function datetimeRegex(e4) {
  let t2 = `${dateRegexSource}T${timeRegexSource(e4)}`;
  const i2 = [];
  return i2.push(e4.local ? "Z?" : "Z"), e4.offset && i2.push("([+-]\\d{2}:?\\d{2})"), t2 = `${t2}(${i2.join("|")})`, new RegExp(`^${t2}$`);
}
function isValidIP(e4, t2) {
  return !("v4" !== t2 && t2 || !ipv4Regex.test(e4)) || !("v6" !== t2 && t2 || !ipv6Regex.test(e4));
}
var ZodString = class extends ZodType {
  _parse(e4) {
    this._def.coerce && (e4.data = String(e4.data));
    if (this._getType(e4) !== ZodParsedType.string) {
      const t3 = this._getOrReturnCtx(e4);
      return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.string, received: t3.parsedType }), INVALID;
    }
    const t2 = new ParseStatus();
    let i2;
    for (const r2 of this._def.checks)
      if ("min" === r2.kind)
        e4.data.length < r2.value && (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: r2.value, type: "string", inclusive: true, exact: false, message: r2.message }), t2.dirty());
      else if ("max" === r2.kind)
        e4.data.length > r2.value && (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: r2.value, type: "string", inclusive: true, exact: false, message: r2.message }), t2.dirty());
      else if ("length" === r2.kind) {
        const n2 = e4.data.length > r2.value, a2 = e4.data.length < r2.value;
        (n2 || a2) && (i2 = this._getOrReturnCtx(e4, i2), n2 ? addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: r2.value, type: "string", inclusive: true, exact: true, message: r2.message }) : a2 && addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: r2.value, type: "string", inclusive: true, exact: true, message: r2.message }), t2.dirty());
      } else if ("email" === r2.kind)
        emailRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "email", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("emoji" === r2.kind)
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "emoji", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("uuid" === r2.kind)
        uuidRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "uuid", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("nanoid" === r2.kind)
        nanoidRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "nanoid", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("cuid" === r2.kind)
        cuidRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "cuid", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("cuid2" === r2.kind)
        cuid2Regex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "cuid2", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("ulid" === r2.kind)
        ulidRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "ulid", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      else if ("url" === r2.kind)
        try {
          new URL(e4.data);
        } catch (n2) {
          i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "url", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty();
        }
      else if ("regex" === r2.kind) {
        r2.regex.lastIndex = 0;
        r2.regex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "regex", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty());
      } else if ("trim" === r2.kind)
        e4.data = e4.data.trim();
      else if ("includes" === r2.kind)
        e4.data.includes(r2.value, r2.position) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: { includes: r2.value, position: r2.position }, message: r2.message }), t2.dirty());
      else if ("toLowerCase" === r2.kind)
        e4.data = e4.data.toLowerCase();
      else if ("toUpperCase" === r2.kind)
        e4.data = e4.data.toUpperCase();
      else if ("startsWith" === r2.kind)
        e4.data.startsWith(r2.value) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: { startsWith: r2.value }, message: r2.message }), t2.dirty());
      else if ("endsWith" === r2.kind)
        e4.data.endsWith(r2.value) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: { endsWith: r2.value }, message: r2.message }), t2.dirty());
      else if ("datetime" === r2.kind) {
        datetimeRegex(r2).test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: "datetime", message: r2.message }), t2.dirty());
      } else if ("date" === r2.kind) {
        dateRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: "date", message: r2.message }), t2.dirty());
      } else if ("time" === r2.kind) {
        timeRegex(r2).test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: "time", message: r2.message }), t2.dirty());
      } else
        "duration" === r2.kind ? durationRegex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "duration", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty()) : "ip" === r2.kind ? isValidIP(e4.data, r2.version) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "ip", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty()) : "base64" === r2.kind ? base64Regex.test(e4.data) || (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { validation: "base64", code: ZodIssueCode.invalid_string, message: r2.message }), t2.dirty()) : util$1.assertNever(r2);
    return { status: t2.value, value: e4.data };
  }
  _regex(e4, t2, i2) {
    return this.refinement((t3) => e4.test(t3), { validation: t2, code: ZodIssueCode.invalid_string, ...errorUtil.errToObj(i2) });
  }
  _addCheck(e4) {
    return new ZodString({ ...this._def, checks: [...this._def.checks, e4] });
  }
  email(e4) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(e4) });
  }
  url(e4) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(e4) });
  }
  emoji(e4) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(e4) });
  }
  uuid(e4) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(e4) });
  }
  nanoid(e4) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(e4) });
  }
  cuid(e4) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(e4) });
  }
  cuid2(e4) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(e4) });
  }
  ulid(e4) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(e4) });
  }
  base64(e4) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(e4) });
  }
  ip(e4) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(e4) });
  }
  datetime(e4) {
    var t2, i2;
    return "string" == typeof e4 ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: e4 }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e4 ? void 0 : e4.precision) ? null : null == e4 ? void 0 : e4.precision, offset: null !== (t2 = null == e4 ? void 0 : e4.offset) && void 0 !== t2 && t2, local: null !== (i2 = null == e4 ? void 0 : e4.local) && void 0 !== i2 && i2, ...errorUtil.errToObj(null == e4 ? void 0 : e4.message) });
  }
  date(e4) {
    return this._addCheck({ kind: "date", message: e4 });
  }
  time(e4) {
    return "string" == typeof e4 ? this._addCheck({ kind: "time", precision: null, message: e4 }) : this._addCheck({ kind: "time", precision: void 0 === (null == e4 ? void 0 : e4.precision) ? null : null == e4 ? void 0 : e4.precision, ...errorUtil.errToObj(null == e4 ? void 0 : e4.message) });
  }
  duration(e4) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(e4) });
  }
  regex(e4, t2) {
    return this._addCheck({ kind: "regex", regex: e4, ...errorUtil.errToObj(t2) });
  }
  includes(e4, t2) {
    return this._addCheck({ kind: "includes", value: e4, position: null == t2 ? void 0 : t2.position, ...errorUtil.errToObj(null == t2 ? void 0 : t2.message) });
  }
  startsWith(e4, t2) {
    return this._addCheck({ kind: "startsWith", value: e4, ...errorUtil.errToObj(t2) });
  }
  endsWith(e4, t2) {
    return this._addCheck({ kind: "endsWith", value: e4, ...errorUtil.errToObj(t2) });
  }
  min(e4, t2) {
    return this._addCheck({ kind: "min", value: e4, ...errorUtil.errToObj(t2) });
  }
  max(e4, t2) {
    return this._addCheck({ kind: "max", value: e4, ...errorUtil.errToObj(t2) });
  }
  length(e4, t2) {
    return this._addCheck({ kind: "length", value: e4, ...errorUtil.errToObj(t2) });
  }
  nonempty(e4) {
    return this.min(1, errorUtil.errToObj(e4));
  }
  trim() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((e4) => "datetime" === e4.kind);
  }
  get isDate() {
    return !!this._def.checks.find((e4) => "date" === e4.kind);
  }
  get isTime() {
    return !!this._def.checks.find((e4) => "time" === e4.kind);
  }
  get isDuration() {
    return !!this._def.checks.find((e4) => "duration" === e4.kind);
  }
  get isEmail() {
    return !!this._def.checks.find((e4) => "email" === e4.kind);
  }
  get isURL() {
    return !!this._def.checks.find((e4) => "url" === e4.kind);
  }
  get isEmoji() {
    return !!this._def.checks.find((e4) => "emoji" === e4.kind);
  }
  get isUUID() {
    return !!this._def.checks.find((e4) => "uuid" === e4.kind);
  }
  get isNANOID() {
    return !!this._def.checks.find((e4) => "nanoid" === e4.kind);
  }
  get isCUID() {
    return !!this._def.checks.find((e4) => "cuid" === e4.kind);
  }
  get isCUID2() {
    return !!this._def.checks.find((e4) => "cuid2" === e4.kind);
  }
  get isULID() {
    return !!this._def.checks.find((e4) => "ulid" === e4.kind);
  }
  get isIP() {
    return !!this._def.checks.find((e4) => "ip" === e4.kind);
  }
  get isBase64() {
    return !!this._def.checks.find((e4) => "base64" === e4.kind);
  }
  get minLength() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "min" === t2.kind && (null === e4 || t2.value > e4) && (e4 = t2.value);
    return e4;
  }
  get maxLength() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "max" === t2.kind && (null === e4 || t2.value < e4) && (e4 = t2.value);
    return e4;
  }
};
function floatSafeRemainder(e4, t2) {
  const i2 = (e4.toString().split(".")[1] || "").length, r2 = (t2.toString().split(".")[1] || "").length, n2 = i2 > r2 ? i2 : r2;
  return parseInt(e4.toFixed(n2).replace(".", "")) % parseInt(t2.toFixed(n2).replace(".", "")) / Math.pow(10, n2);
}
ZodString.create = (e4) => {
  var t2;
  return new ZodString({ checks: [], typeName: ZodFirstPartyTypeKind.ZodString, coerce: null !== (t2 = null == e4 ? void 0 : e4.coerce) && void 0 !== t2 && t2, ...processCreateParams(e4) });
};
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e4) {
    this._def.coerce && (e4.data = Number(e4.data));
    if (this._getType(e4) !== ZodParsedType.number) {
      const t3 = this._getOrReturnCtx(e4);
      return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.number, received: t3.parsedType }), INVALID;
    }
    let t2;
    const i2 = new ParseStatus();
    for (const r2 of this._def.checks)
      if ("int" === r2.kind)
        util$1.isInteger(e4.data) || (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: "integer", received: "float", message: r2.message }), i2.dirty());
      else if ("min" === r2.kind) {
        (r2.inclusive ? e4.data < r2.value : e4.data <= r2.value) && (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.too_small, minimum: r2.value, type: "number", inclusive: r2.inclusive, exact: false, message: r2.message }), i2.dirty());
      } else if ("max" === r2.kind) {
        (r2.inclusive ? e4.data > r2.value : e4.data >= r2.value) && (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.too_big, maximum: r2.value, type: "number", inclusive: r2.inclusive, exact: false, message: r2.message }), i2.dirty());
      } else
        "multipleOf" === r2.kind ? 0 !== floatSafeRemainder(e4.data, r2.value) && (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.not_multiple_of, multipleOf: r2.value, message: r2.message }), i2.dirty()) : "finite" === r2.kind ? Number.isFinite(e4.data) || (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.not_finite, message: r2.message }), i2.dirty()) : util$1.assertNever(r2);
    return { status: i2.value, value: e4.data };
  }
  gte(e4, t2) {
    return this.setLimit("min", e4, true, errorUtil.toString(t2));
  }
  gt(e4, t2) {
    return this.setLimit("min", e4, false, errorUtil.toString(t2));
  }
  lte(e4, t2) {
    return this.setLimit("max", e4, true, errorUtil.toString(t2));
  }
  lt(e4, t2) {
    return this.setLimit("max", e4, false, errorUtil.toString(t2));
  }
  setLimit(e4, t2, i2, r2) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, { kind: e4, value: t2, inclusive: i2, message: errorUtil.toString(r2) }] });
  }
  _addCheck(e4) {
    return new ZodNumber({ ...this._def, checks: [...this._def.checks, e4] });
  }
  int(e4) {
    return this._addCheck({ kind: "int", message: errorUtil.toString(e4) });
  }
  positive(e4) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: errorUtil.toString(e4) });
  }
  negative(e4) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: errorUtil.toString(e4) });
  }
  nonpositive(e4) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: errorUtil.toString(e4) });
  }
  nonnegative(e4) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: errorUtil.toString(e4) });
  }
  multipleOf(e4, t2) {
    return this._addCheck({ kind: "multipleOf", value: e4, message: errorUtil.toString(t2) });
  }
  finite(e4) {
    return this._addCheck({ kind: "finite", message: errorUtil.toString(e4) });
  }
  safe(e4) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: errorUtil.toString(e4) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: errorUtil.toString(e4) });
  }
  get minValue() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "min" === t2.kind && (null === e4 || t2.value > e4) && (e4 = t2.value);
    return e4;
  }
  get maxValue() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "max" === t2.kind && (null === e4 || t2.value < e4) && (e4 = t2.value);
    return e4;
  }
  get isInt() {
    return !!this._def.checks.find((e4) => "int" === e4.kind || "multipleOf" === e4.kind && util$1.isInteger(e4.value));
  }
  get isFinite() {
    let e4 = null, t2 = null;
    for (const i2 of this._def.checks) {
      if ("finite" === i2.kind || "int" === i2.kind || "multipleOf" === i2.kind)
        return true;
      "min" === i2.kind ? (null === t2 || i2.value > t2) && (t2 = i2.value) : "max" === i2.kind && (null === e4 || i2.value < e4) && (e4 = i2.value);
    }
    return Number.isFinite(t2) && Number.isFinite(e4);
  }
};
ZodNumber.create = (e4) => new ZodNumber({ checks: [], typeName: ZodFirstPartyTypeKind.ZodNumber, coerce: (null == e4 ? void 0 : e4.coerce) || false, ...processCreateParams(e4) });
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e4) {
    this._def.coerce && (e4.data = BigInt(e4.data));
    if (this._getType(e4) !== ZodParsedType.bigint) {
      const t3 = this._getOrReturnCtx(e4);
      return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.bigint, received: t3.parsedType }), INVALID;
    }
    let t2;
    const i2 = new ParseStatus();
    for (const r2 of this._def.checks)
      if ("min" === r2.kind) {
        (r2.inclusive ? e4.data < r2.value : e4.data <= r2.value) && (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.too_small, type: "bigint", minimum: r2.value, inclusive: r2.inclusive, message: r2.message }), i2.dirty());
      } else if ("max" === r2.kind) {
        (r2.inclusive ? e4.data > r2.value : e4.data >= r2.value) && (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.too_big, type: "bigint", maximum: r2.value, inclusive: r2.inclusive, message: r2.message }), i2.dirty());
      } else
        "multipleOf" === r2.kind ? e4.data % r2.value !== BigInt(0) && (t2 = this._getOrReturnCtx(e4, t2), addIssueToContext(t2, { code: ZodIssueCode.not_multiple_of, multipleOf: r2.value, message: r2.message }), i2.dirty()) : util$1.assertNever(r2);
    return { status: i2.value, value: e4.data };
  }
  gte(e4, t2) {
    return this.setLimit("min", e4, true, errorUtil.toString(t2));
  }
  gt(e4, t2) {
    return this.setLimit("min", e4, false, errorUtil.toString(t2));
  }
  lte(e4, t2) {
    return this.setLimit("max", e4, true, errorUtil.toString(t2));
  }
  lt(e4, t2) {
    return this.setLimit("max", e4, false, errorUtil.toString(t2));
  }
  setLimit(e4, t2, i2, r2) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, { kind: e4, value: t2, inclusive: i2, message: errorUtil.toString(r2) }] });
  }
  _addCheck(e4) {
    return new ZodBigInt({ ...this._def, checks: [...this._def.checks, e4] });
  }
  positive(e4) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: errorUtil.toString(e4) });
  }
  negative(e4) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: errorUtil.toString(e4) });
  }
  nonpositive(e4) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: errorUtil.toString(e4) });
  }
  nonnegative(e4) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: errorUtil.toString(e4) });
  }
  multipleOf(e4, t2) {
    return this._addCheck({ kind: "multipleOf", value: e4, message: errorUtil.toString(t2) });
  }
  get minValue() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "min" === t2.kind && (null === e4 || t2.value > e4) && (e4 = t2.value);
    return e4;
  }
  get maxValue() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "max" === t2.kind && (null === e4 || t2.value < e4) && (e4 = t2.value);
    return e4;
  }
};
ZodBigInt.create = (e4) => {
  var t2;
  return new ZodBigInt({ checks: [], typeName: ZodFirstPartyTypeKind.ZodBigInt, coerce: null !== (t2 = null == e4 ? void 0 : e4.coerce) && void 0 !== t2 && t2, ...processCreateParams(e4) });
};
var ZodBoolean = class extends ZodType {
  _parse(e4) {
    this._def.coerce && (e4.data = Boolean(e4.data));
    if (this._getType(e4) !== ZodParsedType.boolean) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.boolean, received: t2.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
};
ZodBoolean.create = (e4) => new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean, coerce: (null == e4 ? void 0 : e4.coerce) || false, ...processCreateParams(e4) });
var ZodDate = class extends ZodType {
  _parse(e4) {
    this._def.coerce && (e4.data = new Date(e4.data));
    if (this._getType(e4) !== ZodParsedType.date) {
      const t3 = this._getOrReturnCtx(e4);
      return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.date, received: t3.parsedType }), INVALID;
    }
    if (isNaN(e4.data.getTime())) {
      return addIssueToContext(this._getOrReturnCtx(e4), { code: ZodIssueCode.invalid_date }), INVALID;
    }
    const t2 = new ParseStatus();
    let i2;
    for (const r2 of this._def.checks)
      "min" === r2.kind ? e4.data.getTime() < r2.value && (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.too_small, message: r2.message, inclusive: true, exact: false, minimum: r2.value, type: "date" }), t2.dirty()) : "max" === r2.kind ? e4.data.getTime() > r2.value && (i2 = this._getOrReturnCtx(e4, i2), addIssueToContext(i2, { code: ZodIssueCode.too_big, message: r2.message, inclusive: true, exact: false, maximum: r2.value, type: "date" }), t2.dirty()) : util$1.assertNever(r2);
    return { status: t2.value, value: new Date(e4.data.getTime()) };
  }
  _addCheck(e4) {
    return new ZodDate({ ...this._def, checks: [...this._def.checks, e4] });
  }
  min(e4, t2) {
    return this._addCheck({ kind: "min", value: e4.getTime(), message: errorUtil.toString(t2) });
  }
  max(e4, t2) {
    return this._addCheck({ kind: "max", value: e4.getTime(), message: errorUtil.toString(t2) });
  }
  get minDate() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "min" === t2.kind && (null === e4 || t2.value > e4) && (e4 = t2.value);
    return null != e4 ? new Date(e4) : null;
  }
  get maxDate() {
    let e4 = null;
    for (const t2 of this._def.checks)
      "max" === t2.kind && (null === e4 || t2.value < e4) && (e4 = t2.value);
    return null != e4 ? new Date(e4) : null;
  }
};
ZodDate.create = (e4) => new ZodDate({ checks: [], coerce: (null == e4 ? void 0 : e4.coerce) || false, typeName: ZodFirstPartyTypeKind.ZodDate, ...processCreateParams(e4) });
var ZodSymbol = class extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.symbol) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.symbol, received: t2.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
};
ZodSymbol.create = (e4) => new ZodSymbol({ typeName: ZodFirstPartyTypeKind.ZodSymbol, ...processCreateParams(e4) });
var ZodUndefined = class extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.undefined) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.undefined, received: t2.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
};
ZodUndefined.create = (e4) => new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined, ...processCreateParams(e4) });
var ZodNull = class extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.null) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.null, received: t2.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
};
ZodNull.create = (e4) => new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull, ...processCreateParams(e4) });
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e4) {
    return OK(e4.data);
  }
};
ZodAny.create = (e4) => new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny, ...processCreateParams(e4) });
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e4) {
    return OK(e4.data);
  }
};
ZodUnknown.create = (e4) => new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown, ...processCreateParams(e4) });
var ZodNever = class extends ZodType {
  _parse(e4) {
    const t2 = this._getOrReturnCtx(e4);
    return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.never, received: t2.parsedType }), INVALID;
  }
};
ZodNever.create = (e4) => new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever, ...processCreateParams(e4) });
var ZodVoid = class extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.undefined) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.void, received: t2.parsedType }), INVALID;
    }
    return OK(e4.data);
  }
};
ZodVoid.create = (e4) => new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid, ...processCreateParams(e4) });
var ZodArray = class extends ZodType {
  _parse(e4) {
    const { ctx: t2, status: i2 } = this._processInputParams(e4), r2 = this._def;
    if (t2.parsedType !== ZodParsedType.array)
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: t2.parsedType }), INVALID;
    if (null !== r2.exactLength) {
      const e5 = t2.data.length > r2.exactLength.value, n3 = t2.data.length < r2.exactLength.value;
      (e5 || n3) && (addIssueToContext(t2, { code: e5 ? ZodIssueCode.too_big : ZodIssueCode.too_small, minimum: n3 ? r2.exactLength.value : void 0, maximum: e5 ? r2.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: r2.exactLength.message }), i2.dirty());
    }
    if (null !== r2.minLength && t2.data.length < r2.minLength.value && (addIssueToContext(t2, { code: ZodIssueCode.too_small, minimum: r2.minLength.value, type: "array", inclusive: true, exact: false, message: r2.minLength.message }), i2.dirty()), null !== r2.maxLength && t2.data.length > r2.maxLength.value && (addIssueToContext(t2, { code: ZodIssueCode.too_big, maximum: r2.maxLength.value, type: "array", inclusive: true, exact: false, message: r2.maxLength.message }), i2.dirty()), t2.common.async)
      return Promise.all([...t2.data].map((e5, i3) => r2.type._parseAsync(new ParseInputLazyPath(t2, e5, t2.path, i3)))).then((e5) => ParseStatus.mergeArray(i2, e5));
    const n2 = [...t2.data].map((e5, i3) => r2.type._parseSync(new ParseInputLazyPath(t2, e5, t2.path, i3)));
    return ParseStatus.mergeArray(i2, n2);
  }
  get element() {
    return this._def.type;
  }
  min(e4, t2) {
    return new ZodArray({ ...this._def, minLength: { value: e4, message: errorUtil.toString(t2) } });
  }
  max(e4, t2) {
    return new ZodArray({ ...this._def, maxLength: { value: e4, message: errorUtil.toString(t2) } });
  }
  length(e4, t2) {
    return new ZodArray({ ...this._def, exactLength: { value: e4, message: errorUtil.toString(t2) } });
  }
  nonempty(e4) {
    return this.min(1, e4);
  }
};
function deepPartialify(e4) {
  if (e4 instanceof ZodObject) {
    const t2 = {};
    for (const i2 in e4.shape) {
      const r2 = e4.shape[i2];
      t2[i2] = ZodOptional.create(deepPartialify(r2));
    }
    return new ZodObject({ ...e4._def, shape: () => t2 });
  }
  return e4 instanceof ZodArray ? new ZodArray({ ...e4._def, type: deepPartialify(e4.element) }) : e4 instanceof ZodOptional ? ZodOptional.create(deepPartialify(e4.unwrap())) : e4 instanceof ZodNullable ? ZodNullable.create(deepPartialify(e4.unwrap())) : e4 instanceof ZodTuple ? ZodTuple.create(e4.items.map((e5) => deepPartialify(e5))) : e4;
}
ZodArray.create = (e4, t2) => new ZodArray({ type: e4, minLength: null, maxLength: null, exactLength: null, typeName: ZodFirstPartyTypeKind.ZodArray, ...processCreateParams(t2) });
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (null !== this._cached)
      return this._cached;
    const e4 = this._def.shape(), t2 = util$1.objectKeys(e4);
    return this._cached = { shape: e4, keys: t2 };
  }
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.object) {
      const t3 = this._getOrReturnCtx(e4);
      return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: t3.parsedType }), INVALID;
    }
    const { status: t2, ctx: i2 } = this._processInputParams(e4), { shape: r2, keys: n2 } = this._getCached(), a2 = [];
    if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys))
      for (const e5 in i2.data)
        n2.includes(e5) || a2.push(e5);
    const o2 = [];
    for (const e5 of n2) {
      const t3 = r2[e5], n3 = i2.data[e5];
      o2.push({ key: { status: "valid", value: e5 }, value: t3._parse(new ParseInputLazyPath(i2, n3, i2.path, e5)), alwaysSet: e5 in i2.data });
    }
    if (this._def.catchall instanceof ZodNever) {
      const e5 = this._def.unknownKeys;
      if ("passthrough" === e5)
        for (const e6 of a2)
          o2.push({ key: { status: "valid", value: e6 }, value: { status: "valid", value: i2.data[e6] } });
      else if ("strict" === e5)
        a2.length > 0 && (addIssueToContext(i2, { code: ZodIssueCode.unrecognized_keys, keys: a2 }), t2.dirty());
      else if ("strip" !== e5)
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const e5 = this._def.catchall;
      for (const t3 of a2) {
        const r3 = i2.data[t3];
        o2.push({ key: { status: "valid", value: t3 }, value: e5._parse(new ParseInputLazyPath(i2, r3, i2.path, t3)), alwaysSet: t3 in i2.data });
      }
    }
    return i2.common.async ? Promise.resolve().then(async () => {
      const e5 = [];
      for (const t3 of o2) {
        const i3 = await t3.key, r3 = await t3.value;
        e5.push({ key: i3, value: r3, alwaysSet: t3.alwaysSet });
      }
      return e5;
    }).then((e5) => ParseStatus.mergeObjectSync(t2, e5)) : ParseStatus.mergeObjectSync(t2, o2);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e4) {
    return errorUtil.errToObj, new ZodObject({ ...this._def, unknownKeys: "strict", ...void 0 !== e4 ? { errorMap: (t2, i2) => {
      var r2, n2, a2, o2;
      const s2 = null !== (a2 = null === (n2 = (r2 = this._def).errorMap) || void 0 === n2 ? void 0 : n2.call(r2, t2, i2).message) && void 0 !== a2 ? a2 : i2.defaultError;
      return "unrecognized_keys" === t2.code ? { message: null !== (o2 = errorUtil.errToObj(e4).message) && void 0 !== o2 ? o2 : s2 } : { message: s2 };
    } } : {} });
  }
  strip() {
    return new ZodObject({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new ZodObject({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(e4) {
    return new ZodObject({ ...this._def, shape: () => ({ ...this._def.shape(), ...e4 }) });
  }
  merge(e4) {
    return new ZodObject({ unknownKeys: e4._def.unknownKeys, catchall: e4._def.catchall, shape: () => ({ ...this._def.shape(), ...e4._def.shape() }), typeName: ZodFirstPartyTypeKind.ZodObject });
  }
  setKey(e4, t2) {
    return this.augment({ [e4]: t2 });
  }
  catchall(e4) {
    return new ZodObject({ ...this._def, catchall: e4 });
  }
  pick(e4) {
    const t2 = {};
    return util$1.objectKeys(e4).forEach((i2) => {
      e4[i2] && this.shape[i2] && (t2[i2] = this.shape[i2]);
    }), new ZodObject({ ...this._def, shape: () => t2 });
  }
  omit(e4) {
    const t2 = {};
    return util$1.objectKeys(this.shape).forEach((i2) => {
      e4[i2] || (t2[i2] = this.shape[i2]);
    }), new ZodObject({ ...this._def, shape: () => t2 });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(e4) {
    const t2 = {};
    return util$1.objectKeys(this.shape).forEach((i2) => {
      const r2 = this.shape[i2];
      e4 && !e4[i2] ? t2[i2] = r2 : t2[i2] = r2.optional();
    }), new ZodObject({ ...this._def, shape: () => t2 });
  }
  required(e4) {
    const t2 = {};
    return util$1.objectKeys(this.shape).forEach((i2) => {
      if (e4 && !e4[i2])
        t2[i2] = this.shape[i2];
      else {
        let e5 = this.shape[i2];
        for (; e5 instanceof ZodOptional; )
          e5 = e5._def.innerType;
        t2[i2] = e5;
      }
    }), new ZodObject({ ...this._def, shape: () => t2 });
  }
  keyof() {
    return createZodEnum(util$1.objectKeys(this.shape));
  }
};
ZodObject.create = (e4, t2) => new ZodObject({ shape: () => e4, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t2) }), ZodObject.strictCreate = (e4, t2) => new ZodObject({ shape: () => e4, unknownKeys: "strict", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t2) }), ZodObject.lazycreate = (e4, t2) => new ZodObject({ shape: e4, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t2) });
var ZodUnion = class extends ZodType {
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4), i2 = this._def.options;
    if (t2.common.async)
      return Promise.all(i2.map(async (e5) => {
        const i3 = { ...t2, common: { ...t2.common, issues: [] }, parent: null };
        return { result: await e5._parseAsync({ data: t2.data, path: t2.path, parent: i3 }), ctx: i3 };
      })).then(function(e5) {
        for (const t3 of e5)
          if ("valid" === t3.result.status)
            return t3.result;
        for (const i4 of e5)
          if ("dirty" === i4.result.status)
            return t2.common.issues.push(...i4.ctx.common.issues), i4.result;
        const i3 = e5.map((e6) => new ZodError(e6.ctx.common.issues));
        return addIssueToContext(t2, { code: ZodIssueCode.invalid_union, unionErrors: i3 }), INVALID;
      });
    {
      let e5;
      const r2 = [];
      for (const n3 of i2) {
        const i3 = { ...t2, common: { ...t2.common, issues: [] }, parent: null }, a2 = n3._parseSync({ data: t2.data, path: t2.path, parent: i3 });
        if ("valid" === a2.status)
          return a2;
        "dirty" !== a2.status || e5 || (e5 = { result: a2, ctx: i3 }), i3.common.issues.length && r2.push(i3.common.issues);
      }
      if (e5)
        return t2.common.issues.push(...e5.ctx.common.issues), e5.result;
      const n2 = r2.map((e6) => new ZodError(e6));
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_union, unionErrors: n2 }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (e4, t2) => new ZodUnion({ options: e4, typeName: ZodFirstPartyTypeKind.ZodUnion, ...processCreateParams(t2) });
var getDiscriminator = (e4) => e4 instanceof ZodLazy ? getDiscriminator(e4.schema) : e4 instanceof ZodEffects ? getDiscriminator(e4.innerType()) : e4 instanceof ZodLiteral ? [e4.value] : e4 instanceof ZodEnum ? e4.options : e4 instanceof ZodNativeEnum ? util$1.objectValues(e4.enum) : e4 instanceof ZodDefault ? getDiscriminator(e4._def.innerType) : e4 instanceof ZodUndefined ? [void 0] : e4 instanceof ZodNull ? [null] : e4 instanceof ZodOptional ? [void 0, ...getDiscriminator(e4.unwrap())] : e4 instanceof ZodNullable ? [null, ...getDiscriminator(e4.unwrap())] : e4 instanceof ZodBranded || e4 instanceof ZodReadonly ? getDiscriminator(e4.unwrap()) : e4 instanceof ZodCatch ? getDiscriminator(e4._def.innerType) : [];
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4);
    if (t2.parsedType !== ZodParsedType.object)
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: t2.parsedType }), INVALID;
    const i2 = this.discriminator, r2 = t2.data[i2], n2 = this.optionsMap.get(r2);
    return n2 ? t2.common.async ? n2._parseAsync({ data: t2.data, path: t2.path, parent: t2 }) : n2._parseSync({ data: t2.data, path: t2.path, parent: t2 }) : (addIssueToContext(t2, { code: ZodIssueCode.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [i2] }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e4, t2, i2) {
    const r2 = /* @__PURE__ */ new Map();
    for (const i3 of t2) {
      const t3 = getDiscriminator(i3.shape[e4]);
      if (!t3.length)
        throw new Error(`A discriminator value for key \`${e4}\` could not be extracted from all schema options`);
      for (const n2 of t3) {
        if (r2.has(n2))
          throw new Error(`Discriminator property ${String(e4)} has duplicate value ${String(n2)}`);
        r2.set(n2, i3);
      }
    }
    return new ZodDiscriminatedUnion({ typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion, discriminator: e4, options: t2, optionsMap: r2, ...processCreateParams(i2) });
  }
};
function mergeValues(e4, t2) {
  const i2 = getParsedType(e4), r2 = getParsedType(t2);
  if (e4 === t2)
    return { valid: true, data: e4 };
  if (i2 === ZodParsedType.object && r2 === ZodParsedType.object) {
    const i3 = util$1.objectKeys(t2), r3 = util$1.objectKeys(e4).filter((e5) => -1 !== i3.indexOf(e5)), n2 = { ...e4, ...t2 };
    for (const i4 of r3) {
      const r4 = mergeValues(e4[i4], t2[i4]);
      if (!r4.valid)
        return { valid: false };
      n2[i4] = r4.data;
    }
    return { valid: true, data: n2 };
  }
  if (i2 === ZodParsedType.array && r2 === ZodParsedType.array) {
    if (e4.length !== t2.length)
      return { valid: false };
    const i3 = [];
    for (let r3 = 0; r3 < e4.length; r3++) {
      const n2 = mergeValues(e4[r3], t2[r3]);
      if (!n2.valid)
        return { valid: false };
      i3.push(n2.data);
    }
    return { valid: true, data: i3 };
  }
  return i2 === ZodParsedType.date && r2 === ZodParsedType.date && +e4 == +t2 ? { valid: true, data: e4 } : { valid: false };
}
var ZodIntersection = class extends ZodType {
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4), r2 = (e5, r3) => {
      if (isAborted(e5) || isAborted(r3))
        return INVALID;
      const n2 = mergeValues(e5.value, r3.value);
      return n2.valid ? ((isDirty(e5) || isDirty(r3)) && t2.dirty(), { status: t2.value, value: n2.data }) : (addIssueToContext(i2, { code: ZodIssueCode.invalid_intersection_types }), INVALID);
    };
    return i2.common.async ? Promise.all([this._def.left._parseAsync({ data: i2.data, path: i2.path, parent: i2 }), this._def.right._parseAsync({ data: i2.data, path: i2.path, parent: i2 })]).then(([e5, t3]) => r2(e5, t3)) : r2(this._def.left._parseSync({ data: i2.data, path: i2.path, parent: i2 }), this._def.right._parseSync({ data: i2.data, path: i2.path, parent: i2 }));
  }
};
ZodIntersection.create = (e4, t2, i2) => new ZodIntersection({ left: e4, right: t2, typeName: ZodFirstPartyTypeKind.ZodIntersection, ...processCreateParams(i2) });
var ZodTuple = class extends ZodType {
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4);
    if (i2.parsedType !== ZodParsedType.array)
      return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: i2.parsedType }), INVALID;
    if (i2.data.length < this._def.items.length)
      return addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), INVALID;
    !this._def.rest && i2.data.length > this._def.items.length && (addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t2.dirty());
    const r2 = [...i2.data].map((e5, t3) => {
      const r3 = this._def.items[t3] || this._def.rest;
      return r3 ? r3._parse(new ParseInputLazyPath(i2, e5, i2.path, t3)) : null;
    }).filter((e5) => !!e5);
    return i2.common.async ? Promise.all(r2).then((e5) => ParseStatus.mergeArray(t2, e5)) : ParseStatus.mergeArray(t2, r2);
  }
  get items() {
    return this._def.items;
  }
  rest(e4) {
    return new ZodTuple({ ...this._def, rest: e4 });
  }
};
ZodTuple.create = (e4, t2) => {
  if (!Array.isArray(e4))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({ items: e4, typeName: ZodFirstPartyTypeKind.ZodTuple, rest: null, ...processCreateParams(t2) });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4);
    if (i2.parsedType !== ZodParsedType.object)
      return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: i2.parsedType }), INVALID;
    const r2 = [], n2 = this._def.keyType, a2 = this._def.valueType;
    for (const e5 in i2.data)
      r2.push({ key: n2._parse(new ParseInputLazyPath(i2, e5, i2.path, e5)), value: a2._parse(new ParseInputLazyPath(i2, i2.data[e5], i2.path, e5)), alwaysSet: e5 in i2.data });
    return i2.common.async ? ParseStatus.mergeObjectAsync(t2, r2) : ParseStatus.mergeObjectSync(t2, r2);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e4, t2, i2) {
    return new ZodRecord(t2 instanceof ZodType ? { keyType: e4, valueType: t2, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(i2) } : { keyType: ZodString.create(), valueType: e4, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(t2) });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4);
    if (i2.parsedType !== ZodParsedType.map)
      return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.map, received: i2.parsedType }), INVALID;
    const r2 = this._def.keyType, n2 = this._def.valueType, a2 = [...i2.data.entries()].map(([e5, t3], a3) => ({ key: r2._parse(new ParseInputLazyPath(i2, e5, i2.path, [a3, "key"])), value: n2._parse(new ParseInputLazyPath(i2, t3, i2.path, [a3, "value"])) }));
    if (i2.common.async) {
      const e5 = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const i3 of a2) {
          const r3 = await i3.key, n3 = await i3.value;
          if ("aborted" === r3.status || "aborted" === n3.status)
            return INVALID;
          "dirty" !== r3.status && "dirty" !== n3.status || t2.dirty(), e5.set(r3.value, n3.value);
        }
        return { status: t2.value, value: e5 };
      });
    }
    {
      const e5 = /* @__PURE__ */ new Map();
      for (const i3 of a2) {
        const r3 = i3.key, n3 = i3.value;
        if ("aborted" === r3.status || "aborted" === n3.status)
          return INVALID;
        "dirty" !== r3.status && "dirty" !== n3.status || t2.dirty(), e5.set(r3.value, n3.value);
      }
      return { status: t2.value, value: e5 };
    }
  }
};
ZodMap.create = (e4, t2, i2) => new ZodMap({ valueType: t2, keyType: e4, typeName: ZodFirstPartyTypeKind.ZodMap, ...processCreateParams(i2) });
var ZodSet = class extends ZodType {
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4);
    if (i2.parsedType !== ZodParsedType.set)
      return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.set, received: i2.parsedType }), INVALID;
    const r2 = this._def;
    null !== r2.minSize && i2.data.size < r2.minSize.value && (addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: r2.minSize.value, type: "set", inclusive: true, exact: false, message: r2.minSize.message }), t2.dirty()), null !== r2.maxSize && i2.data.size > r2.maxSize.value && (addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: r2.maxSize.value, type: "set", inclusive: true, exact: false, message: r2.maxSize.message }), t2.dirty());
    const n2 = this._def.valueType;
    function a2(e5) {
      const i3 = /* @__PURE__ */ new Set();
      for (const r3 of e5) {
        if ("aborted" === r3.status)
          return INVALID;
        "dirty" === r3.status && t2.dirty(), i3.add(r3.value);
      }
      return { status: t2.value, value: i3 };
    }
    const o2 = [...i2.data.values()].map((e5, t3) => n2._parse(new ParseInputLazyPath(i2, e5, i2.path, t3)));
    return i2.common.async ? Promise.all(o2).then((e5) => a2(e5)) : a2(o2);
  }
  min(e4, t2) {
    return new ZodSet({ ...this._def, minSize: { value: e4, message: errorUtil.toString(t2) } });
  }
  max(e4, t2) {
    return new ZodSet({ ...this._def, maxSize: { value: e4, message: errorUtil.toString(t2) } });
  }
  size(e4, t2) {
    return this.min(e4, t2).max(e4, t2);
  }
  nonempty(e4) {
    return this.min(1, e4);
  }
};
ZodSet.create = (e4, t2) => new ZodSet({ valueType: e4, minSize: null, maxSize: null, typeName: ZodFirstPartyTypeKind.ZodSet, ...processCreateParams(t2) });
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4);
    if (t2.parsedType !== ZodParsedType.function)
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.function, received: t2.parsedType }), INVALID;
    function i2(e5, i3) {
      return makeIssue({ data: e5, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, getErrorMap(), errorMap].filter((e6) => !!e6), issueData: { code: ZodIssueCode.invalid_arguments, argumentsError: i3 } });
    }
    function r2(e5, i3) {
      return makeIssue({ data: e5, path: t2.path, errorMaps: [t2.common.contextualErrorMap, t2.schemaErrorMap, getErrorMap(), errorMap].filter((e6) => !!e6), issueData: { code: ZodIssueCode.invalid_return_type, returnTypeError: i3 } });
    }
    const n2 = { errorMap: t2.common.contextualErrorMap }, a2 = t2.data;
    if (this._def.returns instanceof ZodPromise) {
      const e5 = this;
      return OK(async function(...t3) {
        const o2 = new ZodError([]), s2 = await e5._def.args.parseAsync(t3, n2).catch((e6) => {
          throw o2.addIssue(i2(t3, e6)), o2;
        }), l2 = await Reflect.apply(a2, this, s2), u2 = await e5._def.returns._def.type.parseAsync(l2, n2).catch((e6) => {
          throw o2.addIssue(r2(l2, e6)), o2;
        });
        return u2;
      });
    }
    {
      const e5 = this;
      return OK(function(...t3) {
        const o2 = e5._def.args.safeParse(t3, n2);
        if (!o2.success)
          throw new ZodError([i2(t3, o2.error)]);
        const s2 = Reflect.apply(a2, this, o2.data), l2 = e5._def.returns.safeParse(s2, n2);
        if (!l2.success)
          throw new ZodError([r2(s2, l2.error)]);
        return l2.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e4) {
    return new ZodFunction({ ...this._def, args: ZodTuple.create(e4).rest(ZodUnknown.create()) });
  }
  returns(e4) {
    return new ZodFunction({ ...this._def, returns: e4 });
  }
  implement(e4) {
    return this.parse(e4);
  }
  strictImplement(e4) {
    return this.parse(e4);
  }
  static create(e4, t2, i2) {
    return new ZodFunction({ args: e4 || ZodTuple.create([]).rest(ZodUnknown.create()), returns: t2 || ZodUnknown.create(), typeName: ZodFirstPartyTypeKind.ZodFunction, ...processCreateParams(i2) });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4);
    return this._def.getter()._parse({ data: t2.data, path: t2.path, parent: t2 });
  }
};
ZodLazy.create = (e4, t2) => new ZodLazy({ getter: e4, typeName: ZodFirstPartyTypeKind.ZodLazy, ...processCreateParams(t2) });
var ZodLiteral = class extends ZodType {
  _parse(e4) {
    if (e4.data !== this._def.value) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { received: t2.data, code: ZodIssueCode.invalid_literal, expected: this._def.value }), INVALID;
    }
    return { status: "valid", value: e4.data };
  }
  get value() {
    return this._def.value;
  }
};
function createZodEnum(e4, t2) {
  return new ZodEnum({ values: e4, typeName: ZodFirstPartyTypeKind.ZodEnum, ...processCreateParams(t2) });
}
ZodLiteral.create = (e4, t2) => new ZodLiteral({ value: e4, typeName: ZodFirstPartyTypeKind.ZodLiteral, ...processCreateParams(t2) });
var ZodEnum = class extends ZodType {
  constructor() {
    super(...arguments), _ZodEnum_cache.set(this, void 0);
  }
  _parse(e4) {
    if ("string" != typeof e4.data) {
      const t2 = this._getOrReturnCtx(e4), i2 = this._def.values;
      return addIssueToContext(t2, { expected: util$1.joinValues(i2), received: t2.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
    }
    if (__classPrivateFieldGet(this, _ZodEnum_cache) || __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values)), !__classPrivateFieldGet(this, _ZodEnum_cache).has(e4.data)) {
      const t2 = this._getOrReturnCtx(e4), i2 = this._def.values;
      return addIssueToContext(t2, { received: t2.data, code: ZodIssueCode.invalid_enum_value, options: i2 }), INVALID;
    }
    return OK(e4.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e4 = {};
    for (const t2 of this._def.values)
      e4[t2] = t2;
    return e4;
  }
  get Values() {
    const e4 = {};
    for (const t2 of this._def.values)
      e4[t2] = t2;
    return e4;
  }
  get Enum() {
    const e4 = {};
    for (const t2 of this._def.values)
      e4[t2] = t2;
    return e4;
  }
  extract(e4, t2 = this._def) {
    return ZodEnum.create(e4, { ...this._def, ...t2 });
  }
  exclude(e4, t2 = this._def) {
    return ZodEnum.create(this.options.filter((t3) => !e4.includes(t3)), { ...this._def, ...t2 });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap(), ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments), _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(e4) {
    const t2 = util$1.getValidEnumValues(this._def.values), i2 = this._getOrReturnCtx(e4);
    if (i2.parsedType !== ZodParsedType.string && i2.parsedType !== ZodParsedType.number) {
      const e5 = util$1.objectValues(t2);
      return addIssueToContext(i2, { expected: util$1.joinValues(e5), received: i2.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
    }
    if (__classPrivateFieldGet(this, _ZodNativeEnum_cache) || __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util$1.getValidEnumValues(this._def.values))), !__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(e4.data)) {
      const e5 = util$1.objectValues(t2);
      return addIssueToContext(i2, { received: i2.data, code: ZodIssueCode.invalid_enum_value, options: e5 }), INVALID;
    }
    return OK(e4.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap(), ZodNativeEnum.create = (e4, t2) => new ZodNativeEnum({ values: e4, typeName: ZodFirstPartyTypeKind.ZodNativeEnum, ...processCreateParams(t2) });
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4);
    if (t2.parsedType !== ZodParsedType.promise && false === t2.common.async)
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.promise, received: t2.parsedType }), INVALID;
    const i2 = t2.parsedType === ZodParsedType.promise ? t2.data : Promise.resolve(t2.data);
    return OK(i2.then((e5) => this._def.type.parseAsync(e5, { path: t2.path, errorMap: t2.common.contextualErrorMap })));
  }
};
ZodPromise.create = (e4, t2) => new ZodPromise({ type: e4, typeName: ZodFirstPartyTypeKind.ZodPromise, ...processCreateParams(t2) });
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4), r2 = this._def.effect || null, n2 = { addIssue: (e5) => {
      addIssueToContext(i2, e5), e5.fatal ? t2.abort() : t2.dirty();
    }, get path() {
      return i2.path;
    } };
    if (n2.addIssue = n2.addIssue.bind(n2), "preprocess" === r2.type) {
      const e5 = r2.transform(i2.data, n2);
      if (i2.common.async)
        return Promise.resolve(e5).then(async (e6) => {
          if ("aborted" === t2.value)
            return INVALID;
          const r3 = await this._def.schema._parseAsync({ data: e6, path: i2.path, parent: i2 });
          return "aborted" === r3.status ? INVALID : "dirty" === r3.status || "dirty" === t2.value ? DIRTY(r3.value) : r3;
        });
      {
        if ("aborted" === t2.value)
          return INVALID;
        const r3 = this._def.schema._parseSync({ data: e5, path: i2.path, parent: i2 });
        return "aborted" === r3.status ? INVALID : "dirty" === r3.status || "dirty" === t2.value ? DIRTY(r3.value) : r3;
      }
    }
    if ("refinement" === r2.type) {
      const e5 = (e6) => {
        const t3 = r2.refinement(e6, n2);
        if (i2.common.async)
          return Promise.resolve(t3);
        if (t3 instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return e6;
      };
      if (false === i2.common.async) {
        const r3 = this._def.schema._parseSync({ data: i2.data, path: i2.path, parent: i2 });
        return "aborted" === r3.status ? INVALID : ("dirty" === r3.status && t2.dirty(), e5(r3.value), { status: t2.value, value: r3.value });
      }
      return this._def.schema._parseAsync({ data: i2.data, path: i2.path, parent: i2 }).then((i3) => "aborted" === i3.status ? INVALID : ("dirty" === i3.status && t2.dirty(), e5(i3.value).then(() => ({ status: t2.value, value: i3.value }))));
    }
    if ("transform" === r2.type) {
      if (false === i2.common.async) {
        const e5 = this._def.schema._parseSync({ data: i2.data, path: i2.path, parent: i2 });
        if (!isValid(e5))
          return e5;
        const a2 = r2.transform(e5.value, n2);
        if (a2 instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t2.value, value: a2 };
      }
      return this._def.schema._parseAsync({ data: i2.data, path: i2.path, parent: i2 }).then((e5) => isValid(e5) ? Promise.resolve(r2.transform(e5.value, n2)).then((e6) => ({ status: t2.value, value: e6 })) : e5);
    }
    util$1.assertNever(r2);
  }
};
ZodEffects.create = (e4, t2, i2) => new ZodEffects({ schema: e4, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: t2, ...processCreateParams(i2) }), ZodEffects.createWithPreprocess = (e4, t2, i2) => new ZodEffects({ schema: t2, effect: { type: "preprocess", transform: e4 }, typeName: ZodFirstPartyTypeKind.ZodEffects, ...processCreateParams(i2) });
var ZodOptional = class extends ZodType {
  _parse(e4) {
    return this._getType(e4) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(e4);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (e4, t2) => new ZodOptional({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodOptional, ...processCreateParams(t2) });
var ZodNullable = class extends ZodType {
  _parse(e4) {
    return this._getType(e4) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(e4);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (e4, t2) => new ZodNullable({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodNullable, ...processCreateParams(t2) });
var ZodDefault = class extends ZodType {
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4);
    let i2 = t2.data;
    return t2.parsedType === ZodParsedType.undefined && (i2 = this._def.defaultValue()), this._def.innerType._parse({ data: i2, path: t2.path, parent: t2 });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (e4, t2) => new ZodDefault({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodDefault, defaultValue: "function" == typeof t2.default ? t2.default : () => t2.default, ...processCreateParams(t2) });
var ZodCatch = class extends ZodType {
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4), i2 = { ...t2, common: { ...t2.common, issues: [] } }, r2 = this._def.innerType._parse({ data: i2.data, path: i2.path, parent: { ...i2 } });
    return isAsync(r2) ? r2.then((e5) => ({ status: "valid", value: "valid" === e5.status ? e5.value : this._def.catchValue({ get error() {
      return new ZodError(i2.common.issues);
    }, input: i2.data }) })) : { status: "valid", value: "valid" === r2.status ? r2.value : this._def.catchValue({ get error() {
      return new ZodError(i2.common.issues);
    }, input: i2.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (e4, t2) => new ZodCatch({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodCatch, catchValue: "function" == typeof t2.catch ? t2.catch : () => t2.catch, ...processCreateParams(t2) });
var ZodNaN = class extends ZodType {
  _parse(e4) {
    if (this._getType(e4) !== ZodParsedType.nan) {
      const t2 = this._getOrReturnCtx(e4);
      return addIssueToContext(t2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.nan, received: t2.parsedType }), INVALID;
    }
    return { status: "valid", value: e4.data };
  }
};
ZodNaN.create = (e4) => new ZodNaN({ typeName: ZodFirstPartyTypeKind.ZodNaN, ...processCreateParams(e4) });
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(e4) {
    const { ctx: t2 } = this._processInputParams(e4), i2 = t2.data;
    return this._def.type._parse({ data: i2, path: t2.path, parent: t2 });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(e4) {
    const { status: t2, ctx: i2 } = this._processInputParams(e4);
    if (i2.common.async) {
      return (async () => {
        const e5 = await this._def.in._parseAsync({ data: i2.data, path: i2.path, parent: i2 });
        return "aborted" === e5.status ? INVALID : "dirty" === e5.status ? (t2.dirty(), DIRTY(e5.value)) : this._def.out._parseAsync({ data: e5.value, path: i2.path, parent: i2 });
      })();
    }
    {
      const e5 = this._def.in._parseSync({ data: i2.data, path: i2.path, parent: i2 });
      return "aborted" === e5.status ? INVALID : "dirty" === e5.status ? (t2.dirty(), { status: "dirty", value: e5.value }) : this._def.out._parseSync({ data: e5.value, path: i2.path, parent: i2 });
    }
  }
  static create(e4, t2) {
    return new ZodPipeline({ in: e4, out: t2, typeName: ZodFirstPartyTypeKind.ZodPipeline });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(e4) {
    const t2 = this._def.innerType._parse(e4), i2 = (e5) => (isValid(e5) && (e5.value = Object.freeze(e5.value)), e5);
    return isAsync(t2) ? t2.then((e5) => i2(e5)) : i2(t2);
  }
  unwrap() {
    return this._def.innerType;
  }
};
function custom(e4, t2 = {}, i2) {
  return e4 ? ZodAny.create().superRefine((r2, n2) => {
    var a2, o2;
    if (!e4(r2)) {
      const e5 = "function" == typeof t2 ? t2(r2) : "string" == typeof t2 ? { message: t2 } : t2, s2 = null === (o2 = null !== (a2 = e5.fatal) && void 0 !== a2 ? a2 : i2) || void 0 === o2 || o2, l2 = "string" == typeof e5 ? { message: e5 } : e5;
      n2.addIssue({ code: "custom", ...l2, fatal: s2 });
    }
  }) : ZodAny.create();
}
ZodReadonly.create = (e4, t2) => new ZodReadonly({ innerType: e4, typeName: ZodFirstPartyTypeKind.ZodReadonly, ...processCreateParams(t2) });
var late = { object: ZodObject.lazycreate };
var ZodFirstPartyTypeKind;
!function(e4) {
  e4.ZodString = "ZodString", e4.ZodNumber = "ZodNumber", e4.ZodNaN = "ZodNaN", e4.ZodBigInt = "ZodBigInt", e4.ZodBoolean = "ZodBoolean", e4.ZodDate = "ZodDate", e4.ZodSymbol = "ZodSymbol", e4.ZodUndefined = "ZodUndefined", e4.ZodNull = "ZodNull", e4.ZodAny = "ZodAny", e4.ZodUnknown = "ZodUnknown", e4.ZodNever = "ZodNever", e4.ZodVoid = "ZodVoid", e4.ZodArray = "ZodArray", e4.ZodObject = "ZodObject", e4.ZodUnion = "ZodUnion", e4.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e4.ZodIntersection = "ZodIntersection", e4.ZodTuple = "ZodTuple", e4.ZodRecord = "ZodRecord", e4.ZodMap = "ZodMap", e4.ZodSet = "ZodSet", e4.ZodFunction = "ZodFunction", e4.ZodLazy = "ZodLazy", e4.ZodLiteral = "ZodLiteral", e4.ZodEnum = "ZodEnum", e4.ZodEffects = "ZodEffects", e4.ZodNativeEnum = "ZodNativeEnum", e4.ZodOptional = "ZodOptional", e4.ZodNullable = "ZodNullable", e4.ZodDefault = "ZodDefault", e4.ZodCatch = "ZodCatch", e4.ZodPromise = "ZodPromise", e4.ZodBranded = "ZodBranded", e4.ZodPipeline = "ZodPipeline", e4.ZodReadonly = "ZodReadonly";
}(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (e4, t2 = { message: `Input not instance of ${e4.name}` }) => custom((t3) => t3 instanceof e4, t2);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = { string: (e4) => ZodString.create({ ...e4, coerce: true }), number: (e4) => ZodNumber.create({ ...e4, coerce: true }), boolean: (e4) => ZodBoolean.create({ ...e4, coerce: true }), bigint: (e4) => ZodBigInt.create({ ...e4, coerce: true }), date: (e4) => ZodDate.create({ ...e4, coerce: true }) };
var NEVER = INVALID;
var z = Object.freeze({ __proto__: null, defaultErrorMap: errorMap, setErrorMap, getErrorMap, makeIssue, EMPTY_PATH, addIssueToContext, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, get util() {
  return util$1;
}, get objectUtil() {
  return objectUtil;
}, ZodParsedType, getParsedType, ZodType, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodTransformer: ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, Schema: ZodType, ZodSchema: ZodType, late, get ZodFirstPartyTypeKind() {
  return ZodFirstPartyTypeKind;
}, coerce, any: anyType, array: arrayType, bigint: bigIntType, boolean: booleanType, date: dateType, discriminatedUnion: discriminatedUnionType, effect: effectsType, enum: enumType, function: functionType, instanceof: instanceOfType, intersection: intersectionType, lazy: lazyType, literal: literalType, map: mapType, nan: nanType, nativeEnum: nativeEnumType, never: neverType, null: nullType, nullable: nullableType, number: numberType, object: objectType, oboolean, onumber, optional: optionalType, ostring, pipeline: pipelineType, preprocess: preprocessType, promise: promiseType, record: recordType, set: setType, strictObject: strictObjectType, string: stringType, symbol: symbolType, transformer: effectsType, tuple: tupleType, undefined: undefinedType, union: unionType, unknown: unknownType, void: voidType, NEVER, ZodIssueCode, quotelessJson, ZodError });
var Edge;
var Edge2;
Edge2 = Edge || (Edge = {}), Edge2[Edge2.EXTEND = 1] = "EXTEND", Edge2[Edge2.WRAP = 2] = "WRAP", Edge2[Edge2.CROP = 3] = "CROP";
var JimpClassSchema = z.object({ bitmap: z.object({ data: z.union([z.instanceof(Buffer2), z.instanceof(Uint8Array)]), width: z.number(), height: z.number() }) });
var BlitOptionsSchemaComplex = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional(), srcX: z.number().optional(), srcY: z.number().optional(), srcW: z.number().optional(), srcH: z.number().optional() });
var BlitOptionsSchema = z.union([JimpClassSchema, BlitOptionsSchemaComplex]);
var methods$h = { blit(e4, t2) {
  const i2 = BlitOptionsSchema.parse(t2);
  let { src: r2, x: n2 = 0, y: a2 = 0, srcX: o2 = 0, srcY: s2 = 0, srcW: l2 = r2.bitmap.width, srcH: u2 = r2.bitmap.height } = "bitmap" in i2 ? { src: i2 } : i2;
  if (!("bitmap" in r2))
    throw new Error("The source must be a Jimp image");
  if ("number" != typeof n2 || "number" != typeof a2)
    throw new Error("x and y must be numbers");
  n2 = Math.round(n2), a2 = Math.round(a2), o2 = Math.round(o2), s2 = Math.round(s2), l2 = Math.round(l2), u2 = Math.round(u2);
  const h2 = e4.bitmap.width, c2 = e4.bitmap.height;
  return scan(r2, o2, s2, l2, u2, function(t3, i3, l3) {
    const u3 = n2 + t3 - o2, f2 = a2 + i3 - s2;
    if (u3 >= 0 && f2 >= 0 && h2 - u3 > 0 && c2 - f2 > 0) {
      const t4 = e4.getPixelIndex(u3, f2), i4 = { r: r2.bitmap.data[l3] || 0, g: r2.bitmap.data[l3 + 1] || 0, b: r2.bitmap.data[l3 + 2] || 0, a: r2.bitmap.data[l3 + 3] || 0 }, n3 = { r: e4.bitmap.data[t4] || 0, g: e4.bitmap.data[t4 + 1] || 0, b: e4.bitmap.data[t4 + 2] || 0, a: e4.bitmap.data[t4 + 3] || 0 };
      e4.bitmap.data[t4] = (i4.a * (i4.r - n3.r) - n3.r + 255 >> 8) + n3.r, e4.bitmap.data[t4 + 1] = (i4.a * (i4.g - n3.g) - n3.g + 255 >> 8) + n3.g, e4.bitmap.data[t4 + 2] = (i4.a * (i4.b - n3.b) - n3.b + 255 >> 8) + n3.b, e4.bitmap.data[t4 + 3] = limit255(n3.a + i4.a);
    }
  }), e4;
} };
var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
var methods$g = { blur(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("r must be a number");
  if (t2 < 1)
    throw new Error("r must be greater than 0");
  let i2, r2, n2, a2, o2, s2, l2, u2, h2, c2, f2, d, p2;
  const m = e4.bitmap.width - 1, _2 = e4.bitmap.height - 1, g = t2 + 1, b2 = mulTable[t2], y2 = shgTable[t2], w = [], v2 = [], x2 = [], E2 = [], k2 = [], S2 = [];
  let A2 = 2;
  for (; A2-- > 0; ) {
    for (d = 0, p2 = 0, s2 = 0; s2 < e4.bitmap.height; s2++) {
      for (i2 = e4.bitmap.data[p2] * g, r2 = e4.bitmap.data[p2 + 1] * g, n2 = e4.bitmap.data[p2 + 2] * g, a2 = e4.bitmap.data[p2 + 3] * g, l2 = 1; l2 <= t2; l2++)
        u2 = p2 + ((l2 > m ? m : l2) << 2), i2 += e4.bitmap.data[u2++], r2 += e4.bitmap.data[u2++], n2 += e4.bitmap.data[u2++], a2 += e4.bitmap.data[u2];
      for (o2 = 0; o2 < e4.bitmap.width; o2++)
        w[d] = i2, v2[d] = r2, x2[d] = n2, E2[d] = a2, 0 === s2 && (k2[o2] = ((u2 = o2 + g) < m ? u2 : m) << 2, S2[o2] = (u2 = o2 - t2) > 0 ? u2 << 2 : 0), h2 = p2 + k2[o2], c2 = p2 + S2[o2], i2 += e4.bitmap.data[h2++] - e4.bitmap.data[c2++], r2 += e4.bitmap.data[h2++] - e4.bitmap.data[c2++], n2 += e4.bitmap.data[h2++] - e4.bitmap.data[c2++], a2 += e4.bitmap.data[h2] - e4.bitmap.data[c2++], d++;
      p2 += e4.bitmap.width << 2;
    }
    for (o2 = 0; o2 < e4.bitmap.width; o2++) {
      for (f2 = o2, i2 = w[f2] * g, r2 = v2[f2] * g, n2 = x2[f2] * g, a2 = E2[f2] * g, l2 = 1; l2 <= t2; l2++)
        f2 += l2 > _2 ? 0 : e4.bitmap.width, i2 += w[f2], r2 += v2[f2], n2 += x2[f2], a2 += E2[f2];
      for (d = o2 << 2, s2 = 0; s2 < e4.bitmap.height; s2++)
        e4.bitmap.data[d] = limit255(i2 * b2 >>> y2), e4.bitmap.data[d + 1] = limit255(r2 * b2 >>> y2), e4.bitmap.data[d + 2] = limit255(n2 * b2 >>> y2), e4.bitmap.data[d + 3] = limit255(a2 * b2 >>> y2), 0 === o2 && (k2[s2] = ((u2 = s2 + g) < _2 ? u2 : _2) * e4.bitmap.width, S2[s2] = (u2 = s2 - t2) > 0 ? u2 * e4.bitmap.width : 0), h2 = o2 + k2[s2], c2 = o2 + S2[s2], i2 += w[h2] - w[c2], r2 += v2[h2] - v2[c2], n2 += x2[h2] - x2[c2], a2 += E2[h2] - E2[c2], d += e4.bitmap.width << 2;
    }
  }
  return e4;
}, gaussian(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("r must be a number");
  if (t2 < 1)
    throw new Error("r must be greater than 0");
  const i2 = Math.ceil(2.57 * t2), r2 = 2 * i2 + 1, n2 = t2 * t2 * 2, a2 = n2 * Math.PI, o2 = [];
  for (let e5 = 0; e5 < r2; e5++) {
    const t3 = [];
    for (let o3 = 0; o3 < r2; o3++) {
      const r3 = (o3 - i2) ** 2 + (e5 - i2) ** 2;
      t3[o3] = Math.exp(-r3 / n2) / a2;
    }
    o2.push(t3);
  }
  for (let t3 = 0; t3 < e4.bitmap.height; t3++)
    for (let n3 = 0; n3 < e4.bitmap.width; n3++) {
      let a3 = 0, s2 = 0, l2 = 0, u2 = 0, h2 = 0;
      for (let c2 = 0; c2 < r2; c2++) {
        for (let f3 = 0; f3 < r2; f3++) {
          const r3 = Math.min(e4.bitmap.width - 1, Math.max(0, f3 + n3 - i2)), d = Math.min(e4.bitmap.height - 1, Math.max(0, c2 + t3 - i2)), p2 = o2[c2][f3], m = d * e4.bitmap.width + r3 << 2;
          a3 += e4.bitmap.data[m] * p2, s2 += e4.bitmap.data[m + 1] * p2, l2 += e4.bitmap.data[m + 2] * p2, u2 += e4.bitmap.data[m + 3] * p2, h2 += p2;
        }
        const f2 = t3 * e4.bitmap.width + n3 << 2;
        e4.bitmap.data[f2] = Math.round(a3 / h2), e4.bitmap.data[f2 + 1] = Math.round(s2 / h2), e4.bitmap.data[f2 + 2] = Math.round(l2 / h2), e4.bitmap.data[f2 + 3] = Math.round(u2 / h2);
      }
    }
  return e4;
} };
var CircleOptionsSchema = z.object({ x: z.number().optional(), y: z.number().optional(), radius: z.number().min(0).optional() });
var methods$f = { circle(e4, t2 = {}) {
  const i2 = CircleOptionsSchema.parse(t2), r2 = i2.radius || (e4.bitmap.width > e4.bitmap.height ? e4.bitmap.height : e4.bitmap.width) / 2, n2 = "number" == typeof i2.x ? i2.x : e4.bitmap.width / 2, a2 = "number" == typeof i2.y ? i2.y : e4.bitmap.height / 2;
  return e4.scan((t3, i3, o2) => {
    const s2 = Math.sqrt(Math.pow(t3 - n2, 2) + Math.pow(i3 - a2, 2));
    r2 - s2 <= 0 ? e4.bitmap.data[o2 + 3] = 0 : r2 - s2 < 1 && (e4.bitmap.data[o2 + 3] = 255 * (r2 - s2));
  }), e4;
} };
var ConvolutionMatrixSchema = z.array(z.number()).min(1).array();
var ConvolutionComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, edgeHandling: z.nativeEnum(Edge).optional() });
var ConvolutionOptionsSchema = z.union([ConvolutionMatrixSchema, ConvolutionComplexOptionsSchema]);
var ConvoluteComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() });
var ConvoluteOptionsSchema = z.union([ConvolutionMatrixSchema, ConvoluteComplexOptionsSchema]);
var PixelateSize = z.number().min(1).max(1 / 0);
var PixelateComplexOptionsSchema = z.object({ size: PixelateSize, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() });
var PixelateOptionsSchema = z.union([PixelateSize, PixelateComplexOptionsSchema]);
function applyKernel(e4, t2, i2, r2) {
  const n2 = [0, 0, 0, 0], a2 = (t2.length - 1) / 2;
  for (let o2 = 0; o2 < t2.length; o2 += 1)
    for (let s2 = 0; s2 < t2[o2].length; s2 += 1) {
      const l2 = e4.getPixelIndex(i2 + o2 - a2, r2 + s2 - a2);
      n2[0] += e4.bitmap.data[l2] * t2[o2][s2], n2[1] += e4.bitmap.data[l2 + 1] * t2[o2][s2], n2[2] += e4.bitmap.data[l2 + 2] * t2[o2][s2], n2[3] += e4.bitmap.data[l2 + 3] * t2[o2][s2];
    }
  return n2;
}
function mix(e4, t2, i2 = 50) {
  return { r: (t2.r - e4.r) * (i2 / 100) + e4.r, g: (t2.g - e4.g) * (i2 / 100) + e4.g, b: (t2.b - e4.b) * (i2 / 100) + e4.b };
}
var HueActionSchema = z.object({ apply: z.literal("hue"), params: z.tuple([z.number().min(-360).max(360)]) });
var SpinActionSchema = z.object({ apply: z.literal("spin"), params: z.tuple([z.number().min(-360).max(360)]) });
var LightenActionSchema = z.object({ apply: z.literal("lighten"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var RGBColorSchema = z.object({ r: z.number().min(0).max(255), g: z.number().min(0).max(255), b: z.number().min(0).max(255) });
var MixActionSchema = z.object({ apply: z.literal("mix"), params: z.union([z.tuple([RGBColorSchema]), z.tuple([RGBColorSchema, z.number().min(0).max(100)])]) });
var TintActionSchema = z.object({ apply: z.literal("tint"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var ShadeActionSchema = z.object({ apply: z.literal("shade"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var XorActionSchema = z.object({ apply: z.literal("xor"), params: z.tuple([RGBColorSchema]) });
var RedActionSchema = z.object({ apply: z.literal("red"), params: z.tuple([z.number().min(-255).max(255)]) });
var GreenActionSchema = z.object({ apply: z.literal("green"), params: z.tuple([z.number().min(-255).max(255)]) });
var BlueActionSchema = z.object({ apply: z.literal("blue"), params: z.tuple([z.number().min(-255).max(255)]) });
var BrightenActionSchema = z.object({ apply: z.literal("brighten"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var DarkenActionSchema = z.object({ apply: z.literal("darken"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var DesaturateActionSchema = z.object({ apply: z.literal("desaturate"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var SaturateActionSchema = z.object({ apply: z.literal("saturate"), params: z.tuple([z.number().min(0).max(100)]).optional() });
var GrayscaleActionSchema = z.object({ apply: z.literal("greyscale"), params: z.tuple([]).optional() });
var ColorActionNameSchema = z.union([HueActionSchema, SpinActionSchema, LightenActionSchema, MixActionSchema, TintActionSchema, ShadeActionSchema, XorActionSchema, RedActionSchema, GreenActionSchema, BlueActionSchema, BrightenActionSchema, DarkenActionSchema, DesaturateActionSchema, SaturateActionSchema, GrayscaleActionSchema]);
function histogram(e4) {
  const t2 = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
  return e4.scan((i2, r2, n2) => {
    t2.r[e4.bitmap.data[n2 + 0]]++, t2.g[e4.bitmap.data[n2 + 1]]++, t2.b[e4.bitmap.data[n2 + 2]]++;
  }), t2;
}
var normalizeValue = function(e4, t2, i2) {
  return 255 * (e4 - t2) / (i2 - t2);
};
var getBounds = function(e4) {
  return [e4.findIndex((e5) => e5 > 0), 255 - e4.slice().reverse().findIndex((e5) => e5 > 0)];
};
var methods$e = { normalize(e4) {
  const t2 = histogram(e4), i2 = { r: getBounds(t2.r), g: getBounds(t2.g), b: getBounds(t2.b) };
  return e4.scan((t3, r2, n2) => {
    const a2 = e4.bitmap.data[n2 + 0], o2 = e4.bitmap.data[n2 + 1], s2 = e4.bitmap.data[n2 + 2];
    e4.bitmap.data[n2 + 0] = normalizeValue(a2, i2.r[0], i2.r[1]), e4.bitmap.data[n2 + 1] = normalizeValue(o2, i2.g[0], i2.g[1]), e4.bitmap.data[n2 + 2] = normalizeValue(s2, i2.b[0], i2.b[1]);
  }), e4;
}, invert: (e4) => (e4.scan((t2, i2, r2) => {
  e4.bitmap.data[r2] = 255 - e4.bitmap.data[r2], e4.bitmap.data[r2 + 1] = 255 - e4.bitmap.data[r2 + 1], e4.bitmap.data[r2 + 2] = 255 - e4.bitmap.data[r2 + 2];
}), e4), brightness(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("val must be numbers");
  return e4.scan((i2, r2, n2) => {
    e4.bitmap.data[n2] = limit255(e4.bitmap.data[n2] * t2), e4.bitmap.data[n2 + 1] = limit255(e4.bitmap.data[n2 + 1] * t2), e4.bitmap.data[n2 + 2] = limit255(e4.bitmap.data[n2 + 2] * t2);
  }), e4;
}, contrast(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("val must be numbers");
  if (t2 < -1 || t2 > 1)
    throw new Error("val must be a number between -1 and +1");
  const i2 = (t2 + 1) / (1 - t2);
  function r2(e5) {
    return (e5 = Math.floor(i2 * (e5 - 127) + 127)) < 0 ? 0 : e5 > 255 ? 255 : e5;
  }
  return e4.scan((t3, i3, n2) => {
    e4.bitmap.data[n2] = r2(e4.bitmap.data[n2]), e4.bitmap.data[n2 + 1] = r2(e4.bitmap.data[n2 + 1]), e4.bitmap.data[n2 + 2] = r2(e4.bitmap.data[n2 + 2]);
  }), e4;
}, posterize(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("n must be numbers");
  return t2 < 2 && (t2 = 2), e4.scan((i2, r2, n2) => {
    const a2 = e4.bitmap.data[n2], o2 = e4.bitmap.data[n2 + 1], s2 = e4.bitmap.data[n2 + 2];
    e4.bitmap.data[n2] = Math.floor(a2 / 255 * (t2 - 1)) / (t2 - 1) * 255, e4.bitmap.data[n2 + 1] = Math.floor(o2 / 255 * (t2 - 1)) / (t2 - 1) * 255, e4.bitmap.data[n2 + 2] = Math.floor(s2 / 255 * (t2 - 1)) / (t2 - 1) * 255;
  }), e4;
}, greyscale: (e4) => (e4.scan((t2, i2, r2) => {
  const n2 = 0.2126 * e4.bitmap.data[r2] + 0.7152 * e4.bitmap.data[r2 + 1] + 0.0722 * e4.bitmap.data[r2 + 2];
  e4.bitmap.data[r2] = n2, e4.bitmap.data[r2 + 1] = n2, e4.bitmap.data[r2 + 2] = n2;
}), e4), opacity(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("f must be a number");
  if (t2 < 0 || t2 > 1)
    throw new Error("f must be a number from 0 to 1");
  return e4.scan((i2, r2, n2) => {
    const a2 = e4.bitmap.data[n2 + 3] * t2;
    e4.bitmap.data[n2 + 3] = a2;
  }), e4;
}, sepia: (e4) => (e4.scan((t2, i2, r2) => {
  let n2 = e4.bitmap.data[r2], a2 = e4.bitmap.data[r2 + 1], o2 = e4.bitmap.data[r2 + 2];
  n2 = 0.393 * n2 + 0.769 * a2 + 0.189 * o2, a2 = 0.349 * n2 + 0.686 * a2 + 0.168 * o2, o2 = 0.272 * n2 + 0.534 * a2 + 0.131 * o2, e4.bitmap.data[r2] = n2 < 255 ? n2 : 255, e4.bitmap.data[r2 + 1] = a2 < 255 ? a2 : 255, e4.bitmap.data[r2 + 2] = o2 < 255 ? o2 : 255;
}), e4), fade(e4, t2) {
  if ("number" != typeof t2)
    throw new Error("f must be a number");
  if (t2 < 0 || t2 > 1)
    throw new Error("f must be a number from 0 to 1");
  return this.opacity(e4, 1 - t2);
}, convolution(e4, t2) {
  const i2 = ConvolutionOptionsSchema.parse(t2), { kernel: r2, edgeHandling: n2 = Edge.EXTEND } = "kernel" in i2 ? i2 : { kernel: i2, edgeHandling: void 0 };
  if (!r2[0])
    throw new Error("kernel must be a matrix");
  const a2 = Buffer2.from(e4.bitmap.data), o2 = r2.length, s2 = r2[0].length, l2 = Math.floor(o2 / 2), u2 = Math.floor(s2 / 2), h2 = -l2, c2 = -u2;
  let f2, d, p2, m, _2, g, b2, y2, w, v2;
  return e4.scan((t3, i3, o3) => {
    m = 0, p2 = 0, d = 0;
    for (let a3 = h2; a3 <= l2; a3++)
      for (let o4 = c2; o4 <= u2; o4++)
        y2 = t3 + o4, w = i3 + a3, f2 = r2[a3 + l2][o4 + u2], v2 = e4.getPixelIndex(y2, w, n2), -1 === v2 ? (b2 = 0, g = 0, _2 = 0) : (_2 = e4.bitmap.data[v2 + 0], g = e4.bitmap.data[v2 + 1], b2 = e4.bitmap.data[v2 + 2]), d += f2 * _2, p2 += f2 * g, m += f2 * b2;
    d < 0 && (d = 0), p2 < 0 && (p2 = 0), m < 0 && (m = 0), d > 255 && (d = 255), p2 > 255 && (p2 = 255), m > 255 && (m = 255), a2[o3 + 0] = d, a2[o3 + 1] = p2, a2[o3 + 2] = m;
  }), e4.bitmap.data = a2, e4;
}, opaque: (e4) => (e4.scan((t2, i2, r2) => {
  e4.bitmap.data[r2 + 3] = 255;
}), e4), pixelate(e4, t2) {
  const i2 = PixelateOptionsSchema.parse(t2), { size: r2, x: n2 = 0, y: a2 = 0, w: o2 = e4.bitmap.width - n2, h: s2 = e4.bitmap.height - a2 } = "number" == typeof i2 ? { size: i2 } : i2, l2 = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 0.25, 2 / 16], [1 / 16, 2 / 16, 1 / 16]], u2 = clone(e4);
  return scan(u2, n2, a2, o2, s2, (t3, i3, n3) => {
    t3 = r2 * Math.floor(t3 / r2), i3 = r2 * Math.floor(i3 / r2);
    const a3 = applyKernel(u2, l2, t3, i3);
    e4.bitmap.data[n3] = a3[0], e4.bitmap.data[n3 + 1] = a3[1], e4.bitmap.data[n3 + 2] = a3[2], e4.bitmap.data[n3 + 3] = a3[3];
  }), e4;
}, convolute(e4, t2) {
  const i2 = ConvoluteOptionsSchema.parse(t2), { kernel: r2, x: n2 = 0, y: a2 = 0, w: o2 = e4.bitmap.width - n2, h: s2 = e4.bitmap.height - a2 } = "kernel" in i2 ? i2 : { kernel: i2 }, l2 = clone(e4);
  return scan(l2, n2, a2, o2, s2, (t3, i3, n3) => {
    const a3 = applyKernel(l2, r2, t3, i3);
    e4.bitmap.data[n3] = limit255(a3[0]), e4.bitmap.data[n3 + 1] = limit255(a3[1]), e4.bitmap.data[n3 + 2] = limit255(a3[2]), e4.bitmap.data[n3 + 3] = limit255(a3[3]);
  }), e4;
}, color(e4, t2) {
  if (!t2 || !Array.isArray(t2))
    throw new Error("actions must be an array");
  return t2.forEach((e5) => ColorActionNameSchema.parse(e5)), t2 = t2.map((e5) => ("xor" !== e5.apply && "mix" !== e5.apply || (e5.params[0] = tinycolor(e5.params[0]).toRgb()), e5)), e4.scan((i2, r2, n2) => {
    let a2 = { r: e4.bitmap.data[n2], g: e4.bitmap.data[n2 + 1], b: e4.bitmap.data[n2 + 2] };
    const o2 = (e5, t3) => limit255(a2[e5] + t3);
    t2.forEach((e5) => {
      var _a, _b;
      if ("mix" === e5.apply)
        a2 = mix(a2, e5.params[0], e5.params[1]);
      else if ("tint" === e5.apply)
        a2 = mix(a2, { r: 255, g: 255, b: 255 }, (_a = e5.params) == null ? void 0 : _a[0]);
      else if ("shade" === e5.apply)
        a2 = mix(a2, { r: 0, g: 0, b: 0 }, (_b = e5.params) == null ? void 0 : _b[0]);
      else if ("xor" === e5.apply)
        a2 = { r: a2.r ^ e5.params[0].r, g: a2.g ^ e5.params[0].g, b: a2.b ^ e5.params[0].b };
      else if ("red" === e5.apply)
        a2.r = o2("r", e5.params[0]);
      else if ("green" === e5.apply)
        a2.g = o2("g", e5.params[0]);
      else if ("blue" === e5.apply)
        a2.b = o2("b", e5.params[0]);
      else {
        "hue" === e5.apply && (e5.apply = "spin");
        const t3 = tinycolor(a2), i3 = t3[e5.apply].bind(t3);
        if (!i3)
          throw new Error("action " + e5.apply + " not supported");
        a2 = i3(...e5.params || []).toRgb();
      }
    }), e4.bitmap.data[n2] = a2.r, e4.bitmap.data[n2 + 1] = a2.g, e4.bitmap.data[n2 + 2] = a2.b;
  }), e4;
} };
var lib$1 = {};
var ieee754 = {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  read: function(e4, t2, i2, r2, n2) {
    var a2, o2, s2 = 8 * n2 - r2 - 1, l2 = (1 << s2) - 1, u2 = l2 >> 1, h2 = -7, c2 = i2 ? n2 - 1 : 0, f2 = i2 ? -1 : 1, d = e4[t2 + c2];
    for (c2 += f2, a2 = d & (1 << -h2) - 1, d >>= -h2, h2 += s2; h2 > 0; a2 = 256 * a2 + e4[t2 + c2], c2 += f2, h2 -= 8)
      ;
    for (o2 = a2 & (1 << -h2) - 1, a2 >>= -h2, h2 += r2; h2 > 0; o2 = 256 * o2 + e4[t2 + c2], c2 += f2, h2 -= 8)
      ;
    if (0 === a2)
      a2 = 1 - u2;
    else {
      if (a2 === l2)
        return o2 ? NaN : 1 / 0 * (d ? -1 : 1);
      o2 += Math.pow(2, r2), a2 -= u2;
    }
    return (d ? -1 : 1) * o2 * Math.pow(2, a2 - r2);
  },
  write: function(e4, t2, i2, r2, n2, a2) {
    var o2, s2, l2, u2 = 8 * a2 - n2 - 1, h2 = (1 << u2) - 1, c2 = h2 >> 1, f2 = 23 === n2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r2 ? 0 : a2 - 1, p2 = r2 ? 1 : -1, m = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
    for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = h2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), (t2 += o2 + c2 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - c2)) * l2 >= 2 && (o2++, l2 /= 2), o2 + c2 >= h2 ? (s2 = 0, o2 = h2) : o2 + c2 >= 1 ? (s2 = (t2 * l2 - 1) * Math.pow(2, n2), o2 += c2) : (s2 = t2 * Math.pow(2, c2 - 1) * Math.pow(2, n2), o2 = 0)); n2 >= 8; e4[i2 + d] = 255 & s2, d += p2, s2 /= 256, n2 -= 8)
      ;
    for (o2 = o2 << n2 | s2, u2 += n2; u2 > 0; e4[i2 + d] = 255 & o2, d += p2, o2 /= 256, u2 -= 8)
      ;
    e4[i2 + d - p2] |= 128 * m;
  }
};
!function(e4) {
  Object.defineProperty(e4, "__esModule", { value: true }), e4.AnsiStringType = e4.StringType = e4.BufferType = e4.Uint8ArrayType = e4.IgnoreType = e4.Float80_LE = e4.Float80_BE = e4.Float64_LE = e4.Float64_BE = e4.Float32_LE = e4.Float32_BE = e4.Float16_LE = e4.Float16_BE = e4.INT64_BE = e4.UINT64_BE = e4.INT64_LE = e4.UINT64_LE = e4.INT32_LE = e4.INT32_BE = e4.INT24_BE = e4.INT24_LE = e4.INT16_LE = e4.INT16_BE = e4.INT8 = e4.UINT32_BE = e4.UINT32_LE = e4.UINT24_BE = e4.UINT24_LE = e4.UINT16_BE = e4.UINT16_LE = e4.UINT8 = void 0;
  const t2 = ieee754;
  function i2(e5) {
    return new DataView(e5.buffer, e5.byteOffset);
  }
  e4.UINT8 = { len: 1, get: (e5, t3) => i2(e5).getUint8(t3), put: (e5, t3, r3) => (i2(e5).setUint8(t3, r3), t3 + 1) }, e4.UINT16_LE = { len: 2, get: (e5, t3) => i2(e5).getUint16(t3, true), put: (e5, t3, r3) => (i2(e5).setUint16(t3, r3, true), t3 + 2) }, e4.UINT16_BE = { len: 2, get: (e5, t3) => i2(e5).getUint16(t3), put: (e5, t3, r3) => (i2(e5).setUint16(t3, r3), t3 + 2) }, e4.UINT24_LE = { len: 3, get(e5, t3) {
    const r3 = i2(e5);
    return r3.getUint8(t3) + (r3.getUint16(t3 + 1, true) << 8);
  }, put(e5, t3, r3) {
    const n2 = i2(e5);
    return n2.setUint8(t3, 255 & r3), n2.setUint16(t3 + 1, r3 >> 8, true), t3 + 3;
  } }, e4.UINT24_BE = { len: 3, get(e5, t3) {
    const r3 = i2(e5);
    return (r3.getUint16(t3) << 8) + r3.getUint8(t3 + 2);
  }, put(e5, t3, r3) {
    const n2 = i2(e5);
    return n2.setUint16(t3, r3 >> 8), n2.setUint8(t3 + 2, 255 & r3), t3 + 3;
  } }, e4.UINT32_LE = { len: 4, get: (e5, t3) => i2(e5).getUint32(t3, true), put: (e5, t3, r3) => (i2(e5).setUint32(t3, r3, true), t3 + 4) }, e4.UINT32_BE = { len: 4, get: (e5, t3) => i2(e5).getUint32(t3), put: (e5, t3, r3) => (i2(e5).setUint32(t3, r3), t3 + 4) }, e4.INT8 = { len: 1, get: (e5, t3) => i2(e5).getInt8(t3), put: (e5, t3, r3) => (i2(e5).setInt8(t3, r3), t3 + 1) }, e4.INT16_BE = { len: 2, get: (e5, t3) => i2(e5).getInt16(t3), put: (e5, t3, r3) => (i2(e5).setInt16(t3, r3), t3 + 2) }, e4.INT16_LE = { len: 2, get: (e5, t3) => i2(e5).getInt16(t3, true), put: (e5, t3, r3) => (i2(e5).setInt16(t3, r3, true), t3 + 2) }, e4.INT24_LE = { len: 3, get(t3, i3) {
    const r3 = e4.UINT24_LE.get(t3, i3);
    return r3 > 8388607 ? r3 - 16777216 : r3;
  }, put(e5, t3, r3) {
    const n2 = i2(e5);
    return n2.setUint8(t3, 255 & r3), n2.setUint16(t3 + 1, r3 >> 8, true), t3 + 3;
  } }, e4.INT24_BE = { len: 3, get(t3, i3) {
    const r3 = e4.UINT24_BE.get(t3, i3);
    return r3 > 8388607 ? r3 - 16777216 : r3;
  }, put(e5, t3, r3) {
    const n2 = i2(e5);
    return n2.setUint16(t3, r3 >> 8), n2.setUint8(t3 + 2, 255 & r3), t3 + 3;
  } }, e4.INT32_BE = { len: 4, get: (e5, t3) => i2(e5).getInt32(t3), put: (e5, t3, r3) => (i2(e5).setInt32(t3, r3), t3 + 4) }, e4.INT32_LE = { len: 4, get: (e5, t3) => i2(e5).getInt32(t3, true), put: (e5, t3, r3) => (i2(e5).setInt32(t3, r3, true), t3 + 4) }, e4.UINT64_LE = { len: 8, get: (e5, t3) => i2(e5).getBigUint64(t3, true), put: (e5, t3, r3) => (i2(e5).setBigUint64(t3, r3, true), t3 + 8) }, e4.INT64_LE = { len: 8, get: (e5, t3) => i2(e5).getBigInt64(t3, true), put: (e5, t3, r3) => (i2(e5).setBigInt64(t3, r3, true), t3 + 8) }, e4.UINT64_BE = { len: 8, get: (e5, t3) => i2(e5).getBigUint64(t3), put: (e5, t3, r3) => (i2(e5).setBigUint64(t3, r3), t3 + 8) }, e4.INT64_BE = { len: 8, get: (e5, t3) => i2(e5).getBigInt64(t3), put: (e5, t3, r3) => (i2(e5).setBigInt64(t3, r3), t3 + 8) }, e4.Float16_BE = { len: 2, get(e5, i3) {
    return t2.read(e5, i3, false, 10, this.len);
  }, put(e5, i3, r3) {
    return t2.write(e5, r3, i3, false, 10, this.len), i3 + this.len;
  } }, e4.Float16_LE = { len: 2, get(e5, i3) {
    return t2.read(e5, i3, true, 10, this.len);
  }, put(e5, i3, r3) {
    return t2.write(e5, r3, i3, true, 10, this.len), i3 + this.len;
  } }, e4.Float32_BE = { len: 4, get: (e5, t3) => i2(e5).getFloat32(t3), put: (e5, t3, r3) => (i2(e5).setFloat32(t3, r3), t3 + 4) }, e4.Float32_LE = { len: 4, get: (e5, t3) => i2(e5).getFloat32(t3, true), put: (e5, t3, r3) => (i2(e5).setFloat32(t3, r3, true), t3 + 4) }, e4.Float64_BE = { len: 8, get: (e5, t3) => i2(e5).getFloat64(t3), put: (e5, t3, r3) => (i2(e5).setFloat64(t3, r3), t3 + 8) }, e4.Float64_LE = { len: 8, get: (e5, t3) => i2(e5).getFloat64(t3, true), put: (e5, t3, r3) => (i2(e5).setFloat64(t3, r3, true), t3 + 8) }, e4.Float80_BE = { len: 10, get(e5, i3) {
    return t2.read(e5, i3, false, 63, this.len);
  }, put(e5, i3, r3) {
    return t2.write(e5, r3, i3, false, 63, this.len), i3 + this.len;
  } }, e4.Float80_LE = { len: 10, get(e5, i3) {
    return t2.read(e5, i3, true, 63, this.len);
  }, put(e5, i3, r3) {
    return t2.write(e5, r3, i3, true, 63, this.len), i3 + this.len;
  } };
  e4.IgnoreType = class {
    constructor(e5) {
      this.len = e5;
    }
    get(e5, t3) {
    }
  };
  e4.Uint8ArrayType = class {
    constructor(e5) {
      this.len = e5;
    }
    get(e5, t3) {
      return e5.subarray(t3, t3 + this.len);
    }
  };
  e4.BufferType = class {
    constructor(e5) {
      this.len = e5;
    }
    get(e5, t3) {
      return Buffer2.from(e5.subarray(t3, t3 + this.len));
    }
  };
  e4.StringType = class {
    constructor(e5, t3) {
      this.len = e5, this.encoding = t3;
    }
    get(e5, t3) {
      return Buffer2.from(e5).toString(this.encoding, t3, t3 + this.len);
    }
  };
  class r2 {
    constructor(e5) {
      this.len = e5;
    }
    static decode(e5, t3, i3) {
      let n2 = "";
      for (let a2 = t3; a2 < i3; ++a2)
        n2 += r2.codePointToString(r2.singleByteDecoder(e5[a2]));
      return n2;
    }
    static inRange(e5, t3, i3) {
      return t3 <= e5 && e5 <= i3;
    }
    static codePointToString(e5) {
      return e5 <= 65535 ? String.fromCharCode(e5) : (e5 -= 65536, String.fromCharCode(55296 + (e5 >> 10), 56320 + (1023 & e5)));
    }
    static singleByteDecoder(e5) {
      if (r2.inRange(e5, 0, 127))
        return e5;
      const t3 = r2.windows1252[e5 - 128];
      if (null === t3)
        throw Error("invaliding encoding");
      return t3;
    }
    get(e5, t3 = 0) {
      return r2.decode(e5, t3, t3 + this.len);
    }
  }
  e4.AnsiStringType = r2, r2.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
}(lib$1);
var core$1 = {};
var ReadStreamTokenizer$1 = {};
var AbstractTokenizer$1 = {};
var lib = {};
var EndOfFileStream = {};
!function(e4) {
  Object.defineProperty(e4, "__esModule", { value: true }), e4.EndOfStreamError = e4.defaultMessages = void 0, e4.defaultMessages = "End-Of-Stream";
  class t2 extends Error {
    constructor() {
      super(e4.defaultMessages);
    }
  }
  e4.EndOfStreamError = t2;
}(EndOfFileStream);
var StreamReader = {};
var Deferred$1 = {};
Object.defineProperty(Deferred$1, "__esModule", { value: true }), Deferred$1.Deferred = void 0;
var Deferred = class {
  constructor() {
    this.resolve = () => null, this.reject = () => null, this.promise = new Promise((e4, t2) => {
      this.reject = t2, this.resolve = e4;
    });
  }
};
Deferred$1.Deferred = Deferred, function(e4) {
  Object.defineProperty(e4, "__esModule", { value: true }), e4.StreamReader = e4.EndOfStreamError = void 0;
  const t2 = EndOfFileStream, i2 = Deferred$1;
  var r2 = EndOfFileStream;
  Object.defineProperty(e4, "EndOfStreamError", { enumerable: true, get: function() {
    return r2.EndOfStreamError;
  } });
  e4.StreamReader = class {
    constructor(e5) {
      if (this.s = e5, this.deferred = null, this.endOfStream = false, this.peekQueue = [], !e5.read || !e5.once)
        throw new Error("Expected an instance of stream.Readable");
      this.s.once("end", () => this.reject(new t2.EndOfStreamError())), this.s.once("error", (e6) => this.reject(e6)), this.s.once("close", () => this.reject(new Error("Stream closed")));
    }
    async peek(e5, t3, i3) {
      const r3 = await this.read(e5, t3, i3);
      return this.peekQueue.push(e5.subarray(t3, t3 + r3)), r3;
    }
    async read(e5, i3, r3) {
      if (0 === r3)
        return 0;
      if (0 === this.peekQueue.length && this.endOfStream)
        throw new t2.EndOfStreamError();
      let n2 = r3, a2 = 0;
      for (; this.peekQueue.length > 0 && n2 > 0; ) {
        const t3 = this.peekQueue.pop();
        if (!t3)
          throw new Error("peekData should be defined");
        const r4 = Math.min(t3.length, n2);
        e5.set(t3.subarray(0, r4), i3 + a2), a2 += r4, n2 -= r4, r4 < t3.length && this.peekQueue.push(t3.subarray(r4));
      }
      for (; n2 > 0 && !this.endOfStream; ) {
        const t3 = Math.min(n2, 1048576), r4 = await this.readFromStream(e5, i3 + a2, t3);
        if (a2 += r4, r4 < t3)
          break;
        n2 -= r4;
      }
      return a2;
    }
    async readFromStream(e5, t3, r3) {
      const n2 = this.s.read(r3);
      if (n2)
        return e5.set(n2, t3), n2.length;
      {
        const n3 = { buffer: e5, offset: t3, length: r3, deferred: new i2.Deferred() };
        return this.deferred = n3.deferred, this.s.once("readable", () => {
          this.readDeferred(n3);
        }), n3.deferred.promise;
      }
    }
    readDeferred(e5) {
      const t3 = this.s.read(e5.length);
      t3 ? (e5.buffer.set(t3, e5.offset), e5.deferred.resolve(t3.length), this.deferred = null) : this.s.once("readable", () => {
        this.readDeferred(e5);
      });
    }
    reject(e5) {
      this.endOfStream = true, this.deferred && (this.deferred.reject(e5), this.deferred = null);
    }
  };
}(StreamReader), function(e4) {
  Object.defineProperty(e4, "__esModule", { value: true }), e4.StreamReader = e4.EndOfStreamError = void 0;
  var t2 = EndOfFileStream;
  Object.defineProperty(e4, "EndOfStreamError", { enumerable: true, get: function() {
    return t2.EndOfStreamError;
  } });
  var i2 = StreamReader;
  Object.defineProperty(e4, "StreamReader", { enumerable: true, get: function() {
    return i2.StreamReader;
  } });
}(lib), Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: true }), AbstractTokenizer$1.AbstractTokenizer = void 0;
var peek_readable_1$2 = lib;
var AbstractTokenizer = class {
  constructor(e4) {
    this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = e4 || {};
  }
  async readToken(e4, t2 = this.position) {
    const i2 = Buffer2.alloc(e4.len);
    if (await this.readBuffer(i2, { position: t2 }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return e4.get(i2, 0);
  }
  async peekToken(e4, t2 = this.position) {
    const i2 = Buffer2.alloc(e4.len);
    if (await this.peekBuffer(i2, { position: t2 }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return e4.get(i2, 0);
  }
  async readNumber(e4) {
    if (await this.readBuffer(this.numBuffer, { length: e4.len }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return e4.get(this.numBuffer, 0);
  }
  async peekNumber(e4) {
    if (await this.peekBuffer(this.numBuffer, { length: e4.len }) < e4.len)
      throw new peek_readable_1$2.EndOfStreamError();
    return e4.get(this.numBuffer, 0);
  }
  async ignore(e4) {
    if (void 0 !== this.fileInfo.size) {
      const t2 = this.fileInfo.size - this.position;
      if (e4 > t2)
        return this.position += t2, t2;
    }
    return this.position += e4, e4;
  }
  async close() {
  }
  normalizeOptions(e4, t2) {
    if (t2 && void 0 !== t2.position && t2.position < this.position)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    return t2 ? { mayBeLess: true === t2.mayBeLess, offset: t2.offset ? t2.offset : 0, length: t2.length ? t2.length : e4.length - (t2.offset ? t2.offset : 0), position: t2.position ? t2.position : this.position } : { mayBeLess: false, offset: 0, length: e4.length, position: this.position };
  }
};
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer, Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: true }), ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
var AbstractTokenizer_1$1 = AbstractTokenizer$1;
var peek_readable_1$1 = lib;
var maxBufferSize = 256e3;
var ReadStreamTokenizer = class extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(e4, t2) {
    super(t2), this.streamReader = new peek_readable_1$1.StreamReader(e4);
  }
  async getFileInfo() {
    return this.fileInfo;
  }
  async readBuffer(e4, t2) {
    const i2 = this.normalizeOptions(e4, t2), r2 = i2.position - this.position;
    if (r2 > 0)
      return await this.ignore(r2), this.readBuffer(e4, t2);
    if (r2 < 0)
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    if (0 === i2.length)
      return 0;
    const n2 = await this.streamReader.read(e4, i2.offset, i2.length);
    if (this.position += n2, (!t2 || !t2.mayBeLess) && n2 < i2.length)
      throw new peek_readable_1$1.EndOfStreamError();
    return n2;
  }
  async peekBuffer(e4, t2) {
    const i2 = this.normalizeOptions(e4, t2);
    let r2 = 0;
    if (i2.position) {
      const t3 = i2.position - this.position;
      if (t3 > 0) {
        const n2 = new Uint8Array(i2.length + t3);
        return r2 = await this.peekBuffer(n2, { mayBeLess: i2.mayBeLess }), e4.set(n2.subarray(t3), i2.offset), r2 - t3;
      }
      if (t3 < 0)
        throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (i2.length > 0) {
      try {
        r2 = await this.streamReader.peek(e4, i2.offset, i2.length);
      } catch (e5) {
        if (t2 && t2.mayBeLess && e5 instanceof peek_readable_1$1.EndOfStreamError)
          return 0;
        throw e5;
      }
      if (!i2.mayBeLess && r2 < i2.length)
        throw new peek_readable_1$1.EndOfStreamError();
    }
    return r2;
  }
  async ignore(e4) {
    const t2 = Math.min(maxBufferSize, e4), i2 = new Uint8Array(t2);
    let r2 = 0;
    for (; r2 < e4; ) {
      const n2 = e4 - r2, a2 = await this.readBuffer(i2, { length: Math.min(t2, n2) });
      if (a2 < 0)
        return a2;
      r2 += a2;
    }
    return r2;
  }
};
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
var BufferTokenizer$1 = {};
Object.defineProperty(BufferTokenizer$1, "__esModule", { value: true }), BufferTokenizer$1.BufferTokenizer = void 0;
var peek_readable_1 = lib;
var AbstractTokenizer_1 = AbstractTokenizer$1;
var BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
  constructor(e4, t2) {
    super(t2), this.uint8Array = e4, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : e4.length;
  }
  async readBuffer(e4, t2) {
    if (t2 && t2.position) {
      if (t2.position < this.position)
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      this.position = t2.position;
    }
    const i2 = await this.peekBuffer(e4, t2);
    return this.position += i2, i2;
  }
  async peekBuffer(e4, t2) {
    const i2 = this.normalizeOptions(e4, t2), r2 = Math.min(this.uint8Array.length - i2.position, i2.length);
    if (!i2.mayBeLess && r2 < i2.length)
      throw new peek_readable_1.EndOfStreamError();
    return e4.set(this.uint8Array.subarray(i2.position, i2.position + r2), i2.offset), r2;
  }
  async close() {
  }
};
BufferTokenizer$1.BufferTokenizer = BufferTokenizer, function(e4) {
  Object.defineProperty(e4, "__esModule", { value: true }), e4.fromBuffer = e4.fromStream = e4.EndOfStreamError = void 0;
  const t2 = ReadStreamTokenizer$1, i2 = BufferTokenizer$1;
  var r2 = lib;
  Object.defineProperty(e4, "EndOfStreamError", { enumerable: true, get: function() {
    return r2.EndOfStreamError;
  } }), e4.fromStream = function(e5, i3) {
    return i3 = i3 || {}, new t2.ReadStreamTokenizer(e5, i3);
  }, e4.fromBuffer = function(e5, t3) {
    return new i2.BufferTokenizer(e5, t3);
  };
}(core$1);
var util = { stringToBytes: (e4) => [...e4].map((e5) => e5.charCodeAt(0)), tarHeaderChecksumMatches: (e4, t2 = 0) => {
  const i2 = parseInt(e4.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (isNaN(i2))
    return false;
  let r2 = 256;
  for (let i3 = t2; i3 < t2 + 148; i3++)
    r2 += e4[i3];
  for (let i3 = t2 + 156; i3 < t2 + 512; i3++)
    r2 += e4[i3];
  return i2 === r2;
}, uint32SyncSafeToken: { get: (e4, t2) => 127 & e4[t2 + 3] | e4[t2 + 2] << 7 | e4[t2 + 1] << 14 | e4[t2] << 21, len: 4 } };
var supported$1 = { extensions: ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "ai", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf"], mimeTypes: ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-apache-arrow", "video/mp4", "audio/midi", "video/x-matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/vnd.wave", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "audio/opus", "video/ogg", "audio/ogg", "application/ogg", "audio/x-flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd"] };
var Token = lib$1;
var strtok3 = core$1;
var { stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = util;
var supported = supported$1;
var minimumBytes = 4100;
async function fromStream(e4) {
  const t2 = await strtok3.fromStream(e4);
  try {
    return await fromTokenizer(t2);
  } finally {
    await t2.close();
  }
}
async function fromBuffer(e4) {
  if (!(e4 instanceof Uint8Array || e4 instanceof ArrayBuffer || Buffer2.isBuffer(e4)))
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof e4}\``);
  const t2 = e4 instanceof Buffer2 ? e4 : Buffer2.from(e4);
  if (!(t2 && t2.length > 1))
    return;
  return fromTokenizer(strtok3.fromBuffer(t2));
}
function _check(e4, t2, i2) {
  i2 = { offset: 0, ...i2 };
  for (const [r2, n2] of t2.entries())
    if (i2.mask) {
      if (n2 !== (i2.mask[r2] & e4[r2 + i2.offset]))
        return false;
    } else if (n2 !== e4[r2 + i2.offset])
      return false;
  return true;
}
async function fromTokenizer(e4) {
  try {
    return _fromTokenizer(e4);
  } catch (e5) {
    if (!(e5 instanceof strtok3.EndOfStreamError))
      throw e5;
  }
}
async function _fromTokenizer(e4) {
  let t2 = Buffer2.alloc(minimumBytes);
  const i2 = (e5, i3) => _check(t2, e5, i3), r2 = (e5, t3) => i2(stringToBytes(e5), t3);
  if (e4.fileInfo.size || (e4.fileInfo.size = Number.MAX_SAFE_INTEGER), await e4.peekBuffer(t2, { length: 12, mayBeLess: true }), i2([66, 77]))
    return { ext: "bmp", mime: "image/bmp" };
  if (i2([11, 119]))
    return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
  if (i2([120, 1]))
    return { ext: "dmg", mime: "application/x-apple-diskimage" };
  if (i2([77, 90]))
    return { ext: "exe", mime: "application/x-msdownload" };
  if (i2([37, 33]))
    return await e4.peekBuffer(t2, { length: 24, mayBeLess: true }), r2("PS-Adobe-", { offset: 2 }) && r2(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
  if (i2([31, 160]) || i2([31, 157]))
    return { ext: "Z", mime: "application/x-compress" };
  if (i2([255, 216, 255]))
    return { ext: "jpg", mime: "image/jpeg" };
  if (i2([73, 73, 188]))
    return { ext: "jxr", mime: "image/vnd.ms-photo" };
  if (i2([31, 139, 8]))
    return { ext: "gz", mime: "application/gzip" };
  if (i2([66, 90, 104]))
    return { ext: "bz2", mime: "application/x-bzip2" };
  if (r2("ID3")) {
    await e4.ignore(6);
    const n2 = await e4.readToken(uint32SyncSafeToken);
    return e4.position + n2 > e4.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await e4.ignore(n2), fromTokenizer(e4));
  }
  if (r2("MP+"))
    return { ext: "mpc", mime: "audio/x-musepack" };
  if ((67 === t2[0] || 70 === t2[0]) && i2([87, 83], { offset: 1 }))
    return { ext: "swf", mime: "application/x-shockwave-flash" };
  if (i2([71, 73, 70]))
    return { ext: "gif", mime: "image/gif" };
  if (r2("FLIF"))
    return { ext: "flif", mime: "image/flif" };
  if (r2("8BPS"))
    return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
  if (r2("WEBP", { offset: 8 }))
    return { ext: "webp", mime: "image/webp" };
  if (r2("MPCK"))
    return { ext: "mpc", mime: "audio/x-musepack" };
  if (r2("FORM"))
    return { ext: "aif", mime: "audio/aiff" };
  if (r2("icns", { offset: 0 }))
    return { ext: "icns", mime: "image/icns" };
  if (i2([80, 75, 3, 4])) {
    try {
      for (; e4.position + 30 < e4.fileInfo.size; ) {
        await e4.readBuffer(t2, { length: 30 });
        const a2 = { compressedSize: t2.readUInt32LE(18), uncompressedSize: t2.readUInt32LE(22), filenameLength: t2.readUInt16LE(26), extraFieldLength: t2.readUInt16LE(28) };
        if (a2.filename = await e4.readToken(new Token.StringType(a2.filenameLength, "utf-8")), await e4.ignore(a2.extraFieldLength), "META-INF/mozilla.rsa" === a2.filename)
          return { ext: "xpi", mime: "application/x-xpinstall" };
        if (a2.filename.endsWith(".rels") || a2.filename.endsWith(".xml")) {
          switch (a2.filename.split("/")[0]) {
            case "_rels":
            default:
              break;
            case "word":
              return { ext: "docx", mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" };
            case "ppt":
              return { ext: "pptx", mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation" };
            case "xl":
              return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
          }
        }
        if (a2.filename.startsWith("xl/"))
          return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
        if (a2.filename.startsWith("3D/") && a2.filename.endsWith(".model"))
          return { ext: "3mf", mime: "model/3mf" };
        if ("mimetype" === a2.filename && a2.compressedSize === a2.uncompressedSize) {
          switch (await e4.readToken(new Token.StringType(a2.compressedSize, "utf-8"))) {
            case "application/epub+zip":
              return { ext: "epub", mime: "application/epub+zip" };
            case "application/vnd.oasis.opendocument.text":
              return { ext: "odt", mime: "application/vnd.oasis.opendocument.text" };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return { ext: "ods", mime: "application/vnd.oasis.opendocument.spreadsheet" };
            case "application/vnd.oasis.opendocument.presentation":
              return { ext: "odp", mime: "application/vnd.oasis.opendocument.presentation" };
          }
        }
        if (0 === a2.compressedSize) {
          let o2 = -1;
          for (; o2 < 0 && e4.position < e4.fileInfo.size; )
            await e4.peekBuffer(t2, { mayBeLess: true }), o2 = t2.indexOf("504B0304", 0, "hex"), await e4.ignore(o2 >= 0 ? o2 : t2.length);
        } else
          await e4.ignore(a2.compressedSize);
      }
    } catch (s2) {
      if (!(s2 instanceof strtok3.EndOfStreamError))
        throw s2;
    }
    return { ext: "zip", mime: "application/zip" };
  }
  if (r2("OggS")) {
    await e4.ignore(28);
    const l2 = Buffer2.alloc(8);
    return await e4.readBuffer(l2), _check(l2, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/opus" } : _check(l2, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : _check(l2, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : _check(l2, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : _check(l2, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : _check(l2, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
  }
  if (i2([80, 75]) && (3 === t2[2] || 5 === t2[2] || 7 === t2[2]) && (4 === t2[3] || 6 === t2[3] || 8 === t2[3]))
    return { ext: "zip", mime: "application/zip" };
  if (r2("ftyp", { offset: 4 }) && 96 & t2[8]) {
    const u2 = t2.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (u2) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        return u2.startsWith("3g") ? u2.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (r2("MThd"))
    return { ext: "mid", mime: "audio/midi" };
  if (r2("wOFF") && (i2([0, 1, 0, 0], { offset: 4 }) || r2("OTTO", { offset: 4 })))
    return { ext: "woff", mime: "font/woff" };
  if (r2("wOF2") && (i2([0, 1, 0, 0], { offset: 4 }) || r2("OTTO", { offset: 4 })))
    return { ext: "woff2", mime: "font/woff2" };
  if (i2([212, 195, 178, 161]) || i2([161, 178, 195, 212]))
    return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
  if (r2("DSD "))
    return { ext: "dsf", mime: "audio/x-dsf" };
  if (r2("LZIP"))
    return { ext: "lz", mime: "application/x-lzip" };
  if (r2("fLaC"))
    return { ext: "flac", mime: "audio/x-flac" };
  if (i2([66, 80, 71, 251]))
    return { ext: "bpg", mime: "image/bpg" };
  if (r2("wvpk"))
    return { ext: "wv", mime: "audio/wavpack" };
  if (r2("%PDF")) {
    await e4.ignore(1350);
    const h2 = 10485760, c2 = Buffer2.alloc(Math.min(h2, e4.fileInfo.size));
    return await e4.readBuffer(c2, { mayBeLess: true }), c2.includes(Buffer2.from("AIPrivateData")) ? { ext: "ai", mime: "application/postscript" } : { ext: "pdf", mime: "application/pdf" };
  }
  if (i2([0, 97, 115, 109]))
    return { ext: "wasm", mime: "application/wasm" };
  if (i2([73, 73, 42, 0]))
    return r2("CR", { offset: 8 }) ? { ext: "cr2", mime: "image/x-canon-cr2" } : i2([28, 0, 254, 0], { offset: 8 }) || i2([31, 0, 11, 0], { offset: 8 }) ? { ext: "nef", mime: "image/x-nikon-nef" } : i2([8, 0, 0, 0], { offset: 4 }) && (i2([45, 0, 254, 0], { offset: 8 }) || i2([39, 0, 254, 0], { offset: 8 })) ? { ext: "dng", mime: "image/x-adobe-dng" } : (t2 = Buffer2.alloc(24), await e4.peekBuffer(t2), (i2([16, 251, 134, 1], { offset: 4 }) || i2([8, 0, 0, 0], { offset: 4 })) && i2([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? { ext: "arw", mime: "image/x-sony-arw" } : { ext: "tif", mime: "image/tiff" });
  if (i2([77, 77, 0, 42]))
    return { ext: "tif", mime: "image/tiff" };
  if (r2("MAC "))
    return { ext: "ape", mime: "audio/ape" };
  if (i2([26, 69, 223, 163])) {
    async function f2() {
      const t3 = await e4.peekNumber(Token.UINT8);
      let i3 = 128, r3 = 0;
      for (; !(t3 & i3) && 0 !== i3; )
        ++r3, i3 >>= 1;
      const n2 = Buffer2.alloc(r3 + 1);
      return await e4.readBuffer(n2), n2;
    }
    async function d() {
      const e5 = await f2(), t3 = await f2();
      t3[0] ^= 128 >> t3.length - 1;
      const i3 = Math.min(6, t3.length);
      return { id: e5.readUIntBE(0, e5.length), len: t3.readUIntBE(t3.length - i3, i3) };
    }
    async function p2(t3, i3) {
      for (; i3 > 0; ) {
        const t4 = await d();
        if (17026 === t4.id)
          return e4.readToken(new Token.StringType(t4.len, "utf-8"));
        await e4.ignore(t4.len), --i3;
      }
    }
    const m = await d();
    switch (await p2(0, m.len)) {
      case "webm":
        return { ext: "webm", mime: "video/webm" };
      case "matroska":
        return { ext: "mkv", mime: "video/x-matroska" };
      default:
        return;
    }
  }
  if (i2([82, 73, 70, 70])) {
    if (i2([65, 86, 73], { offset: 8 }))
      return { ext: "avi", mime: "video/vnd.avi" };
    if (i2([87, 65, 86, 69], { offset: 8 }))
      return { ext: "wav", mime: "audio/vnd.wave" };
    if (i2([81, 76, 67, 77], { offset: 8 }))
      return { ext: "qcp", mime: "audio/qcelp" };
  }
  if (r2("SQLi"))
    return { ext: "sqlite", mime: "application/x-sqlite3" };
  if (i2([78, 69, 83, 26]))
    return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
  if (r2("Cr24"))
    return { ext: "crx", mime: "application/x-google-chrome-extension" };
  if (r2("MSCF") || r2("ISc("))
    return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
  if (i2([237, 171, 238, 219]))
    return { ext: "rpm", mime: "application/x-rpm" };
  if (i2([197, 208, 211, 198]))
    return { ext: "eps", mime: "application/eps" };
  if (i2([40, 181, 47, 253]))
    return { ext: "zst", mime: "application/zstd" };
  if (i2([79, 84, 84, 79, 0]))
    return { ext: "otf", mime: "font/otf" };
  if (r2("#!AMR"))
    return { ext: "amr", mime: "audio/amr" };
  if (r2("{\\rtf"))
    return { ext: "rtf", mime: "application/rtf" };
  if (i2([70, 76, 86, 1]))
    return { ext: "flv", mime: "video/x-flv" };
  if (r2("IMPM"))
    return { ext: "it", mime: "audio/x-it" };
  if (r2("-lh0-", { offset: 2 }) || r2("-lh1-", { offset: 2 }) || r2("-lh2-", { offset: 2 }) || r2("-lh3-", { offset: 2 }) || r2("-lh4-", { offset: 2 }) || r2("-lh5-", { offset: 2 }) || r2("-lh6-", { offset: 2 }) || r2("-lh7-", { offset: 2 }) || r2("-lzs-", { offset: 2 }) || r2("-lz4-", { offset: 2 }) || r2("-lz5-", { offset: 2 }) || r2("-lhd-", { offset: 2 }))
    return { ext: "lzh", mime: "application/x-lzh-compressed" };
  if (i2([0, 0, 1, 186])) {
    if (i2([33], { offset: 4, mask: [241] }))
      return { ext: "mpg", mime: "video/MP1S" };
    if (i2([68], { offset: 4, mask: [196] }))
      return { ext: "mpg", mime: "video/MP2P" };
  }
  if (r2("ITSF"))
    return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
  if (i2([253, 55, 122, 88, 90, 0]))
    return { ext: "xz", mime: "application/x-xz" };
  if (r2("<?xml "))
    return { ext: "xml", mime: "application/xml" };
  if (i2([55, 122, 188, 175, 39, 28]))
    return { ext: "7z", mime: "application/x-7z-compressed" };
  if (i2([82, 97, 114, 33, 26, 7]) && (0 === t2[6] || 1 === t2[6]))
    return { ext: "rar", mime: "application/x-rar-compressed" };
  if (r2("solid "))
    return { ext: "stl", mime: "model/stl" };
  if (r2("BLENDER"))
    return { ext: "blend", mime: "application/x-blender" };
  if (r2("!<arch>")) {
    await e4.ignore(8);
    return "debian-binary" === await e4.readToken(new Token.StringType(13, "ascii")) ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
  }
  if (i2([137, 80, 78, 71, 13, 10, 26, 10])) {
    async function _2() {
      return { length: await e4.readToken(Token.INT32_BE), type: await e4.readToken(new Token.StringType(4, "binary")) };
    }
    await e4.ignore(8);
    do {
      const g = await _2();
      if (g.length < 0)
        return;
      switch (g.type) {
        case "IDAT":
          return { ext: "png", mime: "image/png" };
        case "acTL":
          return { ext: "apng", mime: "image/apng" };
        default:
          await e4.ignore(g.length + 4);
      }
    } while (e4.position + 8 < e4.fileInfo.size);
    return { ext: "png", mime: "image/png" };
  }
  if (i2([65, 82, 82, 79, 87, 49, 0, 0]))
    return { ext: "arrow", mime: "application/x-apache-arrow" };
  if (i2([103, 108, 84, 70, 2, 0, 0, 0]))
    return { ext: "glb", mime: "model/gltf-binary" };
  if (i2([102, 114, 101, 101], { offset: 4 }) || i2([109, 100, 97, 116], { offset: 4 }) || i2([109, 111, 111, 118], { offset: 4 }) || i2([119, 105, 100, 101], { offset: 4 }))
    return { ext: "mov", mime: "video/quicktime" };
  if (i2([73, 73, 82, 79, 8, 0, 0, 0, 24]))
    return { ext: "orf", mime: "image/x-olympus-orf" };
  if (r2("gimp xcf "))
    return { ext: "xcf", mime: "image/x-xcf" };
  if (i2([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
    return { ext: "rw2", mime: "image/x-panasonic-rw2" };
  if (i2([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function b2() {
      const t3 = Buffer2.alloc(16);
      return await e4.readBuffer(t3), { id: t3, size: Number(await e4.readToken(Token.UINT64_LE)) };
    }
    for (await e4.ignore(30); e4.position + 24 < e4.fileInfo.size; ) {
      const y2 = await b2();
      let w = y2.size - 24;
      if (_check(y2.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const v2 = Buffer2.alloc(16);
        if (w -= await e4.readBuffer(v2), _check(v2, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return { ext: "asf", mime: "audio/x-ms-asf" };
        if (_check(v2, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
          return { ext: "asf", mime: "video/x-ms-asf" };
        break;
      }
      await e4.ignore(w);
    }
    return { ext: "asf", mime: "application/vnd.ms-asf" };
  }
  if (i2([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
    return { ext: "ktx", mime: "image/ktx" };
  if ((i2([126, 16, 4]) || i2([126, 24, 4])) && i2([48, 77, 73, 69], { offset: 4 }))
    return { ext: "mie", mime: "application/x-mie" };
  if (i2([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
    return { ext: "shp", mime: "application/x-esri-shape" };
  if (i2([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
    await e4.ignore(20);
    switch (await e4.readToken(new Token.StringType(4, "ascii"))) {
      case "jp2 ":
        return { ext: "jp2", mime: "image/jp2" };
      case "jpx ":
        return { ext: "jpx", mime: "image/jpx" };
      case "jpm ":
        return { ext: "jpm", mime: "image/jpm" };
      case "mjp2":
        return { ext: "mj2", mime: "image/mj2" };
      default:
        return;
    }
  }
  if (i2([255, 10]) || i2([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
    return { ext: "jxl", mime: "image/jxl" };
  if (i2([0, 0, 1, 186]) || i2([0, 0, 1, 179]))
    return { ext: "mpg", mime: "video/mpeg" };
  if (i2([0, 1, 0, 0, 0]))
    return { ext: "ttf", mime: "font/ttf" };
  if (i2([0, 0, 1, 0]))
    return { ext: "ico", mime: "image/x-icon" };
  if (i2([0, 0, 2, 0]))
    return { ext: "cur", mime: "image/x-icon" };
  if (i2([208, 207, 17, 224, 161, 177, 26, 225]))
    return { ext: "cfb", mime: "application/x-cfb" };
  if (await e4.peekBuffer(t2, { length: Math.min(256, e4.fileInfo.size), mayBeLess: true }), r2("BEGIN:")) {
    if (r2("VCARD", { offset: 6 }))
      return { ext: "vcf", mime: "text/vcard" };
    if (r2("VCALENDAR", { offset: 6 }))
      return { ext: "ics", mime: "text/calendar" };
  }
  if (r2("FUJIFILMCCD-RAW"))
    return { ext: "raf", mime: "image/x-fujifilm-raf" };
  if (r2("Extended Module:"))
    return { ext: "xm", mime: "audio/x-xm" };
  if (r2("Creative Voice File"))
    return { ext: "voc", mime: "audio/x-voc" };
  if (i2([4, 0, 0, 0]) && t2.length >= 16) {
    const x2 = t2.readUInt32LE(12);
    if (x2 > 12 && t2.length >= x2 + 16)
      try {
        const E2 = t2.slice(16, x2 + 16).toString();
        if (JSON.parse(E2).files)
          return { ext: "asar", mime: "application/x-asar" };
      } catch (k2) {
      }
  }
  if (i2([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
    return { ext: "mxf", mime: "application/mxf" };
  if (r2("SCRM", { offset: 44 }))
    return { ext: "s3m", mime: "audio/x-s3m" };
  if (i2([71], { offset: 4 }) && (i2([71], { offset: 192 }) || i2([71], { offset: 196 })))
    return { ext: "mts", mime: "video/mp2t" };
  if (i2([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
    return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
  if (i2([68, 73, 67, 77], { offset: 128 }))
    return { ext: "dcm", mime: "application/dicom" };
  if (i2([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
    return { ext: "lnk", mime: "application/x.ms.shortcut" };
  if (i2([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
    return { ext: "alias", mime: "application/x.apple.alias" };
  if (i2([76, 80], { offset: 34 }) && (i2([0, 0, 1], { offset: 8 }) || i2([1, 0, 2], { offset: 8 }) || i2([2, 0, 2], { offset: 8 })))
    return { ext: "eot", mime: "application/vnd.ms-fontobject" };
  if (i2([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
    return { ext: "indd", mime: "application/x-indesign" };
  if (await e4.peekBuffer(t2, { length: Math.min(512, e4.fileInfo.size), mayBeLess: true }), tarHeaderChecksumMatches(t2))
    return { ext: "tar", mime: "application/x-tar" };
  if (i2([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
    return { ext: "skp", mime: "application/vnd.sketchup.skp" };
  if (r2("-----BEGIN PGP MESSAGE-----"))
    return { ext: "pgp", mime: "application/pgp-encrypted" };
  if (t2.length >= 2 && i2([255, 224], { offset: 0, mask: [255, 224] })) {
    if (i2([16], { offset: 1, mask: [22] }))
      return i2([8], { offset: 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
    if (i2([2], { offset: 1, mask: [6] }))
      return { ext: "mp3", mime: "audio/mpeg" };
    if (i2([4], { offset: 1, mask: [6] }))
      return { ext: "mp2", mime: "audio/mpeg" };
    if (i2([6], { offset: 1, mask: [6] }))
      return { ext: "mp1", mime: "audio/mpeg" };
  }
}
var stream2 = (readableStream) => new Promise((resolve, reject) => {
  const stream = eval("require")("stream");
  readableStream.on("error", reject), readableStream.once("readable", async () => {
    const e4 = new stream.PassThrough();
    let t2;
    t2 = stream.pipeline ? stream.pipeline(readableStream, e4, () => {
    }) : readableStream.pipe(e4);
    const i2 = readableStream.read(minimumBytes) || readableStream.read() || Buffer2.alloc(0);
    try {
      const t3 = await fromBuffer(i2);
      e4.fileType = t3;
    } catch (e5) {
      reject(e5);
    }
    resolve(t2);
  });
});
var fileType = { fromStream, fromTokenizer, fromBuffer, stream: stream2 };
Object.defineProperty(fileType, "extensions", { get: () => new Set(supported.extensions) }), Object.defineProperty(fileType, "mimeTypes", { get: () => new Set(supported.mimeTypes) });
var core = fileType;
var fileType$1 = getDefaultExportFromCjs(core);
function to(e4, t2) {
  return e4.then(function(e5) {
    return [null, e5];
  }).catch(function(e5) {
    return [e5, void 0];
  });
}
var writeFile = async () => {
  throw new Error("Not supported");
};
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null), this._extensions = /* @__PURE__ */ Object.create(null);
  for (let e4 = 0; e4 < arguments.length; e4++)
    this.define(arguments[e4]);
  this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
}
Mime$1.prototype.define = function(e4, t2) {
  for (let i2 in e4) {
    let r2 = e4[i2].map(function(e5) {
      return e5.toLowerCase();
    });
    i2 = i2.toLowerCase();
    for (let e5 = 0; e5 < r2.length; e5++) {
      const n2 = r2[e5];
      if ("*" !== n2[0]) {
        if (!t2 && n2 in this._types)
          throw new Error('Attempt to change mapping for "' + n2 + '" extension from "' + this._types[n2] + '" to "' + i2 + '". Pass `force=true` to allow this, otherwise remove "' + n2 + '" from the list of extensions for "' + i2 + '".');
        this._types[n2] = i2;
      }
    }
    if (t2 || !this._extensions[i2]) {
      const e5 = r2[0];
      this._extensions[i2] = "*" !== e5[0] ? e5 : e5.substr(1);
    }
  }
}, Mime$1.prototype.getType = function(e4) {
  let t2 = (e4 = String(e4)).replace(/^.*[/\\]/, "").toLowerCase(), i2 = t2.replace(/^.*\./, "").toLowerCase(), r2 = t2.length < e4.length;
  return (i2.length < t2.length - 1 || !r2) && this._types[i2] || null;
}, Mime$1.prototype.getExtension = function(e4) {
  return (e4 = /^\s*([^;\s]*)/.test(e4) && RegExp.$1) && this._extensions[e4.toLowerCase()] || null;
};
var Mime_1 = Mime$1;
var standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
var Mime = Mime_1;
var lite = new Mime(standard);
var mime = getDefaultExportFromCjs(lite);
var HorizontalAlign;
var HorizontalAlign2;
var VerticalAlign;
var VerticalAlign2;
var BlendMode;
var BlendMode2;
function srcOver(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a;
  return { r: (e4.r * e4.a + t2.r * t2.a * (1 - e4.a)) / r2, g: (e4.g * e4.a + t2.g * t2.a * (1 - e4.a)) / r2, b: (e4.b * e4.a + t2.b * t2.a * (1 - e4.a)) / r2, a: r2 };
}
function dstOver(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a;
  return { r: (t2.r * t2.a + e4.r * e4.a * (1 - t2.a)) / r2, g: (t2.g * t2.a + e4.g * e4.a * (1 - t2.a)) / r2, b: (t2.b * t2.a + e4.b * e4.a * (1 - t2.a)) / r2, a: r2 };
}
function multiply(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (n2 * s2 + n2 * (1 - t2.a) + s2 * (1 - e4.a)) / r2, g: (a2 * l2 + a2 * (1 - t2.a) + l2 * (1 - e4.a)) / r2, b: (o2 * u2 + o2 * (1 - t2.a) + u2 * (1 - e4.a)) / r2, a: r2 };
}
function add(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a;
  return { r: (n2 + t2.r * t2.a) / r2, g: (a2 + t2.g * t2.a) / r2, b: (o2 + t2.b * t2.a) / r2, a: r2 };
}
function screen(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (n2 * t2.a + s2 * e4.a - n2 * s2 + n2 * (1 - t2.a) + s2 * (1 - e4.a)) / r2, g: (a2 * t2.a + l2 * e4.a - a2 * l2 + a2 * (1 - t2.a) + l2 * (1 - e4.a)) / r2, b: (o2 * t2.a + u2 * e4.a - o2 * u2 + o2 * (1 - t2.a) + u2 * (1 - e4.a)) / r2, a: r2 };
}
function overlay(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (2 * s2 <= t2.a ? 2 * n2 * s2 + n2 * (1 - t2.a) + s2 * (1 - e4.a) : n2 * (1 + t2.a) + s2 * (1 + e4.a) - 2 * s2 * n2 - t2.a * e4.a) / r2, g: (2 * l2 <= t2.a ? 2 * a2 * l2 + a2 * (1 - t2.a) + l2 * (1 - e4.a) : a2 * (1 + t2.a) + l2 * (1 + e4.a) - 2 * l2 * a2 - t2.a * e4.a) / r2, b: (2 * u2 <= t2.a ? 2 * o2 * u2 + o2 * (1 - t2.a) + u2 * (1 - e4.a) : o2 * (1 + t2.a) + u2 * (1 + e4.a) - 2 * u2 * o2 - t2.a * e4.a) / r2, a: r2 };
}
function darken(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (Math.min(n2 * t2.a, s2 * e4.a) + n2 * (1 - t2.a) + s2 * (1 - e4.a)) / r2, g: (Math.min(a2 * t2.a, l2 * e4.a) + a2 * (1 - t2.a) + l2 * (1 - e4.a)) / r2, b: (Math.min(o2 * t2.a, u2 * e4.a) + o2 * (1 - t2.a) + u2 * (1 - e4.a)) / r2, a: r2 };
}
function lighten(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (Math.max(n2 * t2.a, s2 * e4.a) + n2 * (1 - t2.a) + s2 * (1 - e4.a)) / r2, g: (Math.max(a2 * t2.a, l2 * e4.a) + a2 * (1 - t2.a) + l2 * (1 - e4.a)) / r2, b: (Math.max(o2 * t2.a, u2 * e4.a) + o2 * (1 - t2.a) + u2 * (1 - e4.a)) / r2, a: r2 };
}
function hardLight(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (2 * n2 <= e4.a ? 2 * n2 * s2 + n2 * (1 - t2.a) + s2 * (1 - e4.a) : n2 * (1 + t2.a) + s2 * (1 + e4.a) - 2 * s2 * n2 - t2.a * e4.a) / r2, g: (2 * a2 <= e4.a ? 2 * a2 * l2 + a2 * (1 - t2.a) + l2 * (1 - e4.a) : a2 * (1 + t2.a) + l2 * (1 + e4.a) - 2 * l2 * a2 - t2.a * e4.a) / r2, b: (2 * o2 <= e4.a ? 2 * o2 * u2 + o2 * (1 - t2.a) + u2 * (1 - e4.a) : o2 * (1 + t2.a) + u2 * (1 + e4.a) - 2 * u2 * o2 - t2.a * e4.a) / r2, a: r2 };
}
function difference(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (n2 + s2 - 2 * Math.min(n2 * t2.a, s2 * e4.a)) / r2, g: (a2 + l2 - 2 * Math.min(a2 * t2.a, l2 * e4.a)) / r2, b: (o2 + u2 - 2 * Math.min(o2 * t2.a, u2 * e4.a)) / r2, a: r2 };
}
function exclusion(e4, t2, i2 = 1) {
  e4.a *= i2;
  const r2 = t2.a + e4.a - t2.a * e4.a, n2 = e4.r * e4.a, a2 = e4.g * e4.a, o2 = e4.b * e4.a, s2 = t2.r * t2.a, l2 = t2.g * t2.a, u2 = t2.b * t2.a;
  return { r: (n2 * t2.a + s2 * e4.a - 2 * n2 * s2 + n2 * (1 - t2.a) + s2 * (1 - e4.a)) / r2, g: (a2 * t2.a + l2 * e4.a - 2 * a2 * l2 + a2 * (1 - t2.a) + l2 * (1 - e4.a)) / r2, b: (o2 * t2.a + u2 * e4.a - 2 * o2 * u2 + o2 * (1 - t2.a) + u2 * (1 - e4.a)) / r2, a: r2 };
}
HorizontalAlign2 = HorizontalAlign || (HorizontalAlign = {}), HorizontalAlign2[HorizontalAlign2.LEFT = 1] = "LEFT", HorizontalAlign2[HorizontalAlign2.CENTER = 2] = "CENTER", HorizontalAlign2[HorizontalAlign2.RIGHT = 4] = "RIGHT", VerticalAlign2 = VerticalAlign || (VerticalAlign = {}), VerticalAlign2[VerticalAlign2.TOP = 8] = "TOP", VerticalAlign2[VerticalAlign2.MIDDLE = 16] = "MIDDLE", VerticalAlign2[VerticalAlign2.BOTTOM = 32] = "BOTTOM", BlendMode2 = BlendMode || (BlendMode = {}), BlendMode2.SRC_OVER = "srcOver", BlendMode2.DST_OVER = "dstOver", BlendMode2.MULTIPLY = "multiply", BlendMode2.ADD = "add", BlendMode2.SCREEN = "screen", BlendMode2.OVERLAY = "overlay", BlendMode2.DARKEN = "darken", BlendMode2.LIGHTEN = "lighten", BlendMode2.HARD_LIGHT = "hardLight", BlendMode2.DIFFERENCE = "difference", BlendMode2.EXCLUSION = "exclusion";
var names = [srcOver, dstOver, multiply, add, screen, overlay, darken, lighten, hardLight, difference, exclusion];
var compositeModes = Object.freeze({ __proto__: null, add, darken, difference, dstOver, exclusion, hardLight, lighten, multiply, names, overlay, screen, srcOver });
function composite(e4, t2, i2 = 0, r2 = 0, n2 = {}) {
  if (!(t2 instanceof e4.constructor))
    throw new Error("The source must be a Jimp image");
  if ("number" != typeof i2 || "number" != typeof r2)
    throw new Error("x and y must be numbers");
  const { mode: a2 = BlendMode.SRC_OVER } = n2;
  let { opacitySource: o2 = 1, opacityDest: s2 = 1 } = n2;
  ("number" != typeof o2 || o2 < 0 || o2 > 1) && (o2 = 1), ("number" != typeof s2 || s2 < 0 || s2 > 1) && (s2 = 1);
  const l2 = compositeModes[a2];
  return i2 = Math.round(i2), r2 = Math.round(r2), 1 !== s2 && e4.scan((t3, i3, r3) => {
    const n3 = e4.bitmap.data[r3 + 3] * s2;
    e4.bitmap.data[r3 + 3] = n3;
  }), t2.scan((n3, a3, s3) => {
    const u2 = e4.getPixelIndex(i2 + n3, r2 + a3, Edge.CROP);
    if (-1 === u2)
      return;
    const h2 = l2({ r: t2.bitmap.data[s3 + 0] / 255, g: t2.bitmap.data[s3 + 1] / 255, b: t2.bitmap.data[s3 + 2] / 255, a: t2.bitmap.data[s3 + 3] / 255 }, { r: e4.bitmap.data[u2 + 0] / 255, g: e4.bitmap.data[u2 + 1] / 255, b: e4.bitmap.data[u2 + 2] / 255, a: e4.bitmap.data[u2 + 3] / 255 }, o2);
    e4.bitmap.data[u2 + 0] = limit255(255 * h2.r), e4.bitmap.data[u2 + 1] = limit255(255 * h2.g), e4.bitmap.data[u2 + 2] = limit255(255 * h2.b), e4.bitmap.data[u2 + 3] = limit255(255 * h2.a);
  }), e4;
}
var jpeg$1 = { parseSections: function(e4, t2) {
  var i2, r2;
  for (e4.setBigEndian(true); e4.remainingLength() > 0 && 218 !== r2; ) {
    if (255 !== e4.nextUInt8())
      throw new Error("Invalid JPEG section offset");
    i2 = (r2 = e4.nextUInt8()) >= 208 && r2 <= 217 || 218 === r2 ? 0 : e4.nextUInt16() - 2, t2(r2, e4.branch(0, i2)), e4.skip(i2);
  }
}, getSizeFromSOFSection: function(e4) {
  return e4.skip(1), { height: e4.nextUInt16(), width: e4.nextUInt16() };
}, getSectionName: function(e4) {
  var t2, i2;
  switch (e4) {
    case 216:
      t2 = "SOI";
      break;
    case 196:
      t2 = "DHT";
      break;
    case 219:
      t2 = "DQT";
      break;
    case 221:
      t2 = "DRI";
      break;
    case 218:
      t2 = "SOS";
      break;
    case 254:
      t2 = "COM";
      break;
    case 217:
      t2 = "EOI";
      break;
    default:
      e4 >= 224 && e4 <= 239 ? (t2 = "APP", i2 = e4 - 224) : e4 >= 192 && e4 <= 207 && 196 !== e4 && 200 !== e4 && 204 !== e4 ? (t2 = "SOF", i2 = e4 - 192) : e4 >= 208 && e4 <= 215 && (t2 = "RST", i2 = e4 - 208);
  }
  var r2 = { name: t2 };
  return "number" == typeof i2 && (r2.index = i2), r2;
} };
function readExifValue(e4, t2) {
  switch (e4) {
    case 1:
      return t2.nextUInt8();
    case 3:
    case 8:
      return t2.nextUInt16();
    case 4:
    case 9:
      return t2.nextUInt32();
    case 5:
      return [t2.nextUInt32(), t2.nextUInt32()];
    case 6:
      return t2.nextInt8();
    case 10:
      return [t2.nextInt32(), t2.nextInt32()];
    case 11:
      return t2.nextFloat();
    case 12:
      return t2.nextDouble();
    default:
      throw new Error("Invalid format while decoding: " + e4);
  }
}
function getBytesPerComponent(e4) {
  switch (e4) {
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
      return 4;
    case 5:
    case 10:
    case 12:
      return 8;
    default:
      return 0;
  }
}
function readExifTag(e4, t2) {
  var i2, r2, n2 = t2.nextUInt16(), a2 = t2.nextUInt16(), o2 = getBytesPerComponent(a2), s2 = t2.nextUInt32(), l2 = o2 * s2;
  if (l2 > 4 && (t2 = e4.openWithOffset(t2.nextUInt32())), 2 === a2) {
    var u2 = (i2 = t2.nextString(s2)).indexOf("\0");
    -1 !== u2 && (i2 = i2.substr(0, u2));
  } else if (7 === a2)
    i2 = t2.nextBuffer(s2);
  else if (0 !== a2)
    for (i2 = [], r2 = 0; r2 < s2; ++r2)
      i2.push(readExifValue(a2, t2));
  return l2 < 4 && t2.skip(4 - l2), [n2, i2, a2];
}
function readIFDSection(e4, t2, i2) {
  var r2, n2, a2 = t2.nextUInt16();
  for (n2 = 0; n2 < a2; ++n2)
    i2((r2 = readExifTag(e4, t2))[0], r2[1], r2[2]);
}
function readHeader(e4) {
  if ("Exif\0\0" !== e4.nextString(6))
    throw new Error("Invalid EXIF header");
  var t2 = e4.mark(), i2 = e4.nextUInt16();
  if (18761 === i2)
    e4.setBigEndian(false);
  else {
    if (19789 !== i2)
      throw new Error("Invalid TIFF header");
    e4.setBigEndian(true);
  }
  if (42 !== e4.nextUInt16())
    throw new Error("Invalid TIFF data");
  return t2;
}
var exif$2 = { IFD0: 1, IFD1: 2, GPSIFD: 3, SubIFD: 4, InteropIFD: 5, parseTags: function(e4, t2) {
  var i2, r2, n2, a2;
  try {
    i2 = readHeader(e4);
  } catch (e5) {
    return false;
  }
  var o2 = i2.openWithOffset(e4.nextUInt32()), s2 = this.IFD0;
  readIFDSection(i2, o2, function(e5, i3, a3) {
    switch (e5) {
      case 34853:
        n2 = i3[0];
        break;
      case 34665:
        r2 = i3[0];
        break;
      default:
        t2(s2, e5, i3, a3);
    }
  });
  var l2 = o2.nextUInt32();
  if (0 !== l2) {
    var u2 = i2.openWithOffset(l2);
    readIFDSection(i2, u2, t2.bind(null, this.IFD1));
  }
  if (n2) {
    var h2 = i2.openWithOffset(n2);
    readIFDSection(i2, h2, t2.bind(null, this.GPSIFD));
  }
  if (r2) {
    var c2 = i2.openWithOffset(r2), f2 = this.InteropIFD;
    readIFDSection(i2, c2, function(e5, i3, r3) {
      40965 === e5 ? a2 = i3[0] : t2(f2, e5, i3, r3);
    });
  }
  if (a2) {
    var d = i2.openWithOffset(a2);
    readIFDSection(i2, d, t2.bind(null, this.InteropIFD));
  }
  return true;
} };
function parseNumber(e4) {
  return parseInt(e4, 10);
}
var hours = 3600;
var minutes = 60;
function parseDateTimeParts(e4, t2) {
  e4 = e4.map(parseNumber), t2 = t2.map(parseNumber);
  var i2 = e4[0], r2 = e4[1] - 1, n2 = e4[2], a2 = t2[0], o2 = t2[1], s2 = t2[2];
  return Date.UTC(i2, r2, n2, a2, o2, s2, 0) / 1e3;
}
function parseDateWithTimezoneFormat(e4) {
  var t2 = e4.substr(0, 10).split("-"), i2 = e4.substr(11, 8).split(":"), r2 = e4.substr(19, 6).split(":").map(parseNumber), n2 = r2[0] * hours + r2[1] * minutes, a2 = parseDateTimeParts(t2, i2);
  if ("number" == typeof (a2 -= n2) && !isNaN(a2))
    return a2;
}
function parseDateWithSpecFormat(e4) {
  var t2 = e4.split(" "), i2 = parseDateTimeParts(t2[0].split(":"), t2[1].split(":"));
  if ("number" == typeof i2 && !isNaN(i2))
    return i2;
}
function parseExifDate(e4) {
  var t2 = 19 === e4.length && ":" === e4.charAt(4);
  return 25 === e4.length && "T" === e4.charAt(10) ? parseDateWithTimezoneFormat(e4) : t2 ? parseDateWithSpecFormat(e4) : void 0;
}
var date$1 = { parseDateWithSpecFormat, parseDateWithTimezoneFormat, parseExifDate };
var exif$1 = exif$2;
var date = date$1;
var degreeTags = [{ section: exif$1.GPSIFD, type: 2, name: "GPSLatitude", refType: 1, refName: "GPSLatitudeRef", posVal: "N" }, { section: exif$1.GPSIFD, type: 4, name: "GPSLongitude", refType: 3, refName: "GPSLongitudeRef", posVal: "E" }];
var dateTags = [{ section: exif$1.SubIFD, type: 306, name: "ModifyDate" }, { section: exif$1.SubIFD, type: 36867, name: "DateTimeOriginal" }, { section: exif$1.SubIFD, type: 36868, name: "CreateDate" }, { section: exif$1.SubIFD, type: 306, name: "ModifyDate" }];
var simplify$1 = { castDegreeValues: function(e4, t2) {
  degreeTags.forEach(function(i2) {
    var r2 = e4(i2);
    if (r2) {
      var n2 = e4({ section: i2.section, type: i2.refType, name: i2.refName }) === i2.posVal ? 1 : -1, a2 = (r2[0] + r2[1] / 60 + r2[2] / 3600) * n2;
      t2(i2, a2);
    }
  });
}, castDateValues: function(e4, t2) {
  dateTags.forEach(function(i2) {
    var r2 = e4(i2);
    if (r2) {
      var n2 = date.parseExifDate(r2);
      void 0 !== n2 && t2(i2, n2);
    }
  });
}, simplifyValue: function(e4, t2) {
  return Array.isArray(e4) && 1 === (e4 = e4.map(function(e5) {
    return 10 === t2 || 5 === t2 ? e5[0] / e5[1] : e5;
  })).length && (e4 = e4[0]), e4;
} };
var exifTags;
var hasRequiredExifTags;
function requireExifTags() {
  return hasRequiredExifTags ? exifTags : (hasRequiredExifTags = 1, exifTags = { exif: { 1: "InteropIndex", 2: "InteropVersion", 11: "ProcessingSoftware", 254: "SubfileType", 255: "OldSubfileType", 256: "ImageWidth", 257: "ImageHeight", 258: "BitsPerSample", 259: "Compression", 262: "PhotometricInterpretation", 263: "Thresholding", 264: "CellWidth", 265: "CellLength", 266: "FillOrder", 269: "DocumentName", 270: "ImageDescription", 271: "Make", 272: "Model", 273: "StripOffsets", 274: "Orientation", 277: "SamplesPerPixel", 278: "RowsPerStrip", 279: "StripByteCounts", 280: "MinSampleValue", 281: "MaxSampleValue", 282: "XResolution", 283: "YResolution", 284: "PlanarConfiguration", 285: "PageName", 286: "XPosition", 287: "YPosition", 288: "FreeOffsets", 289: "FreeByteCounts", 290: "GrayResponseUnit", 291: "GrayResponseCurve", 292: "T4Options", 293: "T6Options", 296: "ResolutionUnit", 297: "PageNumber", 300: "ColorResponseUnit", 301: "TransferFunction", 305: "Software", 306: "ModifyDate", 315: "Artist", 316: "HostComputer", 317: "Predictor", 318: "WhitePoint", 319: "PrimaryChromaticities", 320: "ColorMap", 321: "HalftoneHints", 322: "TileWidth", 323: "TileLength", 324: "TileOffsets", 325: "TileByteCounts", 326: "BadFaxLines", 327: "CleanFaxData", 328: "ConsecutiveBadFaxLines", 330: "SubIFD", 332: "InkSet", 333: "InkNames", 334: "NumberofInks", 336: "DotRange", 337: "TargetPrinter", 338: "ExtraSamples", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 342: "TransferRange", 343: "ClipPath", 344: "XClipPathUnits", 345: "YClipPathUnits", 346: "Indexed", 347: "JPEGTables", 351: "OPIProxy", 400: "GlobalParametersIFD", 401: "ProfileType", 402: "FaxProfile", 403: "CodingMethods", 404: "VersionYear", 405: "ModeNumber", 433: "Decode", 434: "DefaultImageColor", 435: "T82Options", 437: "JPEGTables", 512: "JPEGProc", 513: "ThumbnailOffset", 514: "ThumbnailLength", 515: "JPEGRestartInterval", 517: "JPEGLosslessPredictors", 518: "JPEGPointTransforms", 519: "JPEGQTables", 520: "JPEGDCTables", 521: "JPEGACTables", 529: "YCbCrCoefficients", 530: "YCbCrSubSampling", 531: "YCbCrPositioning", 532: "ReferenceBlackWhite", 559: "StripRowCounts", 700: "ApplicationNotes", 999: "USPTOMiscellaneous", 4096: "RelatedImageFileFormat", 4097: "RelatedImageWidth", 4098: "RelatedImageHeight", 18246: "Rating", 18247: "XP_DIP_XML", 18248: "StitchInfo", 18249: "RatingPercent", 32781: "ImageID", 32931: "WangTag1", 32932: "WangAnnotation", 32933: "WangTag3", 32934: "WangTag4", 32995: "Matteing", 32996: "DataType", 32997: "ImageDepth", 32998: "TileDepth", 33405: "Model2", 33421: "CFARepeatPatternDim", 33422: "CFAPattern2", 33423: "BatteryLevel", 33424: "KodakIFD", 33432: "Copyright", 33434: "ExposureTime", 33437: "FNumber", 33445: "MDFileTag", 33446: "MDScalePixel", 33447: "MDColorTable", 33448: "MDLabName", 33449: "MDSampleInfo", 33450: "MDPrepDate", 33451: "MDPrepTime", 33452: "MDFileUnits", 33550: "PixelScale", 33589: "AdventScale", 33590: "AdventRevision", 33628: "UIC1Tag", 33629: "UIC2Tag", 33630: "UIC3Tag", 33631: "UIC4Tag", 33723: "IPTC-NAA", 33918: "IntergraphPacketData", 33919: "IntergraphFlagRegisters", 33920: "IntergraphMatrix", 33921: "INGRReserved", 33922: "ModelTiePoint", 34016: "Site", 34017: "ColorSequence", 34018: "IT8Header", 34019: "RasterPadding", 34020: "BitsPerRunLength", 34021: "BitsPerExtendedRunLength", 34022: "ColorTable", 34023: "ImageColorIndicator", 34024: "BackgroundColorIndicator", 34025: "ImageColorValue", 34026: "BackgroundColorValue", 34027: "PixelIntensityRange", 34028: "TransparencyIndicator", 34029: "ColorCharacterization", 34030: "HCUsage", 34031: "TrapIndicator", 34032: "CMYKEquivalent", 34118: "SEMInfo", 34152: "AFCP_IPTC", 34232: "PixelMagicJBIGOptions", 34264: "ModelTransform", 34306: "WB_GRGBLevels", 34310: "LeafData", 34377: "PhotoshopSettings", 34665: "ExifOffset", 34675: "ICC_Profile", 34687: "TIFF_FXExtensions", 34688: "MultiProfiles", 34689: "SharedData", 34690: "T88Options", 34732: "ImageLayer", 34735: "GeoTiffDirectory", 34736: "GeoTiffDoubleParams", 34737: "GeoTiffAsciiParams", 34850: "ExposureProgram", 34852: "SpectralSensitivity", 34853: "GPSInfo", 34855: "ISO", 34856: "Opto-ElectricConvFactor", 34857: "Interlace", 34858: "TimeZoneOffset", 34859: "SelfTimerMode", 34864: "SensitivityType", 34865: "StandardOutputSensitivity", 34866: "RecommendedExposureIndex", 34867: "ISOSpeed", 34868: "ISOSpeedLatitudeyyy", 34869: "ISOSpeedLatitudezzz", 34908: "FaxRecvParams", 34909: "FaxSubAddress", 34910: "FaxRecvTime", 34954: "LeafSubIFD", 36864: "ExifVersion", 36867: "DateTimeOriginal", 36868: "CreateDate", 37121: "ComponentsConfiguration", 37122: "CompressedBitsPerPixel", 37377: "ShutterSpeedValue", 37378: "ApertureValue", 37379: "BrightnessValue", 37380: "ExposureCompensation", 37381: "MaxApertureValue", 37382: "SubjectDistance", 37383: "MeteringMode", 37384: "LightSource", 37385: "Flash", 37386: "FocalLength", 37387: "FlashEnergy", 37388: "SpatialFrequencyResponse", 37389: "Noise", 37390: "FocalPlaneXResolution", 37391: "FocalPlaneYResolution", 37392: "FocalPlaneResolutionUnit", 37393: "ImageNumber", 37394: "SecurityClassification", 37395: "ImageHistory", 37396: "SubjectArea", 37397: "ExposureIndex", 37398: "TIFF-EPStandardID", 37399: "SensingMethod", 37434: "CIP3DataFile", 37435: "CIP3Sheet", 37436: "CIP3Side", 37439: "StoNits", 37500: "MakerNote", 37510: "UserComment", 37520: "SubSecTime", 37521: "SubSecTimeOriginal", 37522: "SubSecTimeDigitized", 37679: "MSDocumentText", 37680: "MSPropertySetStorage", 37681: "MSDocumentTextPosition", 37724: "ImageSourceData", 40091: "XPTitle", 40092: "XPComment", 40093: "XPAuthor", 40094: "XPKeywords", 40095: "XPSubject", 40960: "FlashpixVersion", 40961: "ColorSpace", 40962: "ExifImageWidth", 40963: "ExifImageHeight", 40964: "RelatedSoundFile", 40965: "InteropOffset", 41483: "FlashEnergy", 41484: "SpatialFrequencyResponse", 41485: "Noise", 41486: "FocalPlaneXResolution", 41487: "FocalPlaneYResolution", 41488: "FocalPlaneResolutionUnit", 41489: "ImageNumber", 41490: "SecurityClassification", 41491: "ImageHistory", 41492: "SubjectLocation", 41493: "ExposureIndex", 41494: "TIFF-EPStandardID", 41495: "SensingMethod", 41728: "FileSource", 41729: "SceneType", 41730: "CFAPattern", 41985: "CustomRendered", 41986: "ExposureMode", 41987: "WhiteBalance", 41988: "DigitalZoomRatio", 41989: "FocalLengthIn35mmFormat", 41990: "SceneCaptureType", 41991: "GainControl", 41992: "Contrast", 41993: "Saturation", 41994: "Sharpness", 41995: "DeviceSettingDescription", 41996: "SubjectDistanceRange", 42016: "ImageUniqueID", 42032: "OwnerName", 42033: "SerialNumber", 42034: "LensInfo", 42035: "LensMake", 42036: "LensModel", 42037: "LensSerialNumber", 42112: "GDALMetadata", 42113: "GDALNoData", 42240: "Gamma", 44992: "ExpandSoftware", 44993: "ExpandLens", 44994: "ExpandFilm", 44995: "ExpandFilterLens", 44996: "ExpandScanner", 44997: "ExpandFlashLamp", 48129: "PixelFormat", 48130: "Transformation", 48131: "Uncompressed", 48132: "ImageType", 48256: "ImageWidth", 48257: "ImageHeight", 48258: "WidthResolution", 48259: "HeightResolution", 48320: "ImageOffset", 48321: "ImageByteCount", 48322: "AlphaOffset", 48323: "AlphaByteCount", 48324: "ImageDataDiscard", 48325: "AlphaDataDiscard", 50215: "OceScanjobDesc", 50216: "OceApplicationSelector", 50217: "OceIDNumber", 50218: "OceImageLogic", 50255: "Annotations", 50341: "PrintIM", 50560: "USPTOOriginalContentType", 50706: "DNGVersion", 50707: "DNGBackwardVersion", 50708: "UniqueCameraModel", 50709: "LocalizedCameraModel", 50710: "CFAPlaneColor", 50711: "CFALayout", 50712: "LinearizationTable", 50713: "BlackLevelRepeatDim", 50714: "BlackLevel", 50715: "BlackLevelDeltaH", 50716: "BlackLevelDeltaV", 50717: "WhiteLevel", 50718: "DefaultScale", 50719: "DefaultCropOrigin", 50720: "DefaultCropSize", 50721: "ColorMatrix1", 50722: "ColorMatrix2", 50723: "CameraCalibration1", 50724: "CameraCalibration2", 50725: "ReductionMatrix1", 50726: "ReductionMatrix2", 50727: "AnalogBalance", 50728: "AsShotNeutral", 50729: "AsShotWhiteXY", 50730: "BaselineExposure", 50731: "BaselineNoise", 50732: "BaselineSharpness", 50733: "BayerGreenSplit", 50734: "LinearResponseLimit", 50735: "CameraSerialNumber", 50736: "DNGLensInfo", 50737: "ChromaBlurRadius", 50738: "AntiAliasStrength", 50739: "ShadowScale", 50740: "DNGPrivateData", 50741: "MakerNoteSafety", 50752: "RawImageSegmentation", 50778: "CalibrationIlluminant1", 50779: "CalibrationIlluminant2", 50780: "BestQualityScale", 50781: "RawDataUniqueID", 50784: "AliasLayerMetadata", 50827: "OriginalRawFileName", 50828: "OriginalRawFileData", 50829: "ActiveArea", 50830: "MaskedAreas", 50831: "AsShotICCProfile", 50832: "AsShotPreProfileMatrix", 50833: "CurrentICCProfile", 50834: "CurrentPreProfileMatrix", 50879: "ColorimetricReference", 50898: "PanasonicTitle", 50899: "PanasonicTitle2", 50931: "CameraCalibrationSig", 50932: "ProfileCalibrationSig", 50933: "ProfileIFD", 50934: "AsShotProfileName", 50935: "NoiseReductionApplied", 50936: "ProfileName", 50937: "ProfileHueSatMapDims", 50938: "ProfileHueSatMapData1", 50939: "ProfileHueSatMapData2", 50940: "ProfileToneCurve", 50941: "ProfileEmbedPolicy", 50942: "ProfileCopyright", 50964: "ForwardMatrix1", 50965: "ForwardMatrix2", 50966: "PreviewApplicationName", 50967: "PreviewApplicationVersion", 50968: "PreviewSettingsName", 50969: "PreviewSettingsDigest", 50970: "PreviewColorSpace", 50971: "PreviewDateTime", 50972: "RawImageDigest", 50973: "OriginalRawFileDigest", 50974: "SubTileBlockSize", 50975: "RowInterleaveFactor", 50981: "ProfileLookTableDims", 50982: "ProfileLookTableData", 51008: "OpcodeList1", 51009: "OpcodeList2", 51022: "OpcodeList3", 51041: "NoiseProfile", 51043: "TimeCodes", 51044: "FrameRate", 51058: "TStop", 51081: "ReelName", 51089: "OriginalDefaultFinalSize", 51090: "OriginalBestQualitySize", 51091: "OriginalDefaultCropSize", 51105: "CameraLabel", 51107: "ProfileHueSatMapEncoding", 51108: "ProfileLookTableEncoding", 51109: "BaselineExposureOffset", 51110: "DefaultBlackRender", 51111: "NewRawImageDigest", 51112: "RawToPreviewGain", 51125: "DefaultUserCrop", 59932: "Padding", 59933: "OffsetSchema", 65e3: "OwnerName", 65001: "SerialNumber", 65002: "Lens", 65024: "KDC_IFD", 65100: "RawFile", 65101: "Converter", 65102: "WhiteBalance", 65105: "Exposure", 65106: "Shadows", 65107: "Brightness", 65108: "Contrast", 65109: "Saturation", 65110: "Sharpness", 65111: "Smoothness", 65112: "MoireFilter" }, gps: { 0: "GPSVersionID", 1: "GPSLatitudeRef", 2: "GPSLatitude", 3: "GPSLongitudeRef", 4: "GPSLongitude", 5: "GPSAltitudeRef", 6: "GPSAltitude", 7: "GPSTimeStamp", 8: "GPSSatellites", 9: "GPSStatus", 10: "GPSMeasureMode", 11: "GPSDOP", 12: "GPSSpeedRef", 13: "GPSSpeed", 14: "GPSTrackRef", 15: "GPSTrack", 16: "GPSImgDirectionRef", 17: "GPSImgDirection", 18: "GPSMapDatum", 19: "GPSDestLatitudeRef", 20: "GPSDestLatitude", 21: "GPSDestLongitudeRef", 22: "GPSDestLongitude", 23: "GPSDestBearingRef", 24: "GPSDestBearing", 25: "GPSDestDistanceRef", 26: "GPSDestDistance", 27: "GPSProcessingMethod", 28: "GPSAreaInformation", 29: "GPSDateStamp", 30: "GPSDifferential", 31: "GPSHPositioningError" } });
}
var jpeg = jpeg$1;
var exif = exif$2;
var simplify = simplify$1;
function ExifResult(e4, t2, i2, r2, n2, a2, o2) {
  this.startMarker = e4, this.tags = t2, this.imageSize = i2, this.thumbnailOffset = r2, this.thumbnailLength = n2, this.thumbnailType = a2, this.app1Offset = o2;
}
function Parser$1(e4) {
  this.stream = e4, this.flags = { readBinaryTags: false, resolveTagNames: true, simplifyValues: true, imageSize: true, hidePointers: true, returnTags: true };
}
ExifResult.prototype = { hasThumbnail: function(e4) {
  return !(!this.thumbnailOffset || !this.thumbnailLength) && ("string" != typeof e4 || ("image/jpeg" === e4.toLowerCase().trim() ? 6 === this.thumbnailType : "image/tiff" === e4.toLowerCase().trim() && 1 === this.thumbnailType));
}, getThumbnailOffset: function() {
  return this.app1Offset + 6 + this.thumbnailOffset;
}, getThumbnailLength: function() {
  return this.thumbnailLength;
}, getThumbnailBuffer: function() {
  return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
}, _getThumbnailStream: function() {
  return this.startMarker.openWithOffset(this.getThumbnailOffset());
}, getImageSize: function() {
  return this.imageSize;
}, getThumbnailSize: function() {
  var e4, t2 = this._getThumbnailStream();
  return jpeg.parseSections(t2, function(t3, i2) {
    "SOF" === jpeg.getSectionName(t3).name && (e4 = jpeg.getSizeFromSOFSection(i2));
  }), e4;
} }, Parser$1.prototype = { enableBinaryFields: function(e4) {
  return this.flags.readBinaryTags = !!e4, this;
}, enablePointers: function(e4) {
  return this.flags.hidePointers = !e4, this;
}, enableTagNames: function(e4) {
  return this.flags.resolveTagNames = !!e4, this;
}, enableImageSize: function(e4) {
  return this.flags.imageSize = !!e4, this;
}, enableReturnTags: function(e4) {
  return this.flags.returnTags = !!e4, this;
}, enableSimpleValues: function(e4) {
  return this.flags.simplifyValues = !!e4, this;
}, parse: function() {
  var e4, t2, i2, r2, n2, a2, o2, s2, l2, u2 = this.stream.mark(), h2 = u2.openWithOffset(0), c2 = this.flags;
  return c2.resolveTagNames && (o2 = requireExifTags()), c2.resolveTagNames ? (e4 = {}, s2 = function(t3) {
    return e4[t3.name];
  }, l2 = function(t3, i3) {
    e4[t3.name] = i3;
  }) : (e4 = [], s2 = function(t3) {
    var i3;
    for (i3 = 0; i3 < e4.length; ++i3)
      if (e4[i3].type === t3.type && e4[i3].section === t3.section)
        return e4.value;
  }, l2 = function(t3, i3) {
    var r3;
    for (r3 = 0; r3 < e4.length; ++r3)
      if (e4[r3].type === t3.type && e4[r3].section === t3.section)
        return void (e4.value = i3);
  }), jpeg.parseSections(h2, function(s3, l3) {
    var h3 = l3.offsetFrom(u2);
    225 === s3 ? exif.parseTags(l3, function(t3, a3, s4, l4) {
      if (c2.readBinaryTags || 7 !== l4) {
        if (513 === a3) {
          if (i2 = s4[0], c2.hidePointers)
            return;
        } else if (514 === a3) {
          if (r2 = s4[0], c2.hidePointers)
            return;
        } else if (259 === a3 && (n2 = s4[0], c2.hidePointers))
          return;
        if (c2.returnTags)
          if (c2.simplifyValues && (s4 = simplify.simplifyValue(s4, l4)), c2.resolveTagNames) {
            var u3 = (t3 === exif.GPSIFD ? o2.gps : o2.exif)[a3];
            u3 || (u3 = o2.exif[a3]), e4.hasOwnProperty(u3) || (e4[u3] = s4);
          } else
            e4.push({ section: t3, type: a3, value: s4 });
      }
    }) && (a2 = h3) : c2.imageSize && "SOF" === jpeg.getSectionName(s3).name && (t2 = jpeg.getSizeFromSOFSection(l3));
  }), c2.simplifyValues && (simplify.castDegreeValues(s2, l2), simplify.castDateValues(s2, l2)), new ExifResult(u2, e4, t2, i2, r2, n2, a2);
} };
var parser = Parser$1;
var domBufferstream;
var hasRequiredDomBufferstream;
var bufferstream;
var hasRequiredBufferstream;
function requireDomBufferstream() {
  if (hasRequiredDomBufferstream)
    return domBufferstream;
  function e4(e5, t2, i2, r2, n2, a2) {
    this.global = n2, t2 = t2 || 0, i2 = i2 || e5.byteLength - t2, this.arrayBuffer = e5.slice(t2, t2 + i2), this.view = new n2.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(r2), this.offset = 0, this.parentOffset = (a2 || 0) + t2;
  }
  return hasRequiredDomBufferstream = 1, e4.prototype = { setBigEndian: function(e5) {
    this.littleEndian = !e5;
  }, nextUInt8: function() {
    var e5 = this.view.getUint8(this.offset);
    return this.offset += 1, e5;
  }, nextInt8: function() {
    var e5 = this.view.getInt8(this.offset);
    return this.offset += 1, e5;
  }, nextUInt16: function() {
    var e5 = this.view.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, e5;
  }, nextUInt32: function() {
    var e5 = this.view.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e5;
  }, nextInt16: function() {
    var e5 = this.view.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e5;
  }, nextInt32: function() {
    var e5 = this.view.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e5;
  }, nextFloat: function() {
    var e5 = this.view.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e5;
  }, nextDouble: function() {
    var e5 = this.view.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e5;
  }, nextBuffer: function(e5) {
    var t2 = this.arrayBuffer.slice(this.offset, this.offset + e5);
    return this.offset += e5, t2;
  }, remainingLength: function() {
    return this.arrayBuffer.byteLength - this.offset;
  }, nextString: function(e5) {
    var t2 = this.arrayBuffer.slice(this.offset, this.offset + e5);
    return t2 = String.fromCharCode.apply(null, new this.global.Uint8Array(t2)), this.offset += e5, t2;
  }, mark: function() {
    var t2 = this;
    return { openWithOffset: function(i2) {
      return i2 = (i2 || 0) + this.offset, new e4(t2.arrayBuffer, i2, t2.arrayBuffer.byteLength - i2, !t2.littleEndian, t2.global, t2.parentOffset);
    }, offset: this.offset, getParentOffset: function() {
      return t2.parentOffset;
    } };
  }, offsetFrom: function(e5) {
    return this.parentOffset + this.offset - (e5.offset + e5.getParentOffset());
  }, skip: function(e5) {
    this.offset += e5;
  }, branch: function(t2, i2) {
    return i2 = "number" == typeof i2 ? i2 : this.arrayBuffer.byteLength - (this.offset + t2), new e4(this.arrayBuffer, this.offset + t2, i2, !this.littleEndian, this.global, this.parentOffset);
  } }, domBufferstream = e4;
}
function requireBufferstream() {
  if (hasRequiredBufferstream)
    return bufferstream;
  function e4(e5, t2, i2, r2) {
    this.buffer = e5, this.offset = t2 || 0, i2 = "number" == typeof i2 ? i2 : e5.length, this.endPosition = this.offset + i2, this.setBigEndian(r2);
  }
  return hasRequiredBufferstream = 1, e4.prototype = { setBigEndian: function(e5) {
    this.bigEndian = !!e5;
  }, nextUInt8: function() {
    var e5 = this.buffer.readUInt8(this.offset);
    return this.offset += 1, e5;
  }, nextInt8: function() {
    var e5 = this.buffer.readInt8(this.offset);
    return this.offset += 1, e5;
  }, nextUInt16: function() {
    var e5 = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
    return this.offset += 2, e5;
  }, nextUInt32: function() {
    var e5 = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, e5;
  }, nextInt16: function() {
    var e5 = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
    return this.offset += 2, e5;
  }, nextInt32: function() {
    var e5 = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
    return this.offset += 4, e5;
  }, nextFloat: function() {
    var e5 = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
    return this.offset += 4, e5;
  }, nextDouble: function() {
    var e5 = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
    return this.offset += 8, e5;
  }, nextBuffer: function(e5) {
    var t2 = this.buffer.slice(this.offset, this.offset + e5);
    return this.offset += e5, t2;
  }, remainingLength: function() {
    return this.endPosition - this.offset;
  }, nextString: function(e5) {
    var t2 = this.buffer.toString("utf8", this.offset, this.offset + e5);
    return this.offset += e5, t2;
  }, mark: function() {
    var t2 = this;
    return { openWithOffset: function(i2) {
      return i2 = (i2 || 0) + this.offset, new e4(t2.buffer, i2, t2.endPosition - i2, t2.bigEndian);
    }, offset: this.offset };
  }, offsetFrom: function(e5) {
    return this.offset - e5.offset;
  }, skip: function(e5) {
    this.offset += e5;
  }, branch: function(t2, i2) {
    return i2 = "number" == typeof i2 ? i2 : this.endPosition - (this.offset + t2), new e4(this.buffer, this.offset + t2, i2, this.bigEndian);
  } }, bufferstream = e4;
}
var Parser = parser;
function getGlobal() {
  return (0, eval)("this");
}
var exifParser = { create: function(e4, t2) {
  if (e4 instanceof (t2 = t2 || getGlobal()).ArrayBuffer) {
    var i2 = requireDomBufferstream();
    return new Parser(new i2(e4, 0, e4.byteLength, true, t2));
  }
  var r2 = requireBufferstream();
  return new Parser(new r2(e4, 0, e4.length, true));
} };
var EXIFParser = getDefaultExportFromCjs(exifParser);
function getExifOrientation(e4) {
  const t2 = e4._exif;
  return t2 && t2.tags && t2.tags.Orientation || 1;
}
function getExifOrientationTransformation(e4) {
  const t2 = e4.bitmap.width, i2 = e4.bitmap.height;
  switch (getExifOrientation(e4)) {
    case 1:
    default:
      return null;
    case 2:
      return function(e5, i3) {
        return [t2 - e5 - 1, i3];
      };
    case 3:
      return function(e5, r2) {
        return [t2 - e5 - 1, i2 - r2 - 1];
      };
    case 4:
      return function(e5, t3) {
        return [e5, i2 - t3 - 1];
      };
    case 5:
      return function(e5, t3) {
        return [t3, e5];
      };
    case 6:
      return function(e5, t3) {
        return [t3, i2 - e5 - 1];
      };
    case 7:
      return function(e5, r2) {
        return [t2 - r2 - 1, i2 - e5 - 1];
      };
    case 8:
      return function(e5, i3) {
        return [t2 - i3 - 1, e5];
      };
  }
}
function transformBitmap(e4, t2, i2, r2) {
  const n2 = e4.bitmap.data, a2 = e4.bitmap.width, o2 = Buffer2.alloc(n2.length);
  for (let e5 = 0; e5 < t2; e5++)
    for (let s2 = 0; s2 < i2; s2++) {
      const [i3, l2] = r2(e5, s2), u2 = t2 * s2 + e5 << 2, h2 = a2 * l2 + i3 << 2, c2 = n2.readUInt32BE(h2);
      o2.writeUInt32BE(c2, u2);
    }
  e4.bitmap.data = o2, e4.bitmap.width = t2, e4.bitmap.height = i2, e4._exif.tags.Orientation = 1;
}
function exifRotate(e4) {
  if (getExifOrientation(e4) < 2)
    return;
  const t2 = getExifOrientationTransformation(e4), i2 = getExifOrientation(e4) > 4, r2 = i2 ? e4.bitmap.height : e4.bitmap.width, n2 = i2 ? e4.bitmap.width : e4.bitmap.height;
  t2 && transformBitmap(e4, r2, n2, t2);
}
async function attemptExifRotate(e4, t2) {
  try {
    e4._exif = EXIFParser.create(t2).parse(), exifRotate(e4);
  } catch (e5) {
  }
}
var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (e4, t2, i2) => t2 in e4 ? __defProp$2(e4, t2, { enumerable: true, configurable: true, writable: true, value: i2 }) : e4[t2] = i2;
var __publicField$2 = (e4, t2, i2) => __defNormalProp$2(e4, "symbol" != typeof t2 ? t2 + "" : t2, i2);
var emptyBitmap = { data: Buffer2.alloc(0), width: 0, height: 0 };
function bufferFromArrayBuffer(e4) {
  const t2 = Buffer2.alloc(e4.byteLength), i2 = new Uint8Array(e4);
  for (let e5 = 0; e5 < t2.length; ++e5)
    t2[e5] = i2[e5];
  return t2;
}
function createJimp({ plugins: e4, formats: t2 } = {}) {
  const i2 = e4 || [], r2 = (t2 || []).map((e5) => e5()), n2 = class {
    constructor(e5 = emptyBitmap) {
      if (__publicField$2(this, "bitmap", emptyBitmap), __publicField$2(this, "background", 0), __publicField$2(this, "formats", []), __publicField$2(this, "mime"), this.formats = r2, "data" in e5)
        this.bitmap = e5;
      else if (this.bitmap = { data: Buffer2.alloc(e5.width * e5.height * 4), width: e5.width, height: e5.height }, e5.color) {
        this.background = "string" == typeof e5.color ? cssColorToHex(e5.color) : e5.color;
        for (let e6 = 0; e6 < this.bitmap.data.length; e6 += 4)
          this.bitmap.data.writeUInt32BE(this.background, e6);
      }
      for (const e6 of i2)
        for (const t3 in e6)
          this[t3] = (...i3) => {
            var _a;
            const r3 = (_a = e6[t3]) == null ? void 0 : _a.call(e6, this, ...i3);
            return "object" == typeof r3 && "bitmap" in r3 ? (this.bitmap = r3.bitmap, this) : r3;
          };
    }
    static async read(e5, t3) {
      if (Buffer2.isBuffer(e5) || e5 instanceof ArrayBuffer)
        return this.fromBuffer(e5);
      const [i3, r3] = await to(fetch(e5));
      if (i3)
        throw new Error(`Could not load Buffer from URL: ${e5}`);
      if (!r3.ok)
        throw new Error(`HTTP Status ${r3.status} for url ${e5}`);
      const [n3, a2] = await to(r3.arrayBuffer());
      if (n3)
        throw new Error(`Could not load Buffer from ${e5}`);
      const o2 = bufferFromArrayBuffer(a2);
      return this.fromBuffer(o2, t3);
    }
    static fromBitmap(e5) {
      let t3;
      if (e5.data instanceof Buffer2 && (t3 = Buffer2.from(e5.data)), (e5.data instanceof Uint8Array || e5.data instanceof Uint8ClampedArray) && (t3 = Buffer2.from(e5.data.buffer)), Array.isArray(e5.data) && (t3 = Buffer2.concat(e5.data.map((e6) => Buffer2.from(e6.toString(16).padStart(8, "0"), "hex")))), !t3)
        throw new Error("data must be a Buffer");
      if ("number" != typeof e5.height || "number" != typeof e5.width)
        throw new Error("bitmap must have width and height");
      return new n2({ height: e5.height, width: e5.width, data: t3 });
    }
    static async fromBuffer(e5, t3) {
      const i3 = e5 instanceof ArrayBuffer ? bufferFromArrayBuffer(e5) : e5, a2 = await fileType$1.fromBuffer(i3);
      if (!a2 || !a2.mime)
        throw new Error("Could not find MIME for Buffer");
      const o2 = r2.find((e6) => e6.mime === a2.mime);
      if (!o2 || !o2.decode)
        throw new Error(`Mime type ${a2.mime} does not support decoding`);
      const s2 = new n2(await o2.decode(i3, t3 == null ? void 0 : t3[o2.mime]));
      return s2.mime = a2.mime, attemptExifRotate(s2, i3), s2;
    }
    inspect() {
      return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
    }
    toString() {
      return "[object Jimp]";
    }
    get width() {
      return this.bitmap.width;
    }
    get height() {
      return this.bitmap.height;
    }
    async getBuffer(e5, t3) {
      const i3 = this.formats.find((t4) => t4.mime === e5);
      if (!i3 || !i3.encode)
        throw new Error(`Unsupported MIME type: ${e5}`);
      let r3;
      return i3.hasAlpha ? r3 = this : (r3 = new n2({ width: this.bitmap.width, height: this.bitmap.height, color: this.background }), composite(r3, this)), i3.encode(r3.bitmap, t3);
    }
    async getBase64(e5, t3) {
      return "data:" + e5 + ";base64," + (await this.getBuffer(e5, t3)).toString("base64");
    }
    async write(e5, t3) {
      const i3 = mime.getType(e5);
      await writeFile(e5, await this.getBuffer(i3, t3));
    }
    clone() {
      return new n2({ ...this.bitmap, data: Buffer2.from(this.bitmap.data) });
    }
    getPixelIndex(e5, t3, i3) {
      let r3, n3;
      if (i3 || (i3 = Edge.EXTEND), "number" != typeof e5 || "number" != typeof t3)
        throw new Error("x and y must be numbers");
      r3 = e5 = Math.round(e5), n3 = t3 = Math.round(t3), i3 === Edge.EXTEND && (e5 < 0 && (r3 = 0), e5 >= this.bitmap.width && (r3 = this.bitmap.width - 1), t3 < 0 && (n3 = 0), t3 >= this.bitmap.height && (n3 = this.bitmap.height - 1)), i3 === Edge.WRAP && (e5 < 0 && (r3 = this.bitmap.width + e5), e5 >= this.bitmap.width && (r3 = e5 % this.bitmap.width), t3 < 0 && (n3 = this.bitmap.height + t3), t3 >= this.bitmap.height && (n3 = t3 % this.bitmap.height));
      let a2 = this.bitmap.width * n3 + r3 << 2;
      return (r3 < 0 || r3 >= this.bitmap.width) && (a2 = -1), (n3 < 0 || n3 >= this.bitmap.height) && (a2 = -1), a2;
    }
    getPixelColor(e5, t3) {
      if ("number" != typeof e5 || "number" != typeof t3)
        throw new Error("x and y must be numbers");
      const i3 = this.getPixelIndex(e5, t3);
      return this.bitmap.data.readUInt32BE(i3);
    }
    setPixelColor(e5, t3, i3) {
      if ("number" != typeof e5 || "number" != typeof t3 || "number" != typeof i3)
        throw new Error("hex, x and y must be numbers");
      const r3 = this.getPixelIndex(t3, i3);
      return this.bitmap.data.writeUInt32BE(e5, r3), this;
    }
    hasAlpha() {
      const { width: e5, height: t3, data: i3 } = this.bitmap, r3 = e5 * t3 << 2;
      for (let e6 = 3; e6 < r3; e6 += 4)
        if (255 !== i3[e6])
          return true;
      return false;
    }
    composite(e5, t3 = 0, i3 = 0, r3 = {}) {
      return composite(this, e5, t3, i3, r3);
    }
    scan(e5, t3, i3, r3, n3) {
      return scan(this, e5, t3, i3, r3, n3);
    }
    scanIterator(e5 = 0, t3 = 0, i3 = this.bitmap.width, r3 = this.bitmap.height) {
      if ("number" != typeof e5 || "number" != typeof t3)
        throw new Error("x and y must be numbers");
      if ("number" != typeof i3 || "number" != typeof r3)
        throw new Error("w and h must be numbers");
      return scanIterator(this, e5, t3, i3, r3);
    }
  };
  return n2;
}
var ResizeStrategy;
var ResizeStrategy2;
function Resize(e4, t2, i2, r2, n2, a2, o2) {
  this.widthOriginal = Math.abs(Math.floor(e4) || 0), this.heightOriginal = Math.abs(Math.floor(t2) || 0), this.targetWidth = Math.abs(Math.floor(i2) || 0), this.targetHeight = Math.abs(Math.floor(r2) || 0), this.colorChannels = n2 ? 4 : 3, this.interpolationPass = Boolean(a2), this.resizeCallback = "function" == typeof o2 ? o2 : function() {
  }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
}
ResizeStrategy2 = ResizeStrategy || (ResizeStrategy = {}), ResizeStrategy2.NEAREST_NEIGHBOR = "nearestNeighbor", ResizeStrategy2.BILINEAR = "bilinearInterpolation", ResizeStrategy2.BICUBIC = "bicubicInterpolation", ResizeStrategy2.HERMITE = "hermiteInterpolation", ResizeStrategy2.BEZIER = "bezierInterpolation", Resize.prototype.initialize = function() {
  if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0))
    throw console.log(this), new Error("Invalid settings specified for the resizer.");
  this.configurePasses();
}, Resize.prototype.configurePasses = function() {
  this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(true), this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(false), this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(true), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(false), this.resizeHeight = 4 === this.colorChannels ? this.resizeHeightRGBA : this.resizeHeightRGB));
}, Resize.prototype._resizeWidthInterpolatedRGBChannels = function(e4, t2) {
  const i2 = t2 ? 4 : 3, r2 = this.ratioWeightWidthPass, n2 = this.widthBuffer;
  let a2, o2, s2 = 0, l2 = 0, u2 = 0, h2 = 0, c2 = 0;
  for (a2 = 0; s2 < 1 / 3; a2 += i2, s2 += r2)
    for (l2 = a2, u2 = 0; l2 < this.widthPassResultSize; u2 += this.originalWidthMultipliedByChannels, l2 += this.targetWidthMultipliedByChannels)
      n2[l2] = e4[u2], n2[l2 + 1] = e4[u2 + 1], n2[l2 + 2] = e4[u2 + 2], t2 && (n2[l2 + 3] = e4[u2 + 3]);
  for (s2 -= 1 / 3, o2 = this.widthOriginal - 1; s2 < o2; a2 += i2, s2 += r2)
    for (c2 = s2 % 1, h2 = 1 - c2, l2 = a2, u2 = Math.floor(s2) * i2; l2 < this.widthPassResultSize; u2 += this.originalWidthMultipliedByChannels, l2 += this.targetWidthMultipliedByChannels)
      n2[l2 + 0] = e4[u2 + 0] * h2 + e4[u2 + i2 + 0] * c2, n2[l2 + 1] = e4[u2 + 1] * h2 + e4[u2 + i2 + 1] * c2, n2[l2 + 2] = e4[u2 + 2] * h2 + e4[u2 + i2 + 2] * c2, t2 && (n2[l2 + 3] = e4[u2 + 3] * h2 + e4[u2 + i2 + 3] * c2);
  for (o2 = this.originalWidthMultipliedByChannels - i2; a2 < this.targetWidthMultipliedByChannels; a2 += i2)
    for (l2 = a2, u2 = o2; l2 < this.widthPassResultSize; u2 += this.originalWidthMultipliedByChannels, l2 += this.targetWidthMultipliedByChannels)
      n2[l2] = e4[u2], n2[l2 + 1] = e4[u2 + 1], n2[l2 + 2] = e4[u2 + 2], t2 && (n2[l2 + 3] = e4[u2 + 3]);
  return n2;
}, Resize.prototype._resizeWidthRGBChannels = function(e4, t2) {
  const i2 = t2 ? 4 : 3, r2 = this.ratioWeightWidthPass, n2 = 1 / r2, a2 = this.originalWidthMultipliedByChannels - i2 + 1, o2 = this.targetWidthMultipliedByChannels - i2 + 1, s2 = this.outputWidthWorkBench, l2 = this.widthBuffer, u2 = this.outputWidthWorkBenchOpaquePixelsCount;
  let h2 = 0, c2 = 0, f2 = 0, d = 0, p2 = 0, m = 0, _2 = 0, g = 1, b2 = 0, y2 = 0, w = 0, v2 = 0;
  do {
    for (p2 = 0; p2 < this.originalHeightMultipliedByChannels; )
      s2[p2++] = 0, s2[p2++] = 0, s2[p2++] = 0, t2 && (s2[p2++] = 0, u2[p2 / i2 - 1] = 0);
    h2 = r2;
    do {
      for (c2 = 1 + f2 - d, g = Math.min(h2, c2), p2 = 0, m = f2; p2 < this.originalHeightMultipliedByChannels; m += a2)
        b2 = e4[m], y2 = e4[++m], w = e4[++m], v2 = t2 ? e4[++m] : 255, s2[p2++] += (v2 ? b2 : 0) * g, s2[p2++] += (v2 ? y2 : 0) * g, s2[p2++] += (v2 ? w : 0) * g, t2 && (s2[p2++] += v2 * g, u2[p2 / i2 - 1] += v2 ? g : 0);
      if (!(h2 >= c2)) {
        d += h2;
        break;
      }
      f2 += i2, d = f2, h2 -= c2;
    } while (h2 > 0 && f2 < this.originalWidthMultipliedByChannels);
    for (p2 = 0, m = _2; p2 < this.originalHeightMultipliedByChannels; m += o2)
      h2 = t2 ? u2[p2 / i2] : 1, g = t2 ? h2 ? 1 / h2 : 0 : n2, l2[m] = s2[p2++] * g, l2[++m] = s2[p2++] * g, l2[++m] = s2[p2++] * g, t2 && (l2[++m] = s2[p2++] * n2);
    _2 += i2;
  } while (_2 < this.targetWidthMultipliedByChannels);
  return l2;
}, Resize.prototype._resizeHeightRGBChannels = function(e4, t2) {
  const i2 = this.ratioWeightHeightPass, r2 = 1 / i2, n2 = this.outputHeightWorkBench, a2 = this.heightBuffer, o2 = this.outputHeightWorkBenchOpaquePixelsCount;
  let s2 = 0, l2 = 0, u2 = 0, h2 = 0, c2 = 0, f2 = 0, d = 0, p2 = 1, m = 0, _2 = 0, g = 0, b2 = 0;
  do {
    for (c2 = 0; c2 < this.targetWidthMultipliedByChannels; )
      n2[c2++] = 0, n2[c2++] = 0, n2[c2++] = 0, t2 && (n2[c2++] = 0, o2[c2 / 4 - 1] = 0);
    s2 = i2;
    do {
      for (l2 = 1 + u2 - h2, p2 = Math.min(s2, l2), d = u2, c2 = 0; c2 < this.targetWidthMultipliedByChannels; )
        m = e4[d++], _2 = e4[d++], g = e4[d++], b2 = t2 ? e4[d++] : 255, n2[c2++] += (b2 ? m : 0) * p2, n2[c2++] += (b2 ? _2 : 0) * p2, n2[c2++] += (b2 ? g : 0) * p2, t2 && (n2[c2++] += b2 * p2, o2[c2 / 4 - 1] += b2 ? p2 : 0);
      if (!(s2 >= l2)) {
        h2 += s2;
        break;
      }
      u2 = d, h2 = u2, s2 -= l2;
    } while (s2 > 0 && u2 < this.widthPassResultSize);
    for (c2 = 0; c2 < this.targetWidthMultipliedByChannels; )
      s2 = t2 ? o2[c2 / 4] : 1, p2 = t2 ? s2 ? 1 / s2 : 0 : r2, a2[f2++] = Math.round(n2[c2++] * p2), a2[f2++] = Math.round(n2[c2++] * p2), a2[f2++] = Math.round(n2[c2++] * p2), t2 && (a2[f2++] = Math.round(n2[c2++] * r2));
  } while (f2 < this.finalResultSize);
  return a2;
}, Resize.prototype.resizeWidthInterpolatedRGB = function(e4) {
  return this._resizeWidthInterpolatedRGBChannels(e4, false);
}, Resize.prototype.resizeWidthInterpolatedRGBA = function(e4) {
  return this._resizeWidthInterpolatedRGBChannels(e4, true);
}, Resize.prototype.resizeWidthRGB = function(e4) {
  return this._resizeWidthRGBChannels(e4, false);
}, Resize.prototype.resizeWidthRGBA = function(e4) {
  return this._resizeWidthRGBChannels(e4, true);
}, Resize.prototype.resizeHeightInterpolated = function(e4) {
  const t2 = this.ratioWeightHeightPass, i2 = this.heightBuffer;
  let r2, n2 = 0, a2 = 0, o2 = 0, s2 = 0, l2 = 0, u2 = 0, h2 = 0;
  for (; n2 < 1 / 3; n2 += t2)
    for (o2 = 0; o2 < this.targetWidthMultipliedByChannels; )
      i2[a2++] = Math.round(e4[o2++]);
  for (n2 -= 1 / 3, r2 = this.heightOriginal - 1; n2 < r2; n2 += t2)
    for (h2 = n2 % 1, u2 = 1 - h2, s2 = Math.floor(n2) * this.targetWidthMultipliedByChannels, l2 = s2 + this.targetWidthMultipliedByChannels, o2 = 0; o2 < this.targetWidthMultipliedByChannels; ++o2)
      i2[a2++] = Math.round(e4[s2++] * u2 + e4[l2++] * h2);
  for (; a2 < this.finalResultSize; )
    for (o2 = 0, s2 = r2 * this.targetWidthMultipliedByChannels; o2 < this.targetWidthMultipliedByChannels; ++o2)
      i2[a2++] = Math.round(e4[s2++]);
  return i2;
}, Resize.prototype.resizeHeightRGB = function(e4) {
  return this._resizeHeightRGBChannels(e4, false);
}, Resize.prototype.resizeHeightRGBA = function(e4) {
  return this._resizeHeightRGBChannels(e4, true);
}, Resize.prototype.resize = function(e4) {
  this.resizeCallback(this.resizeHeight(this.resizeWidth(e4)));
}, Resize.prototype.bypassResizer = function(e4) {
  return e4;
}, Resize.prototype.initializeFirstPassBuffers = function(e4) {
  this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), e4 || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
}, Resize.prototype.initializeSecondPassBuffers = function(e4) {
  this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), e4 || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
}, Resize.prototype.generateFloatBuffer = function(e4) {
  try {
    return new Float32Array(e4);
  } catch (e5) {
    return console.error(e5), [];
  }
}, Resize.prototype.generateFloat64Buffer = function(e4) {
  try {
    return new Float64Array(e4);
  } catch (e5) {
    return console.error(e5), [];
  }
}, Resize.prototype.generateUint8Buffer = function(e4) {
  try {
    return new Uint8Array(e4);
  } catch (e5) {
    return console.error(e5), [];
  }
};
var operations = { nearestNeighbor(e4, t2) {
  const i2 = e4.width, r2 = e4.height, n2 = t2.width, a2 = t2.height, o2 = e4.data, s2 = t2.data;
  for (let e5 = 0; e5 < a2; e5++)
    for (let t3 = 0; t3 < n2; t3++) {
      let l2 = 4 * (e5 * n2 + t3);
      let u2 = 4 * (Math.floor(e5 * r2 / a2) * i2 + Math.floor(t3 * i2 / n2));
      s2[l2++] = o2[u2++], s2[l2++] = o2[u2++], s2[l2++] = o2[u2++], s2[l2++] = o2[u2++];
    }
}, bilinearInterpolation(e4, t2) {
  const i2 = e4.width, r2 = e4.height, n2 = t2.width, a2 = t2.height, o2 = e4.data, s2 = t2.data, l2 = function(e5, t3, i3, r3, n3) {
    return t3 === r3 ? i3 : Math.round((e5 - t3) * n3 + (r3 - e5) * i3);
  }, u2 = function(e5, t3, r3, n3, a3, u3, h2, c2) {
    let f2 = 4 * (h2 * i2 + n3) + t3, d = 4 * (h2 * i2 + a3) + t3;
    const p2 = l2(r3, n3, o2[f2], a3, o2[d]);
    if (c2 === h2)
      s2[e5 + t3] = p2;
    else {
      f2 = 4 * (c2 * i2 + n3) + t3, d = 4 * (c2 * i2 + a3) + t3;
      const m = l2(r3, n3, o2[f2], a3, o2[d]);
      s2[e5 + t3] = l2(u3, h2, p2, c2, m);
    }
  };
  for (let e5 = 0; e5 < a2; e5++)
    for (let t3 = 0; t3 < n2; t3++) {
      const o3 = 4 * (e5 * n2 + t3), s3 = t3 * i2 / n2, l3 = Math.floor(s3), h2 = Math.min(Math.ceil(s3), i2 - 1), c2 = e5 * r2 / a2, f2 = Math.floor(c2), d = Math.min(Math.ceil(c2), r2 - 1);
      u2(o3, 0, s3, l3, h2, c2, f2, d), u2(o3, 1, s3, l3, h2, c2, f2, d), u2(o3, 2, s3, l3, h2, c2, f2, d), u2(o3, 3, s3, l3, h2, c2, f2, d);
    }
}, _interpolate2D(e4, t2, i2, r2) {
  const n2 = e4.data, a2 = t2.data, o2 = e4.width, s2 = e4.height, l2 = t2.width, u2 = t2.height, h2 = Math.max(1, Math.floor(o2 / l2)), c2 = l2 * h2, f2 = Math.max(1, Math.floor(s2 / u2)), d = u2 * f2, p2 = Buffer2.alloc(c2 * s2 * 4);
  for (let e5 = 0; e5 < s2; e5++)
    for (let t3 = 0; t3 < c2; t3++) {
      const i3 = t3 * (o2 - 1) / c2, a3 = Math.floor(i3), s3 = i3 - a3, l3 = 4 * (e5 * o2 + a3), u3 = 4 * (e5 * c2 + t3);
      for (let e6 = 0; e6 < 4; e6++) {
        const t4 = l3 + e6, i4 = a3 > 0 ? n2[t4 - 4] : 2 * n2[t4] - n2[t4 + 4], h3 = n2[t4], c3 = n2[t4 + 4], f3 = a3 < o2 - 2 ? n2[t4 + 8] : 2 * n2[t4 + 4] - n2[t4];
        p2[u3 + e6] = r2(i4, h3, c3, f3, s3);
      }
    }
  const m = Buffer2.alloc(c2 * d * 4);
  for (let e5 = 0; e5 < d; e5++)
    for (let t3 = 0; t3 < c2; t3++) {
      const i3 = e5 * (s2 - 1) / d, n3 = Math.floor(i3), a3 = i3 - n3, o3 = 4 * (n3 * c2 + t3), l3 = 4 * (e5 * c2 + t3);
      for (let e6 = 0; e6 < 4; e6++) {
        const t4 = o3 + e6, i4 = n3 > 0 ? p2[t4 - 4 * c2] : 2 * p2[t4] - p2[t4 + 4 * c2], u3 = p2[t4], h3 = p2[t4 + 4 * c2], f3 = n3 < s2 - 2 ? p2[t4 + 8 * c2] : 2 * p2[t4 + 4 * c2] - p2[t4];
        m[l3 + e6] = r2(i4, u3, h3, f3, a3);
      }
    }
  const _2 = h2 * f2;
  if (_2 > 1)
    for (let e5 = 0; e5 < u2; e5++)
      for (let t3 = 0; t3 < l2; t3++) {
        let i3 = 0, r3 = 0, n3 = 0, o3 = 0, s3 = 0;
        for (let a3 = 0; a3 < f2; a3++) {
          const l3 = e5 * f2 + a3;
          for (let e6 = 0; e6 < h2; e6++) {
            const a4 = 4 * (l3 * c2 + (t3 * h2 + e6)), u4 = m[a4 + 3];
            u4 && (i3 += m[a4], r3 += m[a4 + 1], n3 += m[a4 + 2], s3++), o3 += u4;
          }
        }
        const u3 = 4 * (e5 * l2 + t3);
        a2[u3] = s3 ? Math.round(i3 / s3) : 0, a2[u3 + 1] = s3 ? Math.round(r3 / s3) : 0, a2[u3 + 2] = s3 ? Math.round(n3 / s3) : 0, a2[u3 + 3] = Math.round(o3 / _2);
      }
  else
    t2.data = m;
}, bicubicInterpolation(e4, t2, i2) {
  return this._interpolate2D(e4, t2, i2, function(e5, t3, i3, r2, n2) {
    const a2 = r2 - i3 - e5 + t3, o2 = e5 - t3 - a2, s2 = i3 - e5, l2 = t3;
    return Math.max(0, Math.min(255, a2 * (n2 * n2 * n2) + o2 * (n2 * n2) + s2 * n2 + l2));
  });
}, hermiteInterpolation(e4, t2, i2) {
  return this._interpolate2D(e4, t2, i2, function(e5, t3, i3, r2, n2) {
    const a2 = t3, o2 = 0.5 * (i3 - e5), s2 = e5 - 2.5 * t3 + 2 * i3 - 0.5 * r2, l2 = 0.5 * (r2 - e5) + 1.5 * (t3 - i3);
    return Math.max(0, Math.min(255, Math.round(((l2 * n2 + s2) * n2 + o2) * n2 + a2)));
  });
}, bezierInterpolation(e4, t2, i2) {
  return this._interpolate2D(e4, t2, i2, function(e5, t3, i3, r2, n2) {
    const a2 = 1 - n2, o2 = t3 * a2 * a2 * a2, s2 = 3 * (t3 + (i3 - e5) / 4) * a2 * a2 * n2, l2 = 3 * (i3 - (r2 - t3) / 4) * a2 * n2 * n2, u2 = i3 * n2 * n2 * n2;
    return Math.max(0, Math.min(255, Math.round(o2 + s2 + l2 + u2)));
  });
} };
var ResizeOptionsSchema = z.union([z.object({ w: z.number().min(0), h: z.number().min(0).optional(), mode: z.nativeEnum(ResizeStrategy).optional() }), z.object({ w: z.number().min(0).optional(), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() })]);
var ScaleToFitOptionsSchema = z.object({ w: z.number().min(0), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() });
var ScaleComplexOptionsSchema = z.object({ f: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() });
var methods$d = { resize(e4, t2) {
  var _a, _b;
  const { mode: i2 } = ResizeOptionsSchema.parse(t2);
  let r2, n2;
  if ("number" == typeof t2.w)
    r2 = t2.w, n2 = (_a = t2.h) != null ? _a : e4.bitmap.height * (r2 / e4.bitmap.width);
  else {
    if ("number" != typeof t2.h)
      throw new Error("w must be a number");
    n2 = t2.h, r2 = (_b = t2.w) != null ? _b : e4.bitmap.width * (n2 / e4.bitmap.height);
  }
  if (r2 = Math.round(r2) || 1, n2 = Math.round(n2) || 1, i2 && "function" == typeof operations[i2]) {
    const t3 = { data: Buffer2.alloc(r2 * n2 * 4), width: r2, height: n2 };
    operations[i2](e4.bitmap, t3), e4.bitmap = t3;
  } else {
    new Resize(e4.bitmap.width, e4.bitmap.height, r2, n2, true, true, (t3) => {
      e4.bitmap.data = Buffer2.from(t3), e4.bitmap.width = r2, e4.bitmap.height = n2;
    }).resize(e4.bitmap.data);
  }
  return e4;
}, scale(e4, t2) {
  const { f: i2, mode: r2 } = "number" == typeof t2 ? { f: t2 } : ScaleComplexOptionsSchema.parse(t2), n2 = e4.bitmap.width * i2, a2 = e4.bitmap.height * i2;
  return this.resize(e4, { w: n2, h: a2, mode: r2 });
}, scaleToFit(e4, t2) {
  const { h: i2, w: r2, mode: n2 } = ScaleToFitOptionsSchema.parse(t2), a2 = r2 / i2 > e4.bitmap.width / e4.bitmap.height ? i2 / e4.bitmap.height : r2 / e4.bitmap.width;
  return this.scale(e4, { f: a2, mode: n2 });
} };
var ContainOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() });
var methods$c = { contain(e4, t2) {
  const { w: i2, h: r2, align: n2 = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: a2 } = ContainOptionsSchema.parse(t2), o2 = 7 & n2, s2 = n2 >> 3;
  if ((0 === o2 || o2 & o2 - 1) && (0 === s2 || s2 & s2 - 1))
    throw new Error("only use one flag per alignment direction");
  const l2 = o2 >> 1, u2 = s2 >> 1, h2 = i2 / r2 > e4.bitmap.width / e4.bitmap.height ? r2 / e4.bitmap.height : i2 / e4.bitmap.width, c2 = methods$d.scale(clone(e4), { f: h2, mode: a2 });
  return (e4 = methods$d.resize(e4, { w: i2, h: r2, mode: a2 })).scan((t3, i3, r3) => {
    e4.bitmap.data.writeUInt32BE(e4.background, r3);
  }), e4 = methods$h.blit(e4, { src: c2, x: (e4.bitmap.width - c2.bitmap.width) / 2 * l2, y: (e4.bitmap.height - c2.bitmap.height) / 2 * u2 });
} };
var CropOptionsSchema = z.object({ x: z.number(), y: z.number(), w: z.number(), h: z.number() });
var AutocropComplexOptionsSchema = z.object({ tolerance: z.number().min(0).max(1).optional(), cropOnlyFrames: z.boolean().optional(), cropSymmetric: z.boolean().optional(), leaveBorder: z.number().optional(), ignoreSides: z.object({ north: z.boolean().optional(), south: z.boolean().optional(), east: z.boolean().optional(), west: z.boolean().optional() }).optional() });
var methods$b = { crop(e4, t2) {
  let { x: i2, y: r2, w: n2, h: a2 } = CropOptionsSchema.parse(t2);
  if (i2 = Math.round(i2), r2 = Math.round(r2), n2 = Math.round(n2), a2 = Math.round(a2), 0 === i2 && n2 === e4.bitmap.width) {
    const t3 = n2 * r2 + i2 << 2, o2 = t3 + (a2 * n2 << 2);
    e4.bitmap.data = e4.bitmap.data.slice(t3, o2);
  } else {
    const t3 = Buffer2.allocUnsafe(n2 * a2 * 4);
    let o2 = 0;
    scan(e4, i2, r2, n2, a2, function(i3, r3, n3) {
      const a3 = e4.bitmap.data.readUInt32BE(n3);
      t3.writeUInt32BE(a3, o2), o2 += 4;
    }), e4.bitmap.data = t3;
  }
  return e4.bitmap.width = n2, e4.bitmap.height = a2, e4;
}, autocrop(e4, t2 = {}) {
  const { tolerance: i2 = 2e-4, cropOnlyFrames: r2 = true, cropSymmetric: n2 = false, leaveBorder: a2 = 0, ignoreSides: o2 } = "number" == typeof t2 ? { tolerance: t2 } : AutocropComplexOptionsSchema.parse(t2), s2 = e4.bitmap.width, l2 = e4.bitmap.height, u2 = { north: false, south: false, east: false, west: false, ...o2 };
  let h2 = e4.getPixelColor(0, 0);
  const c2 = intToRGBA$1(h2);
  let f2 = 0, d = 0, p2 = 0, m = 0;
  if (h2 = e4.getPixelColor(0, 0), !u2.north)
    e:
      for (let t3 = 0; t3 < l2 - 1; t3++) {
        for (let r3 = 0; r3 < s2; r3++) {
          if (colorDiff(c2, intToRGBA$1(e4.getPixelColor(r3, t3))) > i2)
            break e;
        }
        f2++;
      }
  if (h2 = e4.getPixelColor(s2, 0), !u2.west)
    e:
      for (let t3 = 0; t3 < s2 - 1; t3++) {
        for (let r3 = 0 + f2; r3 < l2; r3++) {
          if (colorDiff(c2, intToRGBA$1(e4.getPixelColor(t3, r3))) > i2)
            break e;
        }
        m++;
      }
  if (h2 = e4.getPixelColor(0, l2), !u2.south)
    e:
      for (let t3 = l2 - 1; t3 >= f2 + 1; t3--) {
        for (let r3 = s2 - d - 1; r3 >= 0; r3--) {
          if (colorDiff(c2, intToRGBA$1(e4.getPixelColor(r3, t3))) > i2)
            break e;
        }
        p2++;
      }
  if (h2 = e4.getPixelColor(s2, l2), !u2.east)
    e:
      for (let t3 = s2 - 1; t3 >= 0 + m + 1; t3--) {
        for (let r3 = l2 - 1; r3 >= 0 + f2; r3--) {
          if (colorDiff(c2, intToRGBA$1(e4.getPixelColor(t3, r3))) > i2)
            break e;
        }
        d++;
      }
  let _2 = false;
  if (m -= a2, d -= a2, f2 -= a2, p2 -= a2, n2) {
    const e5 = Math.min(d, m), t3 = Math.min(f2, p2);
    m = e5, d = e5, f2 = t3, p2 = t3;
  }
  m = m >= 0 ? m : 0, d = d >= 0 ? d : 0, f2 = f2 >= 0 ? f2 : 0, p2 = p2 >= 0 ? p2 : 0;
  const g = s2 - (m + d), b2 = l2 - (p2 + f2);
  return _2 = r2 ? 0 !== d && 0 !== f2 && 0 !== m && 0 !== p2 : 0 !== d || 0 !== f2 || 0 !== m || 0 !== p2, _2 && this.crop(e4, { x: m, y: f2, w: g, h: b2 }), e4;
} };
var CoverOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() });
var methods$a = { cover(e4, t2) {
  const { w: i2, h: r2, align: n2 = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: a2 } = CoverOptionsSchema.parse(t2), o2 = 7 & n2, s2 = n2 >> 3;
  if ((0 === o2 || o2 & o2 - 1) && (0 === s2 || s2 & s2 - 1))
    throw new Error("only use one flag per alignment direction");
  const l2 = o2 >> 1, u2 = s2 >> 1, h2 = i2 / r2 > e4.bitmap.width / e4.bitmap.height ? i2 / e4.bitmap.width : r2 / e4.bitmap.height;
  return e4 = methods$d.scale(e4, { f: h2, mode: a2 }), e4 = methods$b.crop(e4, { x: (e4.bitmap.width - i2) / 2 * l2, y: (e4.bitmap.height - r2) / 2 * u2, w: i2, h: r2 });
} };
var DisplaceOptionsSchema = z.object({ map: JimpClassSchema, offset: z.number() });
var methods$9 = { displace(e4, t2) {
  const { map: i2, offset: r2 } = DisplaceOptionsSchema.parse(t2), n2 = clone(e4);
  return e4.scan((t3, a2, o2) => {
    let s2 = i2.bitmap.data[o2] / 256 * r2;
    s2 = Math.round(s2);
    const l2 = e4.getPixelIndex(t3 + s2, a2);
    e4.bitmap.data[l2] = n2.bitmap.data[o2], e4.bitmap.data[l2 + 1] = n2.bitmap.data[o2 + 1], e4.bitmap.data[l2 + 2] = n2.bitmap.data[o2 + 2];
  }), e4;
} };
var methods$8 = { dither(e4) {
  const t2 = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
  return e4.scan((i2, r2, n2) => {
    const a2 = t2[((3 & r2) << 2) + i2 % 4];
    e4.bitmap.data[n2] = Math.min(e4.bitmap.data[n2] + a2, 255), e4.bitmap.data[n2 + 1] = Math.min(e4.bitmap.data[n2 + 1] + a2, 255), e4.bitmap.data[n2 + 2] = Math.min(e4.bitmap.data[n2 + 2] + a2, 255);
  }), e4;
} };
var FisheyeOptionsSchema = z.object({ radius: z.number().min(0).optional() });
var methods$7 = { fisheye(e4, t2 = {}) {
  const { radius: i2 = 2.5 } = FisheyeOptionsSchema.parse(t2), r2 = clone(e4), { width: n2, height: a2 } = r2.bitmap;
  return r2.scan((t3, o2) => {
    const s2 = t3 / n2, l2 = o2 / a2, u2 = Math.sqrt(Math.pow(s2 - 0.5, 2) + Math.pow(l2 - 0.5, 2)), h2 = 2 * Math.pow(u2, i2), c2 = (s2 - 0.5) / u2, f2 = (l2 - 0.5) / u2, d = Math.round((h2 * c2 + 0.5) * n2), p2 = Math.round((h2 * f2 + 0.5) * a2), m = r2.getPixelColor(d, p2);
    e4.setPixelColor(m, t3, o2);
  }), e4.setPixelColor(r2.getPixelColor(n2 / 2, a2 / 2), n2 / 2, a2 / 2), e4;
} };
var FlipOptionsSchema = z.object({ horizontal: z.boolean().optional(), vertical: z.boolean().optional() });
var methods$6 = { flip(e4, t2) {
  const { horizontal: i2, vertical: r2 } = FlipOptionsSchema.parse(t2), n2 = Buffer2.alloc(e4.bitmap.data.length);
  return e4.scan((t3, a2, o2) => {
    const s2 = i2 ? e4.bitmap.width - 1 - t3 : t3, l2 = r2 ? e4.bitmap.height - 1 - a2 : a2, u2 = e4.bitmap.width * l2 + s2 << 2, h2 = e4.bitmap.data.readUInt32BE(o2);
    n2.writeUInt32BE(h2, u2);
  }), e4.bitmap.data = Buffer2.from(n2), e4;
} };
function Converter$1(e4, t2) {
  if (!(e4 && t2 && e4.length && t2.length))
    throw new Error("Bad alphabet");
  this.srcAlphabet = e4, this.dstAlphabet = t2;
}
Converter$1.prototype.convert = function(e4) {
  var t2, i2, r2, n2 = {}, a2 = this.srcAlphabet.length, o2 = this.dstAlphabet.length, s2 = e4.length, l2 = "string" == typeof e4 ? "" : [];
  if (!this.isValid(e4))
    throw new Error('Number "' + e4 + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
  if (this.srcAlphabet === this.dstAlphabet)
    return e4;
  for (t2 = 0; t2 < s2; t2++)
    n2[t2] = this.srcAlphabet.indexOf(e4[t2]);
  do {
    for (i2 = 0, r2 = 0, t2 = 0; t2 < s2; t2++)
      (i2 = i2 * a2 + n2[t2]) >= o2 ? (n2[r2++] = parseInt(i2 / o2, 10), i2 %= o2) : r2 > 0 && (n2[r2++] = 0);
    s2 = r2, l2 = this.dstAlphabet.slice(i2, i2 + 1).concat(l2);
  } while (0 !== r2);
  return l2;
}, Converter$1.prototype.isValid = function(e4) {
  for (var t2 = 0; t2 < e4.length; ++t2)
    if (-1 === this.srcAlphabet.indexOf(e4[t2]))
      return false;
  return true;
};
var converter = Converter$1;
var Converter = converter;
function anyBase(e4, t2) {
  var i2 = new Converter(e4, t2);
  return function(e5) {
    return i2.convert(e5);
  };
}
anyBase.BIN = "01", anyBase.OCT = "01234567", anyBase.DEC = "0123456789", anyBase.HEX = "0123456789abcdef";
var anyBase_1 = anyBase;
var anyBase$1 = getDefaultExportFromCjs(anyBase_1);
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (e4, t2, i2) => t2 in e4 ? __defProp$1(e4, t2, { enumerable: true, configurable: true, writable: true, value: i2 }) : e4[t2] = i2;
var __publicField$1 = (e4, t2, i2) => __defNormalProp$1(e4, "symbol" != typeof t2 ? t2 + "" : t2, i2);
var ImagePHash = class {
  constructor(e4, t2) {
    __publicField$1(this, "size"), __publicField$1(this, "smallerSize"), this.size = e4 || 32, this.smallerSize = t2 || 8, initCoefficients(this.size);
  }
  distance(e4, t2) {
    let i2 = 0;
    for (let r2 = 0; r2 < e4.length; r2++)
      e4[r2] !== t2[r2] && i2++;
    return i2 / e4.length;
  }
  getHash(e4) {
    e4 = methods$d.resize(clone(e4), { w: this.size, h: this.size }), e4 = methods$e.greyscale(e4);
    const t2 = [];
    for (let i3 = 0; i3 < e4.bitmap.width; i3++) {
      const r3 = [];
      for (let t3 = 0; t3 < e4.bitmap.height; t3++)
        r3[t3] = intToRGBA(e4.getPixelColor(i3, t3)).b;
      t2[i3] = r3;
    }
    const i2 = applyDCT(t2, this.size);
    let r2 = 0;
    for (let e5 = 0; e5 < this.smallerSize; e5++)
      for (let t3 = 0; t3 < this.smallerSize; t3++)
        r2 += i2[e5][t3];
    const n2 = r2 / (this.smallerSize * this.smallerSize);
    let a2 = "";
    for (let e5 = 0; e5 < this.smallerSize; e5++)
      for (let t3 = 0; t3 < this.smallerSize; t3++)
        a2 += i2[e5][t3] > n2 ? "1" : "0";
    return a2;
  }
};
function intToRGBA(e4) {
  const t2 = 255 & e4, i2 = 255 & (e4 >>>= 8), r2 = 255 & (e4 >>>= 8);
  return { r: 255 & (e4 >>>= 8), g: r2, b: i2, a: t2 };
}
var c$1 = [];
function initCoefficients(e4) {
  for (let t2 = 1; t2 < e4; t2++)
    c$1[t2] = 1;
  c$1[0] = 1 / Math.sqrt(2);
}
function applyDCT(e4, t2) {
  const i2 = t2, r2 = [];
  for (let t3 = 0; t3 < i2; t3++) {
    const n2 = [];
    for (let a2 = 0; a2 < i2; a2++) {
      let o2 = 0;
      for (let r3 = 0; r3 < i2; r3++)
        for (let n3 = 0; n3 < i2; n3++)
          o2 += Math.cos((2 * r3 + 1) / (2 * i2) * t3 * Math.PI) * Math.cos((2 * n3 + 1) / (2 * i2) * a2 * Math.PI) * e4[r3][n3];
      o2 *= c$1[t3] * c$1[a2] / 4, n2[a2] = o2, r2[t3] = n2;
    }
  }
  return r2;
}
var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
var maxHashLength = [NaN, NaN];
for (let e4 = 2; e4 < 65; e4++) {
  const t2 = anyBase$1(anyBase$1.BIN, alphabet.slice(0, e4))(new Array(65).join("1"));
  maxHashLength.push(t2.length);
}
var methods$5 = { pHash: (e4) => new ImagePHash().getHash(e4), hash(e4, t2 = 64) {
  if (t2 < 2 || t2 > 64)
    throw new Error("base must be a number between 2 and 64");
  const i2 = alphabet.slice(0, t2), r2 = this.pHash(e4), n2 = maxHashLength[t2];
  return anyBase$1(anyBase$1.BIN, i2)(r2).padStart(n2, "0");
}, distanceFromHash(e4, t2) {
  const i2 = new ImagePHash(), r2 = i2.getHash(e4);
  return i2.distance(r2, t2);
} };
function distance(e4, t2) {
  const i2 = new ImagePHash(), r2 = i2.getHash(e4), n2 = i2.getHash(t2);
  return i2.distance(r2, n2);
}
function compareHashes(e4, t2) {
  return new ImagePHash().distance(e4, t2);
}
var MaskOptionsObjectSchema = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional() });
var MaskOptionsSchema = z.union([JimpClassSchema, MaskOptionsObjectSchema]);
var methods$4 = { mask(e4, t2) {
  var _a, _b;
  let i2, r2, n2;
  MaskOptionsSchema.parse(t2), "bitmap" in t2 ? (i2 = t2, r2 = 0, n2 = 0) : (i2 = t2.src, r2 = (_a = t2.x) != null ? _a : 0, n2 = (_b = t2.y) != null ? _b : 0), r2 = Math.round(r2), n2 = Math.round(n2);
  const a2 = e4.bitmap.width, o2 = e4.bitmap.height;
  return i2.scan(function(t3, s2, l2) {
    const u2 = r2 + t3, h2 = n2 + s2;
    if (u2 >= 0 && h2 >= 0 && u2 < a2 && h2 < o2) {
      const t4 = e4.getPixelIndex(u2, h2), { data: r3 } = i2.bitmap, n3 = (r3[l2 + 0] + r3[l2 + 1] + r3[l2 + 2]) / 3;
      e4.bitmap.data[t4 + 3] *= n3 / 255;
    }
  }), e4;
} };
function measureText(e4, t2) {
  let i2 = 0;
  for (let r2 = 0; r2 < t2.length; r2++) {
    const n2 = t2[r2], a2 = e4.chars[n2];
    if (a2) {
      const o2 = e4.kernings[n2], s2 = t2[r2 + 1], l2 = o2 && s2 && o2[s2] && o2[s2] || 0;
      i2 += (a2.xadvance || 0) + l2;
    }
  }
  return i2;
}
function splitLines(e4, t2, i2) {
  const r2 = t2.replace(/[\r\n]+/g, " \n").split(" "), n2 = [];
  let a2 = [], o2 = 0;
  return r2.forEach((t3) => {
    if (measureText(e4, t3 + (r2.length > 1 ? " " : "")) > i2) {
      const r3 = t3[Symbol.iterator]();
      let o3 = "";
      for (const t4 of r3) {
        const r4 = [...a2, o3 + t4].join(" "), s3 = measureText(e4, r4);
        s3 < i2 ? o3 += t4 : s3 > i2 ? (n2.push([...a2, o3]), a2 = [], o3 = t4) : (n2.push([...a2, o3 + t4]), a2 = [], o3 = "");
      }
      return;
    }
    const s2 = [...a2, t3].join(" "), l2 = measureText(e4, s2);
    l2 <= i2 && !t3.includes("\n") ? (l2 > o2 && (o2 = l2), a2.push(t3)) : (n2.push(a2), a2 = [t3.replace("\n", "")]);
  }), n2.push(a2), { lines: n2, longestLine: o2 };
}
function measureTextHeight(e4, t2, i2) {
  const { lines: r2 } = splitLines(e4, t2, i2);
  return r2.length * e4.common.lineHeight;
}
var PrintOptionsSchema = z.object({ x: z.number(), y: z.number(), text: z.union([z.union([z.string(), z.number()]), z.object({ text: z.union([z.string(), z.number()]), alignmentX: z.nativeEnum(HorizontalAlign).optional(), alignmentY: z.nativeEnum(VerticalAlign).optional() })]), maxWidth: z.number().optional(), maxHeight: z.number().optional(), cb: z.function(z.tuple([z.object({ x: z.number(), y: z.number() })])).optional() });
function xOffsetBasedOnAlignment(e4, t2, i2, r2) {
  return r2 === HorizontalAlign.LEFT ? 0 : r2 === HorizontalAlign.CENTER ? (i2 - measureText(e4, t2)) / 2 : i2 - measureText(e4, t2);
}
function drawCharacter(e4, t2, i2, r2, n2) {
  if (n2.width > 0 && n2.height > 0) {
    const a2 = t2.pages[n2.page];
    a2 && (e4 = methods$h.blit(e4, { src: a2, x: i2 + n2.xoffset, y: r2 + n2.yoffset, srcX: n2.x, srcY: n2.y, srcW: n2.width, srcH: n2.height }));
  }
  return e4;
}
function printText(e4, t2, i2, r2, n2, a2) {
  for (let o2 = 0; o2 < n2.length; o2++) {
    const s2 = n2[o2];
    let l2;
    l2 = t2.chars[s2] ? s2 : /\s/.test(s2) ? "" : "?";
    const u2 = t2.chars[l2] || { xadvance: void 0 }, h2 = t2.kernings[l2];
    u2 && drawCharacter(e4, t2, i2, r2, u2);
    const c2 = n2[o2 + 1];
    i2 += (h2 && c2 && h2[c2] && h2[c2] || 0) + (u2.xadvance || a2);
  }
}
var methods$3 = { print(e4, { font: t2, ...i2 }) {
  var _a;
  let r2, n2, { x: a2, y: o2, text: s2, maxWidth: l2 = 1 / 0, maxHeight: u2 = 1 / 0, cb: h2 = () => {
  } } = PrintOptionsSchema.parse(i2);
  "object" == typeof s2 && null !== s2.text && void 0 !== s2.text ? (r2 = s2.alignmentX || HorizontalAlign.LEFT, n2 = s2.alignmentY || VerticalAlign.TOP, { text: s2 } = s2) : (r2 = HorizontalAlign.LEFT, n2 = VerticalAlign.TOP, s2 = s2.toString()), "number" == typeof s2 && (s2 = s2.toString()), u2 !== 1 / 0 && n2 === VerticalAlign.BOTTOM ? o2 += u2 - measureTextHeight(t2, s2, l2) : u2 !== 1 / 0 && n2 === VerticalAlign.MIDDLE && (o2 += u2 / 2 - measureTextHeight(t2, s2, l2) / 2);
  const c2 = (_a = Object.entries(t2.chars).find((e5) => e5[1].xadvance)) == null ? void 0 : _a[1].xadvance;
  if ("number" != typeof c2)
    throw new Error("Could not find default character width");
  const { lines: f2, longestLine: d } = splitLines(t2, s2, l2);
  return f2.forEach((i3) => {
    const n3 = i3.join(" "), s3 = xOffsetBasedOnAlignment(t2, n3, l2, r2);
    printText(e4, t2, a2 + s3, o2, n3, c2), o2 += t2.common.lineHeight;
  }), h2.bind(e4)({ x: a2 + d, y: o2 }), e4;
} };
var RotateOptionsSchema = z.union([z.number(), z.object({ deg: z.number(), mode: z.union([z.boolean(), z.nativeEnum(ResizeStrategy)]).optional() })]);
function createIdxTranslationFunction(e4) {
  return function(t2, i2) {
    return i2 * e4 + t2 << 2;
  };
}
function matrixRotate(e4, t2) {
  if (Math.abs(t2) % 90 != 0)
    throw new Error("Unsupported matrix rotation degree");
  const i2 = e4.bitmap.width, r2 = e4.bitmap.height;
  let n2;
  switch (t2) {
    case 90:
    case -270:
      n2 = 90;
      break;
    case 180:
    case -180:
      n2 = 180;
      break;
    case 270:
    case -90:
      n2 = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const a2 = 180 === n2 ? i2 : r2, o2 = 180 === n2 ? r2 : i2, s2 = Buffer2.alloc(e4.bitmap.data.length), l2 = createIdxTranslationFunction(i2), u2 = createIdxTranslationFunction(a2);
  for (let t3 = 0; t3 < i2; t3++)
    for (let a3 = 0; a3 < r2; a3++) {
      const o3 = l2(t3, a3), h2 = e4.bitmap.data.readUInt32BE(o3);
      let c2;
      switch (n2) {
        case 90:
          c2 = u2(a3, i2 - t3 - 1);
          break;
        case -90:
          c2 = u2(r2 - a3 - 1, t3);
          break;
        case 180:
          c2 = u2(i2 - t3 - 1, r2 - a3 - 1);
          break;
        default:
          throw new Error("Unsupported matrix rotation angle");
      }
      s2.writeUInt32BE(h2, c2);
    }
  e4.bitmap.data = s2, e4.bitmap.width = a2, e4.bitmap.height = o2;
}
function createTranslationFunction(e4, t2) {
  return function(i2, r2) {
    return { x: i2 + e4, y: r2 + t2 };
  };
}
function advancedRotate(e4, t2, i2) {
  const r2 = t2 * Math.PI / 180, n2 = Math.cos(r2), a2 = Math.sin(r2);
  let o2 = e4.bitmap.width, s2 = e4.bitmap.height;
  if (true === i2 || "string" == typeof i2) {
    o2 = Math.ceil(Math.abs(e4.bitmap.width * n2) + Math.abs(e4.bitmap.height * a2)) + 1, s2 = Math.ceil(Math.abs(e4.bitmap.width * a2) + Math.abs(e4.bitmap.height * n2)) + 1, o2 % 2 != 0 && o2++, s2 % 2 != 0 && s2++;
    const t3 = clone(e4);
    e4.scan((t4, i3, r4) => {
      e4.bitmap.data.writeUInt32BE(e4.background, r4);
    });
    const r3 = Math.max(o2, s2, e4.bitmap.width, e4.bitmap.height);
    e4 = composite(e4 = methods$d.resize(e4, { h: r3, w: r3, mode: true === i2 ? void 0 : i2 }), t3, e4.bitmap.width / 2 - t3.bitmap.width / 2, e4.bitmap.height / 2 - t3.bitmap.height / 2);
  }
  const l2 = e4.bitmap.width, u2 = e4.bitmap.height, h2 = Buffer2.alloc(e4.bitmap.data.length), c2 = createTranslationFunction(-l2 / 2, -u2 / 2), f2 = createTranslationFunction(l2 / 2 + 0.5, u2 / 2 + 0.5);
  for (let t3 = 1; t3 <= u2; t3++)
    for (let i3 = 1; i3 <= l2; i3++) {
      const r3 = c2(i3, t3), o3 = f2(n2 * r3.x - a2 * r3.y, n2 * r3.y + a2 * r3.x), s3 = l2 * (t3 - 1) + i3 - 1 << 2;
      if (o3.x >= 0 && o3.x < l2 && o3.y >= 0 && o3.y < u2) {
        const t4 = l2 * (0 | o3.y) + o3.x << 2, i4 = e4.bitmap.data.readUInt32BE(t4);
        h2.writeUInt32BE(i4, s3);
      } else
        h2.writeUInt32BE(e4.background, s3);
    }
  if (e4.bitmap.data = h2, true === i2 || "string" == typeof i2) {
    const t3 = Math.max(l2 / 2 - o2 / 2, 0), i3 = Math.max(u2 / 2 - s2 / 2, 0);
    e4 = methods$b.crop(e4, { x: t3, y: i3, w: o2, h: s2 });
  }
}
var methods$2 = { rotate(e4, t2) {
  const i2 = RotateOptionsSchema.parse(t2), r2 = "number" == typeof i2 ? { deg: i2 } : i2, { mode: n2 = true } = r2;
  let { deg: a2 } = r2;
  if (a2 %= 360, a2 % 360 == 0)
    return e4;
  return a2 % 90 == 0 && (n2 || e4.bitmap.width === e4.bitmap.height || a2 % 180 == 0) ? matrixRotate(e4, a2) : advancedRotate(e4, a2, n2), e4;
} };
var ThresholdOptionsSchema = z.object({ max: z.number().min(0).max(255), replace: z.number().min(0).max(255).optional(), autoGreyscale: z.boolean().optional() });
var methods$1 = { threshold(e4, t2) {
  let { max: i2, replace: r2 = 255, autoGreyscale: n2 = true } = ThresholdOptionsSchema.parse(t2);
  return i2 = limit255(i2), r2 = limit255(r2), n2 && methods$e.greyscale(e4), e4.scan((t3, n3, a2) => {
    const o2 = e4.bitmap.data[a2] < i2 ? e4.bitmap.data[a2] : r2;
    e4.bitmap.data[a2] = o2, e4.bitmap.data[a2 + 1] = o2, e4.bitmap.data[a2 + 2] = o2;
  }), e4;
} };
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (e4, t2, i2) => t2 in e4 ? __defProp2(e4, t2, { enumerable: true, configurable: true, writable: true, value: i2 }) : e4[t2] = i2;
var __export2 = (e4, t2) => {
  for (var i2 in t2)
    __defProp2(e4, i2, { get: t2[i2], enumerable: true });
};
var __publicField2 = (e4, t2, i2) => (__defNormalProp2(e4, "symbol" != typeof t2 ? t2 + "" : t2, i2), i2);
var constants_exports = {};
__export2(constants_exports, { bt709: () => bt709_exports });
var bt709_exports = {};
__export2(bt709_exports, { Y: () => Y, x: () => x$1, y: () => y$1 });
var Y = ((e4) => (e4[e4.RED = 0.2126] = "RED", e4[e4.GREEN = 0.7152] = "GREEN", e4[e4.BLUE = 0.0722] = "BLUE", e4[e4.WHITE = 1] = "WHITE", e4))(Y || {});
var x$1 = ((e4) => (e4[e4.RED = 0.64] = "RED", e4[e4.GREEN = 0.3] = "GREEN", e4[e4.BLUE = 0.15] = "BLUE", e4[e4.WHITE = 0.3127] = "WHITE", e4))(x$1 || {});
var y$1 = ((e4) => (e4[e4.RED = 0.33] = "RED", e4[e4.GREEN = 0.6] = "GREEN", e4[e4.BLUE = 0.06] = "BLUE", e4[e4.WHITE = 0.329] = "WHITE", e4))(y$1 || {});
var conversion_exports = {};
function correctGamma(e4) {
  return e4 > 0.04045 ? ((e4 + 0.055) / 1.055) ** 2.4 : e4 / 12.92;
}
function rgb2xyz(e4, t2, i2) {
  return { x: 0.4124 * (e4 = correctGamma(e4 / 255)) + 0.3576 * (t2 = correctGamma(t2 / 255)) + 0.1805 * (i2 = correctGamma(i2 / 255)), y: 0.2126 * e4 + 0.7152 * t2 + 0.0722 * i2, z: 0.0193 * e4 + 0.1192 * t2 + 0.9505 * i2 };
}
__export2(conversion_exports, { lab2rgb: () => lab2rgb, lab2xyz: () => lab2xyz, rgb2hsl: () => rgb2hsl, rgb2lab: () => rgb2lab, rgb2xyz: () => rgb2xyz, xyz2lab: () => xyz2lab, xyz2rgb: () => xyz2rgb });
var arithmetic_exports = {};
function degrees2radians(e4) {
  return e4 * (Math.PI / 180);
}
function max3(e4, t2, i2) {
  let r2 = e4;
  return r2 < t2 && (r2 = t2), r2 < i2 && (r2 = i2), r2;
}
function min3(e4, t2, i2) {
  let r2 = e4;
  return r2 > t2 && (r2 = t2), r2 > i2 && (r2 = i2), r2;
}
function intInRange(e4, t2, i2) {
  return e4 > i2 && (e4 = i2), e4 < t2 && (e4 = t2), 0 | e4;
}
function inRange0to255Rounded(e4) {
  return (e4 = Math.round(e4)) > 255 ? e4 = 255 : e4 < 0 && (e4 = 0), e4;
}
function inRange0to255(e4) {
  return e4 > 255 ? e4 = 255 : e4 < 0 && (e4 = 0), e4;
}
function stableSort(e4, t2) {
  const i2 = typeof e4[0];
  let r2;
  if ("number" === i2 || "string" === i2) {
    const i3 = /* @__PURE__ */ Object.create(null);
    for (let t3 = 0, r3 = e4.length; t3 < r3; t3++) {
      const r4 = e4[t3];
      i3[r4] || 0 === i3[r4] || (i3[r4] = t3);
    }
    r2 = e4.sort((e5, r3) => t2(e5, r3) || i3[e5] - i3[r3]);
  } else {
    const i3 = e4.slice(0);
    r2 = e4.sort((e5, r3) => t2(e5, r3) || i3.indexOf(e5) - i3.indexOf(r3));
  }
  return r2;
}
function rgb2hsl(e4, t2, i2) {
  const r2 = min3(e4, t2, i2), n2 = max3(e4, t2, i2), a2 = n2 - r2, o2 = (r2 + n2) / 510;
  let s2 = 0;
  o2 > 0 && o2 < 1 && (s2 = a2 / (o2 < 0.5 ? n2 + r2 : 510 - n2 - r2));
  let l2 = 0;
  return a2 > 0 && (l2 = n2 === e4 ? (t2 - i2) / a2 : n2 === t2 ? 2 + (i2 - e4) / a2 : 4 + (e4 - t2) / a2, l2 *= 60, l2 < 0 && (l2 += 360)), { h: l2, s: s2, l: o2 };
}
__export2(arithmetic_exports, { degrees2radians: () => degrees2radians, inRange0to255: () => inRange0to255, inRange0to255Rounded: () => inRange0to255Rounded, intInRange: () => intInRange, max3: () => max3, min3: () => min3, stableSort: () => stableSort });
var refX = 0.95047;
var refY = 1;
var refZ = 1.08883;
function pivot(e4) {
  return e4 > 8856e-6 ? e4 ** (1 / 3) : 7.787 * e4 + 16 / 116;
}
function xyz2lab(e4, t2, i2) {
  if (e4 = pivot(e4 / refX), t2 = pivot(t2 / refY), i2 = pivot(i2 / refZ), 116 * t2 - 16 < 0)
    throw new Error("xxx");
  return { L: Math.max(0, 116 * t2 - 16), a: 500 * (e4 - t2), b: 200 * (t2 - i2) };
}
function rgb2lab(e4, t2, i2) {
  const r2 = rgb2xyz(e4, t2, i2);
  return xyz2lab(r2.x, r2.y, r2.z);
}
var refX2 = 0.95047;
var refY2 = 1;
var refZ2 = 1.08883;
function pivot2(e4) {
  return e4 > 0.206893034 ? e4 ** 3 : (e4 - 16 / 116) / 7.787;
}
function lab2xyz(e4, t2, i2) {
  const r2 = (e4 + 16) / 116, n2 = r2 - i2 / 200;
  return { x: refX2 * pivot2(t2 / 500 + r2), y: refY2 * pivot2(r2), z: refZ2 * pivot2(n2) };
}
function correctGamma2(e4) {
  return e4 > 31308e-7 ? 1.055 * e4 ** (1 / 2.4) - 0.055 : 12.92 * e4;
}
function xyz2rgb(e4, t2, i2) {
  const r2 = correctGamma2(3.2406 * e4 + -1.5372 * t2 + -0.4986 * i2), n2 = correctGamma2(-0.9689 * e4 + 1.8758 * t2 + 0.0415 * i2), a2 = correctGamma2(0.0557 * e4 + -0.204 * t2 + 1.057 * i2);
  return { r: inRange0to255Rounded(255 * r2), g: inRange0to255Rounded(255 * n2), b: inRange0to255Rounded(255 * a2) };
}
function lab2rgb(e4, t2, i2) {
  const r2 = lab2xyz(e4, t2, i2);
  return xyz2rgb(r2.x, r2.y, r2.z);
}
var distance_exports = {};
__export2(distance_exports, { AbstractDistanceCalculator: () => AbstractDistanceCalculator, AbstractEuclidean: () => AbstractEuclidean, AbstractManhattan: () => AbstractManhattan, CIE94GraphicArts: () => CIE94GraphicArts, CIE94Textiles: () => CIE94Textiles, CIEDE2000: () => CIEDE2000, CMetric: () => CMetric, Euclidean: () => Euclidean, EuclideanBT709: () => EuclideanBT709, EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha, Manhattan: () => Manhattan, ManhattanBT709: () => ManhattanBT709, ManhattanNommyde: () => ManhattanNommyde, PNGQuant: () => PNGQuant });
var AbstractDistanceCalculator = class {
  constructor() {
    __publicField2(this, "_maxDistance"), __publicField2(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
  }
  setWhitePoint(e4, t2, i2, r2) {
    this._whitePoint = { r: e4 > 0 ? 255 / e4 : 0, g: t2 > 0 ? 255 / t2 : 0, b: i2 > 0 ? 255 / i2 : 0, a: r2 > 0 ? 255 / r2 : 0 }, this._maxDistance = this.calculateRaw(e4, t2, i2, r2, 0, 0, 0, 0);
  }
  calculateNormalized(e4, t2) {
    return this.calculateRaw(e4.r, e4.g, e4.b, e4.a, t2.r, t2.g, t2.b, t2.a) / this._maxDistance;
  }
};
var AbstractCIE94 = class extends AbstractDistanceCalculator {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = rgb2lab(inRange0to255(e4 * this._whitePoint.r), inRange0to255(t2 * this._whitePoint.g), inRange0to255(i2 * this._whitePoint.b)), u2 = rgb2lab(inRange0to255(n2 * this._whitePoint.r), inRange0to255(a2 * this._whitePoint.g), inRange0to255(o2 * this._whitePoint.b)), h2 = l2.L - u2.L, c2 = l2.a - u2.a, f2 = l2.b - u2.b, d = Math.sqrt(l2.a * l2.a + l2.b * l2.b), p2 = d - Math.sqrt(u2.a * u2.a + u2.b * u2.b);
    let m = c2 * c2 + f2 * f2 - p2 * p2;
    m = m < 0 ? 0 : Math.sqrt(m);
    const _2 = (s2 - r2) * this._whitePoint.a * this._kA;
    return Math.sqrt((h2 / this._Kl) ** 2 + (p2 / (1 + this._K1 * d)) ** 2 + (m / (1 + this._K2 * d)) ** 2 + _2 ** 2);
  }
};
var CIE94Textiles = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
  }
};
var CIE94GraphicArts = class extends AbstractCIE94 {
  _setDefaults() {
    this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
  }
};
var _CIEDE2000 = class extends AbstractDistanceCalculator {
  _setDefaults() {
  }
  static _calculatehp(e4, t2) {
    const i2 = Math.atan2(e4, t2);
    return i2 >= 0 ? i2 : i2 + _CIEDE2000._deg360InRad;
  }
  static _calculateRT(e4, t2) {
    const i2 = t2 ** 7, r2 = 2 * Math.sqrt(i2 / (i2 + _CIEDE2000._pow25to7)), n2 = _CIEDE2000._deg30InRad * Math.exp(-(((e4 - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
    return -Math.sin(2 * n2) * r2;
  }
  static _calculateT(e4) {
    return 1 - 0.17 * Math.cos(e4 - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(2 * e4) + 0.32 * Math.cos(3 * e4 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(4 * e4 - _CIEDE2000._deg63InRad);
  }
  static _calculate_ahp(e4, t2, i2, r2) {
    const n2 = i2 + r2;
    return 0 === e4 ? n2 : t2 <= _CIEDE2000._deg180InRad ? n2 / 2 : n2 < _CIEDE2000._deg360InRad ? (n2 + _CIEDE2000._deg360InRad) / 2 : (n2 - _CIEDE2000._deg360InRad) / 2;
  }
  static _calculate_dHp(e4, t2, i2, r2) {
    let n2;
    return n2 = 0 === e4 ? 0 : t2 <= _CIEDE2000._deg180InRad ? i2 - r2 : i2 <= r2 ? i2 - r2 + _CIEDE2000._deg360InRad : i2 - r2 - _CIEDE2000._deg360InRad, 2 * Math.sqrt(e4) * Math.sin(n2 / 2);
  }
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = rgb2lab(inRange0to255(e4 * this._whitePoint.r), inRange0to255(t2 * this._whitePoint.g), inRange0to255(i2 * this._whitePoint.b)), u2 = rgb2lab(inRange0to255(n2 * this._whitePoint.r), inRange0to255(a2 * this._whitePoint.g), inRange0to255(o2 * this._whitePoint.b)), h2 = (s2 - r2) * this._whitePoint.a * _CIEDE2000._kA, c2 = this.calculateRawInLab(l2, u2);
    return Math.sqrt(c2 + h2 * h2);
  }
  calculateRawInLab(e4, t2) {
    const i2 = e4.L, r2 = e4.a, n2 = e4.b, a2 = t2.L, o2 = t2.a, s2 = t2.b, l2 = ((Math.sqrt(r2 * r2 + n2 * n2) + Math.sqrt(o2 * o2 + s2 * s2)) / 2) ** 7, u2 = 0.5 * (1 - Math.sqrt(l2 / (l2 + _CIEDE2000._pow25to7))), h2 = (1 + u2) * r2, c2 = (1 + u2) * o2, f2 = Math.sqrt(h2 * h2 + n2 * n2), d = Math.sqrt(c2 * c2 + s2 * s2), p2 = f2 * d, m = _CIEDE2000._calculatehp(n2, h2), _2 = _CIEDE2000._calculatehp(s2, c2), g = Math.abs(m - _2), b2 = a2 - i2, y2 = d - f2, w = _CIEDE2000._calculate_dHp(p2, g, _2, m), v2 = _CIEDE2000._calculate_ahp(p2, g, m, _2), x2 = (f2 + d) / 2, E2 = ((i2 + a2) / 2 - 50) ** 2, k2 = y2 / (1 + 0.045 * x2), S2 = w / (1 + 0.015 * _CIEDE2000._calculateT(v2) * x2);
    return (b2 / (1 + 0.015 * E2 / Math.sqrt(20 + E2))) ** 2 + k2 ** 2 + S2 ** 2 + _CIEDE2000._calculateRT(v2, x2) * k2 * S2;
  }
};
var CIEDE2000 = _CIEDE2000;
__publicField2(CIEDE2000, "_kA", 25 / 255), __publicField2(CIEDE2000, "_pow25to7", 25 ** 7), __publicField2(CIEDE2000, "_deg360InRad", degrees2radians(360)), __publicField2(CIEDE2000, "_deg180InRad", degrees2radians(180)), __publicField2(CIEDE2000, "_deg30InRad", degrees2radians(30)), __publicField2(CIEDE2000, "_deg6InRad", degrees2radians(6)), __publicField2(CIEDE2000, "_deg63InRad", degrees2radians(63)), __publicField2(CIEDE2000, "_deg275InRad", degrees2radians(275)), __publicField2(CIEDE2000, "_deg25InRad", degrees2radians(25));
var CMetric = class extends AbstractDistanceCalculator {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = (e4 + n2) / 2 * this._whitePoint.r, u2 = (e4 - n2) * this._whitePoint.r, h2 = (t2 - a2) * this._whitePoint.g, c2 = (i2 - o2) * this._whitePoint.b, f2 = ((512 + l2) * u2 * u2 >> 8) + 4 * h2 * h2 + ((767 - l2) * c2 * c2 >> 8), d = (s2 - r2) * this._whitePoint.a;
    return Math.sqrt(f2 + d * d);
  }
  _setDefaults() {
  }
};
var AbstractEuclidean = class extends AbstractDistanceCalculator {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = n2 - e4, u2 = a2 - t2, h2 = o2 - i2, c2 = s2 - r2;
    return Math.sqrt(this._kR * l2 * l2 + this._kG * u2 * u2 + this._kB * h2 * h2 + this._kA * c2 * c2);
  }
};
var Euclidean = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
};
var EuclideanBT709 = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
};
var EuclideanBT709NoAlpha = class extends AbstractEuclidean {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
  }
};
var AbstractManhattan = class extends AbstractDistanceCalculator {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    let l2 = n2 - e4, u2 = a2 - t2, h2 = o2 - i2, c2 = s2 - r2;
    return l2 < 0 && (l2 = 0 - l2), u2 < 0 && (u2 = 0 - u2), h2 < 0 && (h2 = 0 - h2), c2 < 0 && (c2 = 0 - c2), this._kR * l2 + this._kG * u2 + this._kB * h2 + this._kA * c2;
  }
};
var Manhattan = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
  }
};
var ManhattanNommyde = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
  }
};
var ManhattanBT709 = class extends AbstractManhattan {
  _setDefaults() {
    this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
  }
};
var PNGQuant = class extends AbstractDistanceCalculator {
  calculateRaw(e4, t2, i2, r2, n2, a2, o2, s2) {
    const l2 = (s2 - r2) * this._whitePoint.a;
    return this._colordifferenceCh(e4 * this._whitePoint.r, n2 * this._whitePoint.r, l2) + this._colordifferenceCh(t2 * this._whitePoint.g, a2 * this._whitePoint.g, l2) + this._colordifferenceCh(i2 * this._whitePoint.b, o2 * this._whitePoint.b, l2);
  }
  _colordifferenceCh(e4, t2, i2) {
    const r2 = e4 - t2, n2 = r2 + i2;
    return r2 * r2 + n2 * n2;
  }
  _setDefaults() {
  }
};
var palette_exports = {};
__export2(palette_exports, { AbstractPaletteQuantizer: () => AbstractPaletteQuantizer, ColorHistogram: () => ColorHistogram, NeuQuant: () => NeuQuant, NeuQuantFloat: () => NeuQuantFloat, RGBQuant: () => RGBQuant, WuColorCube: () => WuColorCube, WuQuant: () => WuQuant });
var AbstractPaletteQuantizer = class {
  quantizeSync() {
    for (const e4 of this.quantize())
      if (e4.palette)
        return e4.palette;
    throw new Error("unreachable");
  }
};
var Point = class {
  constructor() {
    __publicField2(this, "r"), __publicField2(this, "g"), __publicField2(this, "b"), __publicField2(this, "a"), __publicField2(this, "uint32"), __publicField2(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
  }
  static createByQuadruplet(e4) {
    const t2 = new Point();
    return t2.r = 0 | e4[0], t2.g = 0 | e4[1], t2.b = 0 | e4[2], t2.a = 0 | e4[3], t2._loadUINT32(), t2._loadQuadruplet(), t2;
  }
  static createByRGBA(e4, t2, i2, r2) {
    const n2 = new Point();
    return n2.r = 0 | e4, n2.g = 0 | t2, n2.b = 0 | i2, n2.a = 0 | r2, n2._loadUINT32(), n2._loadQuadruplet(), n2;
  }
  static createByUint32(e4) {
    const t2 = new Point();
    return t2.uint32 = e4 >>> 0, t2._loadRGBA(), t2._loadQuadruplet(), t2;
  }
  from(e4) {
    this.r = e4.r, this.g = e4.g, this.b = e4.b, this.a = e4.a, this.uint32 = e4.uint32, this.rgba[0] = e4.r, this.rgba[1] = e4.g, this.rgba[2] = e4.b, this.rgba[3] = e4.a;
  }
  getLuminosity(e4) {
    let t2 = this.r, i2 = this.g, r2 = this.b;
    return e4 && (t2 = Math.min(255, 255 - this.a + this.a * t2 / 255), i2 = Math.min(255, 255 - this.a + this.a * i2 / 255), r2 = Math.min(255, 255 - this.a + this.a * r2 / 255)), 0.2126 * t2 + 0.7152 * i2 + 0.0722 * r2;
  }
  _loadUINT32() {
    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
  }
  _loadRGBA() {
    this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
  }
  _loadQuadruplet() {
    this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
  }
};
var PointContainer = class {
  constructor() {
    __publicField2(this, "_pointArray"), __publicField2(this, "_width"), __publicField2(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setWidth(e4) {
    this._width = e4;
  }
  setHeight(e4) {
    this._height = e4;
  }
  getPointArray() {
    return this._pointArray;
  }
  clone() {
    const e4 = new PointContainer();
    e4._width = this._width, e4._height = this._height;
    for (let t2 = 0, i2 = this._pointArray.length; t2 < i2; t2++)
      e4._pointArray[t2] = Point.createByUint32(0 | this._pointArray[t2].uint32);
    return e4;
  }
  toUint32Array() {
    const e4 = this._pointArray.length, t2 = new Uint32Array(e4);
    for (let i2 = 0; i2 < e4; i2++)
      t2[i2] = this._pointArray[i2].uint32;
    return t2;
  }
  toUint8Array() {
    return new Uint8Array(this.toUint32Array().buffer);
  }
  static fromHTMLImageElement(e4) {
    const t2 = e4.naturalWidth, i2 = e4.naturalHeight, r2 = document.createElement("canvas");
    r2.width = t2, r2.height = i2;
    return r2.getContext("2d").drawImage(e4, 0, 0, t2, i2, 0, 0, t2, i2), PointContainer.fromHTMLCanvasElement(r2);
  }
  static fromHTMLCanvasElement(e4) {
    const t2 = e4.width, i2 = e4.height, r2 = e4.getContext("2d").getImageData(0, 0, t2, i2);
    return PointContainer.fromImageData(r2);
  }
  static fromImageData(e4) {
    const t2 = e4.width, i2 = e4.height;
    return PointContainer.fromUint8Array(e4.data, t2, i2);
  }
  static fromUint8Array(e4, t2, i2) {
    switch (Object.prototype.toString.call(e4)) {
      case "[object Uint8ClampedArray]":
      case "[object Uint8Array]":
        break;
      default:
        e4 = new Uint8Array(e4);
    }
    const r2 = new Uint32Array(e4.buffer);
    return PointContainer.fromUint32Array(r2, t2, i2);
  }
  static fromUint32Array(e4, t2, i2) {
    const r2 = new PointContainer();
    r2._width = t2, r2._height = i2;
    for (let t3 = 0, i3 = e4.length; t3 < i3; t3++)
      r2._pointArray[t3] = Point.createByUint32(0 | e4[t3]);
    return r2;
  }
  static fromBuffer(e4, t2, i2) {
    const r2 = new Uint32Array(e4.buffer, e4.byteOffset, e4.byteLength / Uint32Array.BYTES_PER_ELEMENT);
    return PointContainer.fromUint32Array(r2, t2, i2);
  }
};
var hueGroups = 10;
function hueGroup(e4, t2) {
  const i2 = 360 / t2;
  for (let r2 = 1, n2 = i2 - i2 / 2; r2 < t2; r2++, n2 += i2)
    if (e4 >= n2 && e4 < n2 + i2)
      return r2;
  return 0;
}
var Palette = class {
  constructor() {
    __publicField2(this, "_pointContainer"), __publicField2(this, "_pointArray", []), __publicField2(this, "_i32idx", {}), this._pointContainer = new PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
  }
  add(e4) {
    this._pointArray.push(e4), this._pointContainer.setWidth(this._pointArray.length);
  }
  has(e4) {
    for (let t2 = this._pointArray.length - 1; t2 >= 0; t2--)
      if (e4.uint32 === this._pointArray[t2].uint32)
        return true;
    return false;
  }
  getNearestColor(e4, t2) {
    return this._pointArray[0 | this._getNearestIndex(e4, t2)];
  }
  getPointContainer() {
    return this._pointContainer;
  }
  _nearestPointFromCache(e4) {
    return "number" == typeof this._i32idx[e4] ? this._i32idx[e4] : -1;
  }
  _getNearestIndex(e4, t2) {
    let i2 = this._nearestPointFromCache("" + t2.uint32);
    if (i2 >= 0)
      return i2;
    let r2 = Number.MAX_VALUE;
    i2 = 0;
    for (let n2 = 0, a2 = this._pointArray.length; n2 < a2; n2++) {
      const a3 = this._pointArray[n2], o2 = e4.calculateRaw(t2.r, t2.g, t2.b, t2.a, a3.r, a3.g, a3.b, a3.a);
      o2 < r2 && (r2 = o2, i2 = n2);
    }
    return this._i32idx[t2.uint32] = i2, i2;
  }
  sort() {
    this._i32idx = {}, this._pointArray.sort((e4, t2) => {
      const i2 = rgb2hsl(e4.r, e4.g, e4.b), r2 = rgb2hsl(t2.r, t2.g, t2.b), n2 = e4.r === e4.g && e4.g === e4.b ? 0 : 1 + hueGroup(i2.h, hueGroups), a2 = (t2.r === t2.g && t2.g === t2.b ? 0 : 1 + hueGroup(r2.h, hueGroups)) - n2;
      if (a2)
        return -a2;
      const o2 = e4.getLuminosity(true), s2 = t2.getLuminosity(true);
      if (s2 - o2 != 0)
        return s2 - o2;
      const l2 = (100 * r2.s | 0) - (100 * i2.s | 0);
      return l2 ? -l2 : 0;
    });
  }
};
var utils_exports = {};
__export2(utils_exports, { HueStatistics: () => HueStatistics, Palette: () => Palette, Point: () => Point, PointContainer: () => PointContainer, ProgressTracker: () => ProgressTracker, arithmetic: () => arithmetic_exports });
var HueGroup = class {
  constructor() {
    __publicField2(this, "num", 0), __publicField2(this, "cols", []);
  }
};
var HueStatistics = class {
  constructor(e4, t2) {
    __publicField2(this, "_numGroups"), __publicField2(this, "_minCols"), __publicField2(this, "_stats"), __publicField2(this, "_groupsFull"), this._numGroups = e4, this._minCols = t2, this._stats = [];
    for (let t3 = 0; t3 <= e4; t3++)
      this._stats[t3] = new HueGroup();
    this._groupsFull = 0;
  }
  check(e4) {
    this._groupsFull === this._numGroups + 1 && (this.check = () => {
    });
    const t2 = 255 & e4, i2 = e4 >>> 8 & 255, r2 = e4 >>> 16 & 255, n2 = t2 === i2 && i2 === r2 ? 0 : 1 + hueGroup(rgb2hsl(t2, i2, r2).h, this._numGroups), a2 = this._stats[n2], o2 = this._minCols;
    a2.num++, a2.num > o2 || (a2.num === o2 && this._groupsFull++, a2.num <= o2 && this._stats[n2].cols.push(e4));
  }
  injectIntoDictionary(e4) {
    for (let t2 = 0; t2 <= this._numGroups; t2++)
      this._stats[t2].num <= this._minCols && this._stats[t2].cols.forEach((t3) => {
        e4[t3] ? e4[t3]++ : e4[t3] = 1;
      });
  }
  injectIntoArray(e4) {
    for (let t2 = 0; t2 <= this._numGroups; t2++)
      this._stats[t2].num <= this._minCols && this._stats[t2].cols.forEach((t3) => {
        -1 === e4.indexOf(t3) && e4.push(t3);
      });
  }
};
var _ProgressTracker = class {
  constructor(e4, t2) {
    __publicField2(this, "progress"), __publicField2(this, "_step"), __publicField2(this, "_range"), __publicField2(this, "_last"), __publicField2(this, "_progressRange"), this._range = e4, this._progressRange = t2, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), this._last = -this._step, this.progress = 0;
  }
  shouldNotify(e4) {
    return e4 - this._last >= this._step && (this._last = e4, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), true);
  }
};
var ProgressTracker = _ProgressTracker;
__publicField2(ProgressTracker, "steps", 100);
var networkBiasShift = 3;
var Neuron = class {
  constructor(e4) {
    __publicField2(this, "r"), __publicField2(this, "g"), __publicField2(this, "b"), __publicField2(this, "a"), this.r = this.g = this.b = this.a = e4;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
  }
  subtract(e4, t2, i2, r2) {
    this.r -= 0 | e4, this.g -= 0 | t2, this.b -= 0 | i2, this.a -= 0 | r2;
  }
};
var _NeuQuant = class extends AbstractPaletteQuantizer {
  constructor(e4, t2 = 256) {
    super(), __publicField2(this, "_pointArray"), __publicField2(this, "_networkSize"), __publicField2(this, "_network"), __publicField2(this, "_sampleFactor"), __publicField2(this, "_radPower"), __publicField2(this, "_freq"), __publicField2(this, "_bias"), __publicField2(this, "_distance"), this._distance = e4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t2, this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
  }
  sample(e4) {
    this._pointArray = this._pointArray.concat(e4.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let e4 = 0; e4 < this._networkSize; e4++)
      this._network[e4] = new Neuron((e4 << networkBiasShift + 8) / this._networkSize | 0), this._freq[e4] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[e4] = 0;
  }
  *_learn() {
    let e4 = this._sampleFactor;
    const t2 = this._pointArray.length;
    t2 < _NeuQuant._minpicturebytes && (e4 = 1);
    const i2 = 30 + (e4 - 1) / 3 | 0, r2 = t2 / e4 | 0;
    let n2, a2 = r2 / _NeuQuant._nCycles | 0, o2 = _NeuQuant._initAlpha, s2 = (this._networkSize >> 3) * _NeuQuant._radiusBias, l2 = s2 >> _NeuQuant._radiusBiasShift;
    l2 <= 1 && (l2 = 0);
    for (let e5 = 0; e5 < l2; e5++)
      this._radPower[e5] = o2 * ((l2 * l2 - e5 * e5) * _NeuQuant._radBias / (l2 * l2)) >>> 0;
    n2 = t2 < _NeuQuant._minpicturebytes ? 1 : t2 % _NeuQuant._prime1 != 0 ? _NeuQuant._prime1 : t2 % _NeuQuant._prime2 != 0 ? _NeuQuant._prime2 : t2 % _NeuQuant._prime3 != 0 ? _NeuQuant._prime3 : _NeuQuant._prime4;
    const u2 = new ProgressTracker(r2, 99);
    for (let e5 = 0, h2 = 0; e5 < r2; ) {
      u2.shouldNotify(e5) && (yield { progress: u2.progress });
      const r3 = this._pointArray[h2], c2 = r3.b << networkBiasShift, f2 = r3.g << networkBiasShift, d = r3.r << networkBiasShift, p2 = r3.a << networkBiasShift, m = this._contest(c2, f2, d, p2);
      if (this._alterSingle(o2, m, c2, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c2, f2, d, p2), h2 += n2, h2 >= t2 && (h2 -= t2), e5++, 0 === a2 && (a2 = 1), e5 % a2 == 0) {
        o2 -= o2 / i2 | 0, s2 -= s2 / _NeuQuant._radiusDecrease | 0, l2 = s2 >> _NeuQuant._radiusBiasShift, l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++)
          this._radPower[e6] = o2 * ((l2 * l2 - e6 * e6) * _NeuQuant._radBias / (l2 * l2)) >>> 0;
      }
    }
  }
  _buildPalette() {
    const e4 = new Palette();
    return this._network.forEach((t2) => {
      e4.add(t2.toPoint());
    }), e4.sort(), e4;
  }
  _alterNeighbour(e4, t2, i2, r2, n2, a2) {
    let o2 = t2 - e4;
    o2 < -1 && (o2 = -1);
    let s2 = t2 + e4;
    s2 > this._networkSize && (s2 = this._networkSize);
    let l2 = t2 + 1, u2 = t2 - 1, h2 = 1;
    for (; l2 < s2 || u2 > o2; ) {
      const e5 = this._radPower[h2++] / _NeuQuant._alphaRadBias;
      if (l2 < s2) {
        const t3 = this._network[l2++];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
      if (u2 > o2) {
        const t3 = this._network[u2--];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
    }
  }
  _alterSingle(e4, t2, i2, r2, n2, a2) {
    e4 /= _NeuQuant._initAlpha;
    const o2 = this._network[t2];
    o2.subtract(e4 * (o2.r - n2), e4 * (o2.g - r2), e4 * (o2.b - i2), e4 * (o2.a - a2));
  }
  _contest(e4, t2, i2, r2) {
    const n2 = 1020 << networkBiasShift;
    let a2 = ~(1 << 31), o2 = a2, s2 = -1, l2 = s2;
    for (let u2 = 0; u2 < this._networkSize; u2++) {
      const h2 = this._network[u2], c2 = this._distance.calculateNormalized(h2, { r: i2, g: t2, b: e4, a: r2 }) * n2 | 0;
      c2 < a2 && (a2 = c2, s2 = u2);
      const f2 = c2 - (this._bias[u2] >> _NeuQuant._initialBiasShift - networkBiasShift);
      f2 < o2 && (o2 = f2, l2 = u2);
      const d = this._freq[u2] >> _NeuQuant._betaShift;
      this._freq[u2] -= d, this._bias[u2] += d << _NeuQuant._gammaShift;
    }
    return this._freq[s2] += _NeuQuant._beta, this._bias[s2] -= _NeuQuant._betaGamma, l2;
  }
};
var NeuQuant = _NeuQuant;
__publicField2(NeuQuant, "_prime1", 499), __publicField2(NeuQuant, "_prime2", 491), __publicField2(NeuQuant, "_prime3", 487), __publicField2(NeuQuant, "_prime4", 503), __publicField2(NeuQuant, "_minpicturebytes", _NeuQuant._prime4), __publicField2(NeuQuant, "_nCycles", 100), __publicField2(NeuQuant, "_initialBiasShift", 16), __publicField2(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift), __publicField2(NeuQuant, "_gammaShift", 10), __publicField2(NeuQuant, "_betaShift", 10), __publicField2(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift), __publicField2(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift), __publicField2(NeuQuant, "_radiusBiasShift", 6), __publicField2(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift), __publicField2(NeuQuant, "_radiusDecrease", 30), __publicField2(NeuQuant, "_alphaBiasShift", 10), __publicField2(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift), __publicField2(NeuQuant, "_radBiasShift", 8), __publicField2(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift), __publicField2(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift), __publicField2(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
var networkBiasShift2 = 3;
var NeuronFloat = class {
  constructor(e4) {
    __publicField2(this, "r"), __publicField2(this, "g"), __publicField2(this, "b"), __publicField2(this, "a"), this.r = this.g = this.b = this.a = e4;
  }
  toPoint() {
    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
  }
  subtract(e4, t2, i2, r2) {
    this.r -= e4, this.g -= t2, this.b -= i2, this.a -= r2;
  }
};
var _NeuQuantFloat = class extends AbstractPaletteQuantizer {
  constructor(e4, t2 = 256) {
    super(), __publicField2(this, "_pointArray"), __publicField2(this, "_networkSize"), __publicField2(this, "_network"), __publicField2(this, "_sampleFactor"), __publicField2(this, "_radPower"), __publicField2(this, "_freq"), __publicField2(this, "_bias"), __publicField2(this, "_distance"), this._distance = e4, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t2, this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
  }
  sample(e4) {
    this._pointArray = this._pointArray.concat(e4.getPointArray());
  }
  *quantize() {
    this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
  }
  _init() {
    this._freq = [], this._bias = [], this._radPower = [], this._network = [];
    for (let e4 = 0; e4 < this._networkSize; e4++)
      this._network[e4] = new NeuronFloat((e4 << networkBiasShift2 + 8) / this._networkSize), this._freq[e4] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[e4] = 0;
  }
  *_learn() {
    let e4 = this._sampleFactor;
    const t2 = this._pointArray.length;
    t2 < _NeuQuantFloat._minpicturebytes && (e4 = 1);
    const i2 = 30 + (e4 - 1) / 3, r2 = t2 / e4;
    let n2, a2 = r2 / _NeuQuantFloat._nCycles | 0, o2 = _NeuQuantFloat._initAlpha, s2 = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, l2 = s2 >> _NeuQuantFloat._radiusBiasShift;
    l2 <= 1 && (l2 = 0);
    for (let e5 = 0; e5 < l2; e5++)
      this._radPower[e5] = o2 * ((l2 * l2 - e5 * e5) * _NeuQuantFloat._radBias / (l2 * l2));
    n2 = t2 < _NeuQuantFloat._minpicturebytes ? 1 : t2 % _NeuQuantFloat._prime1 != 0 ? _NeuQuantFloat._prime1 : t2 % _NeuQuantFloat._prime2 != 0 ? _NeuQuantFloat._prime2 : t2 % _NeuQuantFloat._prime3 != 0 ? _NeuQuantFloat._prime3 : _NeuQuantFloat._prime4;
    const u2 = new ProgressTracker(r2, 99);
    for (let e5 = 0, h2 = 0; e5 < r2; ) {
      u2.shouldNotify(e5) && (yield { progress: u2.progress });
      const r3 = this._pointArray[h2], c2 = r3.b << networkBiasShift2, f2 = r3.g << networkBiasShift2, d = r3.r << networkBiasShift2, p2 = r3.a << networkBiasShift2, m = this._contest(c2, f2, d, p2);
      if (this._alterSingle(o2, m, c2, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c2, f2, d, p2), h2 += n2, h2 >= t2 && (h2 -= t2), e5++, 0 === a2 && (a2 = 1), e5 % a2 == 0) {
        o2 -= o2 / i2, s2 -= s2 / _NeuQuantFloat._radiusDecrease, l2 = s2 >> _NeuQuantFloat._radiusBiasShift, l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++)
          this._radPower[e6] = o2 * ((l2 * l2 - e6 * e6) * _NeuQuantFloat._radBias / (l2 * l2));
      }
    }
  }
  _buildPalette() {
    const e4 = new Palette();
    return this._network.forEach((t2) => {
      e4.add(t2.toPoint());
    }), e4.sort(), e4;
  }
  _alterNeighbour(e4, t2, i2, r2, n2, a2) {
    let o2 = t2 - e4;
    o2 < -1 && (o2 = -1);
    let s2 = t2 + e4;
    s2 > this._networkSize && (s2 = this._networkSize);
    let l2 = t2 + 1, u2 = t2 - 1, h2 = 1;
    for (; l2 < s2 || u2 > o2; ) {
      const e5 = this._radPower[h2++] / _NeuQuantFloat._alphaRadBias;
      if (l2 < s2) {
        const t3 = this._network[l2++];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
      if (u2 > o2) {
        const t3 = this._network[u2--];
        t3.subtract(e5 * (t3.r - n2), e5 * (t3.g - r2), e5 * (t3.b - i2), e5 * (t3.a - a2));
      }
    }
  }
  _alterSingle(e4, t2, i2, r2, n2, a2) {
    e4 /= _NeuQuantFloat._initAlpha;
    const o2 = this._network[t2];
    o2.subtract(e4 * (o2.r - n2), e4 * (o2.g - r2), e4 * (o2.b - i2), e4 * (o2.a - a2));
  }
  _contest(e4, t2, i2, r2) {
    const n2 = 1020 << networkBiasShift2;
    let a2 = ~(1 << 31), o2 = a2, s2 = -1, l2 = s2;
    for (let u2 = 0; u2 < this._networkSize; u2++) {
      const h2 = this._network[u2], c2 = this._distance.calculateNormalized(h2, { r: i2, g: t2, b: e4, a: r2 }) * n2;
      c2 < a2 && (a2 = c2, s2 = u2);
      const f2 = c2 - (this._bias[u2] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
      f2 < o2 && (o2 = f2, l2 = u2);
      const d = this._freq[u2] >> _NeuQuantFloat._betaShift;
      this._freq[u2] -= d, this._bias[u2] += d << _NeuQuantFloat._gammaShift;
    }
    return this._freq[s2] += _NeuQuantFloat._beta, this._bias[s2] -= _NeuQuantFloat._betaGamma, l2;
  }
};
var NeuQuantFloat = _NeuQuantFloat;
__publicField2(NeuQuantFloat, "_prime1", 499), __publicField2(NeuQuantFloat, "_prime2", 491), __publicField2(NeuQuantFloat, "_prime3", 487), __publicField2(NeuQuantFloat, "_prime4", 503), __publicField2(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4), __publicField2(NeuQuantFloat, "_nCycles", 100), __publicField2(NeuQuantFloat, "_initialBiasShift", 16), __publicField2(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift), __publicField2(NeuQuantFloat, "_gammaShift", 10), __publicField2(NeuQuantFloat, "_betaShift", 10), __publicField2(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift), __publicField2(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift), __publicField2(NeuQuantFloat, "_radiusBiasShift", 6), __publicField2(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift), __publicField2(NeuQuantFloat, "_radiusDecrease", 30), __publicField2(NeuQuantFloat, "_alphaBiasShift", 10), __publicField2(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift), __publicField2(NeuQuantFloat, "_radBiasShift", 8), __publicField2(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift), __publicField2(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift), __publicField2(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
var _ColorHistogram = class {
  constructor(e4, t2) {
    __publicField2(this, "_method"), __publicField2(this, "_hueStats"), __publicField2(this, "_histogram"), __publicField2(this, "_initColors"), __publicField2(this, "_minHueCols"), this._method = e4, this._minHueCols = t2 << 2, this._initColors = t2 << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
  }
  sample(e4) {
    switch (this._method) {
      case 1:
        this._colorStats1D(e4);
        break;
      case 2:
        this._colorStats2D(e4);
    }
  }
  getImportanceSortedColorsIDXI32() {
    const e4 = stableSort(Object.keys(this._histogram), (e5, t3) => this._histogram[t3] - this._histogram[e5]);
    if (0 === e4.length)
      return [];
    let t2;
    switch (this._method) {
      case 1:
        const i2 = Math.min(e4.length, this._initColors), r2 = e4[i2 - 1], n2 = this._histogram[r2];
        t2 = e4.slice(0, i2);
        let a2 = i2;
        const o2 = e4.length;
        for (; a2 < o2 && this._histogram[e4[a2]] === n2; )
          t2.push(e4[a2++]);
        this._hueStats.injectIntoArray(t2);
        break;
      case 2:
        t2 = e4;
        break;
      default:
        throw new Error("Incorrect method");
    }
    return t2.map((e5) => +e5);
  }
  _colorStats1D(e4) {
    const t2 = this._histogram, i2 = e4.getPointArray(), r2 = i2.length;
    for (let e5 = 0; e5 < r2; e5++) {
      const r3 = i2[e5].uint32;
      this._hueStats.check(r3), r3 in t2 ? t2[r3]++ : t2[r3] = 1;
    }
  }
  _colorStats2D(e4) {
    const t2 = e4.getWidth(), i2 = e4.getHeight(), r2 = e4.getPointArray(), n2 = _ColorHistogram._boxSize[0], a2 = _ColorHistogram._boxSize[1], o2 = n2 * a2, s2 = this._makeBoxes(t2, i2, n2, a2), l2 = this._histogram;
    s2.forEach((e5) => {
      let i3 = Math.round(e5.w * e5.h / o2) * _ColorHistogram._boxPixels;
      i3 < 2 && (i3 = 2);
      const n3 = {};
      this._iterateBox(e5, t2, (e6) => {
        const t3 = r2[e6].uint32;
        this._hueStats.check(t3), t3 in l2 ? l2[t3]++ : t3 in n3 ? ++n3[t3] >= i3 && (l2[t3] = n3[t3]) : n3[t3] = 1;
      });
    }), this._hueStats.injectIntoDictionary(l2);
  }
  _iterateBox(e4, t2, i2) {
    const r2 = e4, n2 = r2.y * t2 + r2.x, a2 = (r2.y + r2.h - 1) * t2 + (r2.x + r2.w - 1), o2 = t2 - r2.w + 1;
    let s2 = 0, l2 = n2;
    do {
      i2.call(this, l2), l2 += ++s2 % r2.w == 0 ? o2 : 1;
    } while (l2 <= a2);
  }
  _makeBoxes(e4, t2, i2, r2) {
    const n2 = e4 % i2, a2 = t2 % r2, o2 = e4 - n2, s2 = t2 - a2, l2 = [];
    for (let u2 = 0; u2 < t2; u2 += r2)
      for (let t3 = 0; t3 < e4; t3 += i2)
        l2.push({ x: t3, y: u2, w: t3 === o2 ? n2 : i2, h: u2 === s2 ? a2 : r2 });
    return l2;
  }
};
var ColorHistogram = _ColorHistogram;
__publicField2(ColorHistogram, "_boxSize", [64, 64]), __publicField2(ColorHistogram, "_boxPixels", 2), __publicField2(ColorHistogram, "_hueGroups", 10);
var RemovedColor = class {
  constructor(e4, t2, i2) {
    __publicField2(this, "index"), __publicField2(this, "color"), __publicField2(this, "distance"), this.index = e4, this.color = t2, this.distance = i2;
  }
};
var RGBQuant = class extends AbstractPaletteQuantizer {
  constructor(e4, t2 = 256, i2 = 2) {
    super(), __publicField2(this, "_colors"), __publicField2(this, "_initialDistance"), __publicField2(this, "_distanceIncrement"), __publicField2(this, "_histogram"), __publicField2(this, "_distance"), this._distance = e4, this._colors = t2, this._histogram = new ColorHistogram(i2, t2), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
  }
  sample(e4) {
    this._histogram.sample(e4);
  }
  *quantize() {
    const e4 = this._histogram.getImportanceSortedColorsIDXI32();
    if (0 === e4.length)
      throw new Error("No colors in image");
    yield* this._buildPalette(e4);
  }
  *_buildPalette(e4) {
    const t2 = new Palette(), i2 = t2.getPointContainer().getPointArray(), r2 = new Array(e4.length);
    for (let t3 = 0; t3 < e4.length; t3++)
      i2.push(Point.createByUint32(e4[t3])), r2[t3] = 1;
    const n2 = i2.length, a2 = [];
    let o2 = n2, s2 = this._initialDistance;
    const l2 = new ProgressTracker(o2 - this._colors, 99);
    for (; o2 > this._colors; ) {
      a2.length = 0;
      for (let e5 = 0; e5 < n2; e5++) {
        if (l2.shouldNotify(n2 - o2) && (yield { progress: l2.progress }), 0 === r2[e5])
          continue;
        const t3 = i2[e5];
        for (let l3 = e5 + 1; l3 < n2; l3++) {
          if (0 === r2[l3])
            continue;
          const e6 = i2[l3], n3 = this._distance.calculateNormalized(t3, e6);
          n3 < s2 && (a2.push(new RemovedColor(l3, e6, n3)), r2[l3] = 0, o2--);
        }
      }
      s2 += o2 > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
    }
    if (o2 < this._colors) {
      stableSort(a2, (e6, t3) => t3.distance - e6.distance);
      let e5 = 0;
      for (; o2 < this._colors && e5 < a2.length; ) {
        r2[a2[e5].index] = 1, o2++, e5++;
      }
    }
    let u2 = i2.length;
    for (let e5 = u2 - 1; e5 >= 0; e5--)
      0 === r2[e5] && (e5 !== u2 - 1 && (i2[e5] = i2[u2 - 1]), --u2);
    i2.length = u2, t2.sort(), yield { palette: t2, progress: 100 };
  }
};
function createArray1D(e4) {
  const t2 = [];
  for (let i2 = 0; i2 < e4; i2++)
    t2[i2] = 0;
  return t2;
}
function createArray4D(e4, t2, i2, r2) {
  const n2 = new Array(e4);
  for (let a2 = 0; a2 < e4; a2++) {
    n2[a2] = new Array(t2);
    for (let e5 = 0; e5 < t2; e5++) {
      n2[a2][e5] = new Array(i2);
      for (let t3 = 0; t3 < i2; t3++) {
        n2[a2][e5][t3] = new Array(r2);
        for (let i3 = 0; i3 < r2; i3++)
          n2[a2][e5][t3][i3] = 0;
      }
    }
  }
  return n2;
}
function createArray3D(e4, t2, i2) {
  const r2 = new Array(e4);
  for (let n2 = 0; n2 < e4; n2++) {
    r2[n2] = new Array(t2);
    for (let e5 = 0; e5 < t2; e5++) {
      r2[n2][e5] = new Array(i2);
      for (let t3 = 0; t3 < i2; t3++)
        r2[n2][e5][t3] = 0;
    }
  }
  return r2;
}
function fillArray3D(e4, t2, i2, r2, n2) {
  for (let a2 = 0; a2 < t2; a2++) {
    e4[a2] = [];
    for (let t3 = 0; t3 < i2; t3++) {
      e4[a2][t3] = [];
      for (let i3 = 0; i3 < r2; i3++)
        e4[a2][t3][i3] = n2;
    }
  }
}
function fillArray1D(e4, t2, i2) {
  for (let r2 = 0; r2 < t2; r2++)
    e4[r2] = i2;
}
var WuColorCube = class {
  constructor() {
    __publicField2(this, "redMinimum"), __publicField2(this, "redMaximum"), __publicField2(this, "greenMinimum"), __publicField2(this, "greenMaximum"), __publicField2(this, "blueMinimum"), __publicField2(this, "blueMaximum"), __publicField2(this, "volume"), __publicField2(this, "alphaMinimum"), __publicField2(this, "alphaMaximum");
  }
};
var _WuQuant = class extends AbstractPaletteQuantizer {
  constructor(e4, t2 = 256, i2 = 5) {
    super(), __publicField2(this, "_reds"), __publicField2(this, "_greens"), __publicField2(this, "_blues"), __publicField2(this, "_alphas"), __publicField2(this, "_sums"), __publicField2(this, "_weights"), __publicField2(this, "_momentsRed"), __publicField2(this, "_momentsGreen"), __publicField2(this, "_momentsBlue"), __publicField2(this, "_momentsAlpha"), __publicField2(this, "_moments"), __publicField2(this, "_table"), __publicField2(this, "_pixels"), __publicField2(this, "_cubes"), __publicField2(this, "_colors"), __publicField2(this, "_significantBitsPerChannel"), __publicField2(this, "_maxSideIndex"), __publicField2(this, "_alphaMaxSideIndex"), __publicField2(this, "_sideSize"), __publicField2(this, "_alphaSideSize"), __publicField2(this, "_distance"), this._distance = e4, this._setQuality(i2), this._initialize(t2);
  }
  sample(e4) {
    const t2 = e4.getPointArray();
    for (let e5 = 0, i2 = t2.length; e5 < i2; e5++)
      this._addColor(t2[e5]);
    this._pixels = this._pixels.concat(t2);
  }
  *quantize() {
    yield* this._preparePalette();
    const e4 = new Palette();
    for (let t2 = 0; t2 < this._colors; t2++)
      if (this._sums[t2] > 0) {
        const i2 = this._sums[t2], r2 = this._reds[t2] / i2, n2 = this._greens[t2] / i2, a2 = this._blues[t2] / i2, o2 = this._alphas[t2] / i2, s2 = Point.createByRGBA(0 | r2, 0 | n2, 0 | a2, 0 | o2);
        e4.add(s2);
      }
    e4.sort(), yield { palette: e4, progress: 100 };
  }
  *_preparePalette() {
    yield* this._calculateMoments();
    let e4 = 0;
    const t2 = createArray1D(this._colors);
    for (let i3 = 1; i3 < this._colors; ++i3) {
      this._cut(this._cubes[e4], this._cubes[i3]) ? (t2[e4] = this._cubes[e4].volume > 1 ? this._calculateVariance(this._cubes[e4]) : 0, t2[i3] = this._cubes[i3].volume > 1 ? this._calculateVariance(this._cubes[i3]) : 0) : (t2[e4] = 0, i3--), e4 = 0;
      let r3 = t2[0];
      for (let n3 = 1; n3 <= i3; ++n3)
        t2[n3] > r3 && (r3 = t2[n3], e4 = n3);
      if (r3 <= 0) {
        this._colors = i3 + 1;
        break;
      }
    }
    const i2 = [], r2 = [], n2 = [], a2 = [];
    for (let e5 = 0; e5 < this._colors; ++e5) {
      const t3 = _WuQuant._volume(this._cubes[e5], this._weights);
      t3 > 0 ? (i2[e5] = _WuQuant._volume(this._cubes[e5], this._momentsRed) / t3 | 0, r2[e5] = _WuQuant._volume(this._cubes[e5], this._momentsGreen) / t3 | 0, n2[e5] = _WuQuant._volume(this._cubes[e5], this._momentsBlue) / t3 | 0, a2[e5] = _WuQuant._volume(this._cubes[e5], this._momentsAlpha) / t3 | 0) : (i2[e5] = 0, r2[e5] = 0, n2[e5] = 0, a2[e5] = 0);
    }
    this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), this._sums = createArray1D(this._colors + 1);
    for (let e5 = 0, t3 = this._pixels.length; e5 < t3; e5++) {
      const t4 = this._pixels[e5];
      let o2 = -1, s2 = Number.MAX_VALUE;
      for (let e6 = 0; e6 < this._colors; e6++) {
        const l2 = i2[e6], u2 = r2[e6], h2 = n2[e6], c2 = a2[e6], f2 = this._distance.calculateRaw(l2, u2, h2, c2, t4.r, t4.g, t4.b, t4.a);
        f2 < s2 && (s2 = f2, o2 = e6);
      }
      this._reds[o2] += t4.r, this._greens[o2] += t4.g, this._blues[o2] += t4.b, this._alphas[o2] += t4.a, this._sums[o2]++;
    }
  }
  _addColor(e4) {
    const t2 = 8 - this._significantBitsPerChannel, i2 = 1 + (e4.r >> t2), r2 = 1 + (e4.g >> t2), n2 = 1 + (e4.b >> t2), a2 = 1 + (e4.a >> t2);
    this._weights[a2][i2][r2][n2]++, this._momentsRed[a2][i2][r2][n2] += e4.r, this._momentsGreen[a2][i2][r2][n2] += e4.g, this._momentsBlue[a2][i2][r2][n2] += e4.b, this._momentsAlpha[a2][i2][r2][n2] += e4.a, this._moments[a2][i2][r2][n2] += this._table[e4.r] + this._table[e4.g] + this._table[e4.b] + this._table[e4.a];
  }
  *_calculateMoments() {
    const e4 = [], t2 = [], i2 = [], r2 = [], n2 = [], a2 = [], o2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), s2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), l2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), u2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), h2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), c2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
    let f2 = 0;
    const d = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
    for (let p2 = 1; p2 <= this._alphaMaxSideIndex; ++p2) {
      fillArray3D(o2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(s2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(l2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(u2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(h2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(c2, this._sideSize, this._sideSize, this._sideSize, 0);
      for (let m = 1; m <= this._maxSideIndex; ++m, ++f2) {
        d.shouldNotify(f2) && (yield { progress: d.progress }), fillArray1D(e4, this._sideSize, 0), fillArray1D(t2, this._sideSize, 0), fillArray1D(i2, this._sideSize, 0), fillArray1D(r2, this._sideSize, 0), fillArray1D(n2, this._sideSize, 0), fillArray1D(a2, this._sideSize, 0);
        for (let f3 = 1; f3 <= this._maxSideIndex; ++f3) {
          let d2 = 0, _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0;
          for (let v2 = 1; v2 <= this._maxSideIndex; ++v2)
            d2 += this._weights[p2][m][f3][v2], _2 += this._momentsRed[p2][m][f3][v2], g += this._momentsGreen[p2][m][f3][v2], b2 += this._momentsBlue[p2][m][f3][v2], y2 += this._momentsAlpha[p2][m][f3][v2], w += this._moments[p2][m][f3][v2], e4[v2] += d2, t2[v2] += _2, i2[v2] += g, r2[v2] += b2, n2[v2] += y2, a2[v2] += w, o2[m][f3][v2] = o2[m - 1][f3][v2] + e4[v2], s2[m][f3][v2] = s2[m - 1][f3][v2] + t2[v2], l2[m][f3][v2] = l2[m - 1][f3][v2] + i2[v2], u2[m][f3][v2] = u2[m - 1][f3][v2] + r2[v2], h2[m][f3][v2] = h2[m - 1][f3][v2] + n2[v2], c2[m][f3][v2] = c2[m - 1][f3][v2] + a2[v2], this._weights[p2][m][f3][v2] = this._weights[p2 - 1][m][f3][v2] + o2[m][f3][v2], this._momentsRed[p2][m][f3][v2] = this._momentsRed[p2 - 1][m][f3][v2] + s2[m][f3][v2], this._momentsGreen[p2][m][f3][v2] = this._momentsGreen[p2 - 1][m][f3][v2] + l2[m][f3][v2], this._momentsBlue[p2][m][f3][v2] = this._momentsBlue[p2 - 1][m][f3][v2] + u2[m][f3][v2], this._momentsAlpha[p2][m][f3][v2] = this._momentsAlpha[p2 - 1][m][f3][v2] + h2[m][f3][v2], this._moments[p2][m][f3][v2] = this._moments[p2 - 1][m][f3][v2] + c2[m][f3][v2];
        }
      }
    }
  }
  static _volumeFloat(e4, t2) {
    return t2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] - t2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - t2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + t2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - t2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] + t2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + t2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - t2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (t2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - t2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - t2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + t2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - t2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + t2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + t2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] - t2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
  }
  static _volume(e4, t2) {
    return 0 | _WuQuant._volumeFloat(e4, t2);
  }
  static _top(e4, t2, i2, r2) {
    let n2;
    switch (t2) {
      case _WuQuant._alpha:
        n2 = r2[i2][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] - r2[i2][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - r2[i2][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + r2[i2][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (r2[i2][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] - r2[i2][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - r2[i2][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + r2[i2][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
        break;
      case _WuQuant._red:
        n2 = r2[e4.alphaMaximum][i2][e4.greenMaximum][e4.blueMaximum] - r2[e4.alphaMaximum][i2][e4.greenMinimum][e4.blueMaximum] - r2[e4.alphaMinimum][i2][e4.greenMaximum][e4.blueMaximum] + r2[e4.alphaMinimum][i2][e4.greenMinimum][e4.blueMaximum] - (r2[e4.alphaMaximum][i2][e4.greenMaximum][e4.blueMinimum] - r2[e4.alphaMaximum][i2][e4.greenMinimum][e4.blueMinimum] - r2[e4.alphaMinimum][i2][e4.greenMaximum][e4.blueMinimum] + r2[e4.alphaMinimum][i2][e4.greenMinimum][e4.blueMinimum]);
        break;
      case _WuQuant._green:
        n2 = r2[e4.alphaMaximum][e4.redMaximum][i2][e4.blueMaximum] - r2[e4.alphaMaximum][e4.redMinimum][i2][e4.blueMaximum] - r2[e4.alphaMinimum][e4.redMaximum][i2][e4.blueMaximum] + r2[e4.alphaMinimum][e4.redMinimum][i2][e4.blueMaximum] - (r2[e4.alphaMaximum][e4.redMaximum][i2][e4.blueMinimum] - r2[e4.alphaMaximum][e4.redMinimum][i2][e4.blueMinimum] - r2[e4.alphaMinimum][e4.redMaximum][i2][e4.blueMinimum] + r2[e4.alphaMinimum][e4.redMinimum][i2][e4.blueMinimum]);
        break;
      case _WuQuant._blue:
        n2 = r2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][i2] - r2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][i2] - r2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][i2] + r2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][i2] - (r2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][i2] - r2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][i2] - r2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][i2] + r2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][i2]);
        break;
      default:
        throw new Error("impossible");
    }
    return 0 | n2;
  }
  static _bottom(e4, t2, i2) {
    switch (t2) {
      case _WuQuant._alpha:
        return -i2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      case _WuQuant._red:
        return -i2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMaximum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      case _WuQuant._green:
        return -i2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMaximum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMaximum] - (-i2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      case _WuQuant._blue:
        return -i2[e4.alphaMaximum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMaximum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMaximum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum] - (-i2[e4.alphaMinimum][e4.redMaximum][e4.greenMaximum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMaximum][e4.greenMinimum][e4.blueMinimum] + i2[e4.alphaMinimum][e4.redMinimum][e4.greenMaximum][e4.blueMinimum] - i2[e4.alphaMinimum][e4.redMinimum][e4.greenMinimum][e4.blueMinimum]);
      default:
        return 0;
    }
  }
  _calculateVariance(e4) {
    const t2 = _WuQuant._volume(e4, this._momentsRed), i2 = _WuQuant._volume(e4, this._momentsGreen), r2 = _WuQuant._volume(e4, this._momentsBlue), n2 = _WuQuant._volume(e4, this._momentsAlpha);
    return _WuQuant._volumeFloat(e4, this._moments) - (t2 * t2 + i2 * i2 + r2 * r2 + n2 * n2) / _WuQuant._volume(e4, this._weights);
  }
  _maximize(e4, t2, i2, r2, n2, a2, o2, s2, l2) {
    const u2 = 0 | _WuQuant._bottom(e4, t2, this._momentsRed), h2 = 0 | _WuQuant._bottom(e4, t2, this._momentsGreen), c2 = 0 | _WuQuant._bottom(e4, t2, this._momentsBlue), f2 = 0 | _WuQuant._bottom(e4, t2, this._momentsAlpha), d = 0 | _WuQuant._bottom(e4, t2, this._weights);
    let p2 = 0, m = -1;
    for (let _2 = i2; _2 < r2; ++_2) {
      let i3 = u2 + _WuQuant._top(e4, t2, _2, this._momentsRed), r3 = h2 + _WuQuant._top(e4, t2, _2, this._momentsGreen), g = c2 + _WuQuant._top(e4, t2, _2, this._momentsBlue), b2 = f2 + _WuQuant._top(e4, t2, _2, this._momentsAlpha), y2 = d + _WuQuant._top(e4, t2, _2, this._weights);
      if (0 !== y2) {
        let e5 = i3 * i3 + r3 * r3 + g * g + b2 * b2, t3 = e5 / y2;
        i3 = n2 - i3, r3 = a2 - r3, g = o2 - g, b2 = s2 - b2, y2 = l2 - y2, 0 !== y2 && (e5 = i3 * i3 + r3 * r3 + g * g + b2 * b2, t3 += e5 / y2, t3 > p2 && (p2 = t3, m = _2));
      }
    }
    return { max: p2, position: m };
  }
  _cut(e4, t2) {
    let i2;
    const r2 = _WuQuant._volume(e4, this._momentsRed), n2 = _WuQuant._volume(e4, this._momentsGreen), a2 = _WuQuant._volume(e4, this._momentsBlue), o2 = _WuQuant._volume(e4, this._momentsAlpha), s2 = _WuQuant._volume(e4, this._weights), l2 = this._maximize(e4, _WuQuant._red, e4.redMinimum + 1, e4.redMaximum, r2, n2, a2, o2, s2), u2 = this._maximize(e4, _WuQuant._green, e4.greenMinimum + 1, e4.greenMaximum, r2, n2, a2, o2, s2), h2 = this._maximize(e4, _WuQuant._blue, e4.blueMinimum + 1, e4.blueMaximum, r2, n2, a2, o2, s2), c2 = this._maximize(e4, _WuQuant._alpha, e4.alphaMinimum + 1, e4.alphaMaximum, r2, n2, a2, o2, s2);
    if (c2.max >= l2.max && c2.max >= u2.max && c2.max >= h2.max) {
      if (i2 = _WuQuant._alpha, c2.position < 0)
        return false;
    } else
      i2 = l2.max >= c2.max && l2.max >= u2.max && l2.max >= h2.max ? _WuQuant._red : u2.max >= c2.max && u2.max >= l2.max && u2.max >= h2.max ? _WuQuant._green : _WuQuant._blue;
    switch (t2.redMaximum = e4.redMaximum, t2.greenMaximum = e4.greenMaximum, t2.blueMaximum = e4.blueMaximum, t2.alphaMaximum = e4.alphaMaximum, i2) {
      case _WuQuant._red:
        t2.redMinimum = e4.redMaximum = l2.position, t2.greenMinimum = e4.greenMinimum, t2.blueMinimum = e4.blueMinimum, t2.alphaMinimum = e4.alphaMinimum;
        break;
      case _WuQuant._green:
        t2.greenMinimum = e4.greenMaximum = u2.position, t2.redMinimum = e4.redMinimum, t2.blueMinimum = e4.blueMinimum, t2.alphaMinimum = e4.alphaMinimum;
        break;
      case _WuQuant._blue:
        t2.blueMinimum = e4.blueMaximum = h2.position, t2.redMinimum = e4.redMinimum, t2.greenMinimum = e4.greenMinimum, t2.alphaMinimum = e4.alphaMinimum;
        break;
      case _WuQuant._alpha:
        t2.alphaMinimum = e4.alphaMaximum = c2.position, t2.blueMinimum = e4.blueMinimum, t2.redMinimum = e4.redMinimum, t2.greenMinimum = e4.greenMinimum;
    }
    return e4.volume = (e4.redMaximum - e4.redMinimum) * (e4.greenMaximum - e4.greenMinimum) * (e4.blueMaximum - e4.blueMinimum) * (e4.alphaMaximum - e4.alphaMinimum), t2.volume = (t2.redMaximum - t2.redMinimum) * (t2.greenMaximum - t2.greenMinimum) * (t2.blueMaximum - t2.blueMinimum) * (t2.alphaMaximum - t2.alphaMinimum), true;
  }
  _initialize(e4) {
    this._colors = e4, this._cubes = [];
    for (let t2 = 0; t2 < e4; t2++)
      this._cubes[t2] = new WuColorCube();
    this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
    for (let e5 = 0; e5 < 256; ++e5)
      this._table[e5] = e5 * e5;
    this._pixels = [];
  }
  _setQuality(e4 = 5) {
    this._significantBitsPerChannel = e4, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
  }
};
var WuQuant = _WuQuant;
__publicField2(WuQuant, "_alpha", 3), __publicField2(WuQuant, "_red", 2), __publicField2(WuQuant, "_green", 1), __publicField2(WuQuant, "_blue", 0);
var image_exports = {};
__export2(image_exports, { AbstractImageQuantizer: () => AbstractImageQuantizer, ErrorDiffusionArray: () => ErrorDiffusionArray, ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel, ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma, NearestColor: () => NearestColor });
var AbstractImageQuantizer = class {
  quantizeSync(e4, t2) {
    for (const i2 of this.quantize(e4, t2))
      if (i2.pointContainer)
        return i2.pointContainer;
    throw new Error("unreachable");
  }
};
var NearestColor = class extends AbstractImageQuantizer {
  constructor(e4) {
    super(), __publicField2(this, "_distance"), this._distance = e4;
  }
  *quantize(e4, t2) {
    const i2 = e4.getPointArray(), r2 = e4.getWidth(), n2 = e4.getHeight(), a2 = new ProgressTracker(n2, 99);
    for (let e5 = 0; e5 < n2; e5++) {
      a2.shouldNotify(e5) && (yield { progress: a2.progress });
      for (let n3 = 0, a3 = e5 * r2; n3 < r2; n3++, a3++) {
        const e6 = i2[a3];
        e6.from(t2.getNearestColor(this._distance, e6));
      }
    }
    yield { pointContainer: e4, progress: 100 };
  }
};
var ErrorDiffusionArrayKernel = ((e4) => (e4[e4.FloydSteinberg = 0] = "FloydSteinberg", e4[e4.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e4[e4.Stucki = 2] = "Stucki", e4[e4.Atkinson = 3] = "Atkinson", e4[e4.Jarvis = 4] = "Jarvis", e4[e4.Burkes = 5] = "Burkes", e4[e4.Sierra = 6] = "Sierra", e4[e4.TwoSierra = 7] = "TwoSierra", e4[e4.SierraLite = 8] = "SierraLite", e4))(ErrorDiffusionArrayKernel || {});
var ErrorDiffusionArray = class extends AbstractImageQuantizer {
  constructor(e4, t2, i2 = true, r2 = 0, n2 = false) {
    super(), __publicField2(this, "_minColorDistance"), __publicField2(this, "_serpentine"), __publicField2(this, "_kernel"), __publicField2(this, "_calculateErrorLikeGIMP"), __publicField2(this, "_distance"), this._setKernel(t2), this._distance = e4, this._minColorDistance = r2, this._serpentine = i2, this._calculateErrorLikeGIMP = n2;
  }
  *quantize(e4, t2) {
    const i2 = e4.getPointArray(), r2 = new Point(), n2 = e4.getWidth(), a2 = e4.getHeight(), o2 = [];
    let s2 = 1, l2 = 1;
    for (const e5 of this._kernel) {
      const t3 = e5[2] + 1;
      l2 < t3 && (l2 = t3);
    }
    for (let e5 = 0; e5 < l2; e5++)
      this._fillErrorLine(o2[e5] = [], n2);
    const u2 = new ProgressTracker(a2, 99);
    for (let e5 = 0; e5 < a2; e5++) {
      u2.shouldNotify(e5) && (yield { progress: u2.progress }), this._serpentine && (s2 *= -1);
      const l3 = e5 * n2, h2 = 1 === s2 ? 0 : n2 - 1, c2 = 1 === s2 ? n2 : -1;
      this._fillErrorLine(o2[0], n2), o2.push(o2.shift());
      const f2 = o2[0];
      for (let u3 = h2, d = l3 + h2; u3 !== c2; u3 += s2, d += s2) {
        const l4 = i2[d], h3 = f2[u3];
        r2.from(l4);
        const c3 = Point.createByRGBA(inRange0to255Rounded(l4.r + h3[0]), inRange0to255Rounded(l4.g + h3[1]), inRange0to255Rounded(l4.b + h3[2]), inRange0to255Rounded(l4.a + h3[3])), p2 = t2.getNearestColor(this._distance, c3);
        if (l4.from(p2), this._minColorDistance) {
          if (this._distance.calculateNormalized(r2, p2) < this._minColorDistance)
            continue;
        }
        let m, _2, g, b2;
        this._calculateErrorLikeGIMP ? (m = c3.r - p2.r, _2 = c3.g - p2.g, g = c3.b - p2.b, b2 = c3.a - p2.a) : (m = r2.r - p2.r, _2 = r2.g - p2.g, g = r2.b - p2.b, b2 = r2.a - p2.a);
        const y2 = 1 === s2 ? 0 : this._kernel.length - 1, w = 1 === s2 ? this._kernel.length : -1;
        for (let t3 = y2; t3 !== w; t3 += s2) {
          const i3 = this._kernel[t3][1] * s2, r3 = this._kernel[t3][2];
          if (i3 + u3 >= 0 && i3 + u3 < n2 && r3 + e5 >= 0 && r3 + e5 < a2) {
            const e6 = this._kernel[t3][0], n3 = o2[r3][i3 + u3];
            n3[0] += m * e6, n3[1] += _2 * e6, n3[2] += g * e6, n3[3] += b2 * e6;
          }
        }
      }
    }
    yield { pointContainer: e4, progress: 100 };
  }
  _fillErrorLine(e4, t2) {
    e4.length > t2 && (e4.length = t2);
    const i2 = e4.length;
    for (let t3 = 0; t3 < i2; t3++) {
      const i3 = e4[t3];
      i3[0] = i3[1] = i3[2] = i3[3] = 0;
    }
    for (let r2 = i2; r2 < t2; r2++)
      e4[r2] = [0, 0, 0, 0];
  }
  _setKernel(e4) {
    switch (e4) {
      case 0:
        this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
        break;
      case 1:
        this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
        break;
      case 2:
        this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
        break;
      case 3:
        this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
        break;
      case 4:
        this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
        break;
      case 5:
        this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
        break;
      case 6:
        this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
        break;
      case 7:
        this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
        break;
      case 8:
        this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
        break;
      default:
        throw new Error(`ErrorDiffusionArray: unknown kernel = ${e4}`);
    }
  }
};
function* hilbertCurve(e4, t2, i2) {
  const r2 = Math.max(e4, t2), n2 = { width: e4, height: t2, level: Math.floor(Math.log(r2) / Math.log(2) + 1), callback: i2, tracker: new ProgressTracker(e4 * t2, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert(n2, 1), visit(n2, 0);
}
function* walkHilbert(e4, t2) {
  if (!(e4.level < 1)) {
    switch (e4.tracker.shouldNotify(e4.index) && (yield { progress: e4.tracker.progress }), e4.level--, t2) {
      case 2:
        yield* walkHilbert(e4, 1), visit(e4, 3), yield* walkHilbert(e4, 2), visit(e4, 4), yield* walkHilbert(e4, 2), visit(e4, 2), yield* walkHilbert(e4, 4);
        break;
      case 3:
        yield* walkHilbert(e4, 4), visit(e4, 2), yield* walkHilbert(e4, 3), visit(e4, 1), yield* walkHilbert(e4, 3), visit(e4, 3), yield* walkHilbert(e4, 1);
        break;
      case 1:
        yield* walkHilbert(e4, 2), visit(e4, 4), yield* walkHilbert(e4, 1), visit(e4, 3), yield* walkHilbert(e4, 1), visit(e4, 1), yield* walkHilbert(e4, 3);
        break;
      case 4:
        yield* walkHilbert(e4, 3), visit(e4, 1), yield* walkHilbert(e4, 4), visit(e4, 2), yield* walkHilbert(e4, 4), visit(e4, 4), yield* walkHilbert(e4, 2);
    }
    e4.level++;
  }
}
function visit(e4, t2) {
  switch (e4.x >= 0 && e4.x < e4.width && e4.y >= 0 && e4.y < e4.height && (e4.callback(e4.x, e4.y), e4.index++), t2) {
    case 2:
      e4.x--;
      break;
    case 3:
      e4.x++;
      break;
    case 1:
      e4.y--;
      break;
    case 4:
      e4.y++;
  }
}
var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
  constructor(e4, t2 = 16, i2 = 1) {
    super(), __publicField2(this, "_distance"), __publicField2(this, "_weights"), __publicField2(this, "_errorQueueSize"), this._distance = e4, this._errorQueueSize = t2, this._weights = ErrorDiffusionRiemersma._createWeights(i2, t2);
  }
  *quantize(e4, t2) {
    const i2 = e4.getPointArray(), r2 = e4.getWidth(), n2 = e4.getHeight(), a2 = [];
    let o2 = 0;
    for (let e5 = 0; e5 < this._errorQueueSize; e5++)
      a2[e5] = { r: 0, g: 0, b: 0, a: 0 };
    yield* hilbertCurve(r2, n2, (e5, n3) => {
      const s2 = i2[e5 + n3 * r2];
      let { r: l2, g: u2, b: h2, a: c2 } = s2;
      for (let e6 = 0; e6 < this._errorQueueSize; e6++) {
        const t3 = this._weights[e6], i3 = a2[(e6 + o2) % this._errorQueueSize];
        l2 += i3.r * t3, u2 += i3.g * t3, h2 += i3.b * t3, c2 += i3.a * t3;
      }
      const f2 = Point.createByRGBA(inRange0to255Rounded(l2), inRange0to255Rounded(u2), inRange0to255Rounded(h2), inRange0to255Rounded(c2)), d = t2.getNearestColor(this._distance, f2);
      o2 = (o2 + 1) % this._errorQueueSize;
      const p2 = (o2 + this._errorQueueSize - 1) % this._errorQueueSize;
      a2[p2].r = s2.r - d.r, a2[p2].g = s2.g - d.g, a2[p2].b = s2.b - d.b, a2[p2].a = s2.a - d.a, s2.from(d);
    }), yield { pointContainer: e4, progress: 100 };
  }
  static _createWeights(e4, t2) {
    const i2 = [], r2 = Math.exp(Math.log(t2) / (t2 - 1));
    for (let n2 = 0, a2 = 1; n2 < t2; n2++)
      i2[n2] = (a2 + 0.5 | 0) / t2 * e4, a2 *= r2;
    return i2;
  }
};
var quality_exports = {};
__export2(quality_exports, { ssim: () => ssim });
var K1 = 0.01;
var K2 = 0.03;
function ssim(e4, t2) {
  if (e4.getHeight() !== t2.getHeight() || e4.getWidth() !== t2.getWidth())
    throw new Error("Images have different sizes!");
  const i2 = (255 * K1) ** 2, r2 = (255 * K2) ** 2;
  let n2 = 0, a2 = 0;
  return iterate(e4, t2, (e5, t3, o2, s2) => {
    let l2 = 0, u2 = 0, h2 = 0;
    for (let i3 = 0; i3 < e5.length; i3++)
      u2 += (e5[i3] - o2) ** 2, h2 += (t3[i3] - s2) ** 2, l2 += (e5[i3] - o2) * (t3[i3] - s2);
    const c2 = e5.length - 1;
    u2 /= c2, h2 /= c2, l2 /= c2;
    a2 += (2 * o2 * s2 + i2) * (2 * l2 + r2) / ((o2 ** 2 + s2 ** 2 + i2) * (u2 + h2 + r2)), n2++;
  }), a2 / n2;
}
function iterate(e4, t2, i2) {
  const r2 = e4.getWidth(), n2 = e4.getHeight();
  for (let a2 = 0; a2 < n2; a2 += 8)
    for (let o2 = 0; o2 < r2; o2 += 8) {
      const s2 = Math.min(8, r2 - o2), l2 = Math.min(8, n2 - a2), u2 = calculateLumaValuesForWindow(e4, o2, a2, s2, l2), h2 = calculateLumaValuesForWindow(t2, o2, a2, s2, l2);
      i2(u2, h2, calculateAverageLuma(u2), calculateAverageLuma(h2));
    }
}
function calculateLumaValuesForWindow(e4, t2, i2, r2, n2) {
  const a2 = e4.getPointArray(), o2 = [];
  let s2 = 0;
  for (let l2 = i2; l2 < i2 + n2; l2++) {
    const i3 = l2 * e4.getWidth();
    for (let e5 = t2; e5 < t2 + r2; e5++) {
      const t3 = a2[i3 + e5];
      o2[s2] = 0.2126 * t3.r + 0.7152 * t3.g + 0.0722 * t3.b, s2++;
    }
  }
  return o2;
}
function calculateAverageLuma(e4) {
  let t2 = 0;
  for (const i2 of e4)
    t2 += i2;
  return t2 / e4.length;
}
function buildPaletteSync(e4, { colorDistanceFormula: t2, paletteQuantization: i2, colors: r2 } = {}) {
  const n2 = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(t2), i2, r2);
  return e4.forEach((e5) => n2.sample(e5)), n2.quantizeSync();
}
function applyPaletteSync(e4, t2, { colorDistanceFormula: i2, imageQuantization: r2 } = {}) {
  return imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(i2), r2).quantizeSync(e4, t2);
}
function colorDistanceFormulaToColorDistance(e4 = "euclidean-bt709") {
  switch (e4) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${e4}`);
  }
}
function imageQuantizationToImageQuantizer(e4, t2 = "floyd-steinberg") {
  switch (t2) {
    case "nearest":
      return new NearestColor(e4);
    case "riemersma":
      return new ErrorDiffusionRiemersma(e4);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(e4, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(e4, 1);
    case "stucki":
      return new ErrorDiffusionArray(e4, 2);
    case "atkinson":
      return new ErrorDiffusionArray(e4, 3);
    case "jarvis":
      return new ErrorDiffusionArray(e4, 4);
    case "burkes":
      return new ErrorDiffusionArray(e4, 5);
    case "sierra":
      return new ErrorDiffusionArray(e4, 6);
    case "two-sierra":
      return new ErrorDiffusionArray(e4, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray(e4, 8);
    default:
      throw new Error(`Unknown imageQuantization ${t2}`);
  }
}
function paletteQuantizationToPaletteQuantizer(e4, t2 = "wuquant", i2 = 256) {
  switch (t2) {
    case "neuquant":
      return new NeuQuant(e4, i2);
    case "rgbquant":
      return new RGBQuant(e4, i2);
    case "wuquant":
      return new WuQuant(e4, i2);
    case "neuquant-float":
      return new NeuQuantFloat(e4, i2);
    default:
      throw new Error(`Unknown paletteQuantization ${t2}`);
  }
}
"function" == typeof setImmediate ? setImmediate : "undefined" != typeof process && (null == process || process.nextTick);
var QuantizeOptionsSchema = z.object({ colors: z.number().optional(), colorDistanceFormula: z.union([z.literal("cie94-textiles"), z.literal("cie94-graphic-arts"), z.literal("ciede2000"), z.literal("color-metric"), z.literal("euclidean"), z.literal("euclidean-bt709-noalpha"), z.literal("euclidean-bt709"), z.literal("manhattan"), z.literal("manhattan-bt709"), z.literal("manhattan-nommyde"), z.literal("pngquant")]).optional(), paletteQuantization: z.union([z.literal("neuquant"), z.literal("neuquant-float"), z.literal("rgbquant"), z.literal("wuquant")]).optional(), imageQuantization: z.union([z.literal("nearest"), z.literal("riemersma"), z.literal("floyd-steinberg"), z.literal("false-floyd-steinberg"), z.literal("stucki"), z.literal("atkinson"), z.literal("jarvis"), z.literal("burkes"), z.literal("sierra"), z.literal("two-sierra"), z.literal("sierra-lite")]).optional() });
var methods = { quantize(e4, t2) {
  const { colors: i2, colorDistanceFormula: r2, paletteQuantization: n2, imageQuantization: a2 } = QuantizeOptionsSchema.parse(t2), o2 = utils_exports.PointContainer.fromUint8Array(e4.bitmap.data, e4.bitmap.width, e4.bitmap.height), s2 = applyPaletteSync(o2, buildPaletteSync([o2], { colors: i2, colorDistanceFormula: r2, paletteQuantization: n2 }), { colorDistanceFormula: r2, imageQuantization: a2 });
  return e4.bitmap.data = Buffer2.from(s2.toUint8Array()), e4;
} };
var parseBmfontAscii = function(e4) {
  if (!e4)
    throw new Error("no data provided");
  var t2 = { pages: [], chars: [], kernings: [] }, i2 = (e4 = e4.toString().trim()).split(/\r\n?|\n/g);
  if (0 === i2.length)
    throw new Error("no data in BMFont file");
  for (var r2 = 0; r2 < i2.length; r2++) {
    var n2 = splitLine(i2[r2], r2);
    if (n2)
      if ("page" === n2.key) {
        if ("number" != typeof n2.data.id)
          throw new Error("malformed file at line " + r2 + " -- needs page id=N");
        if ("string" != typeof n2.data.file)
          throw new Error("malformed file at line " + r2 + ' -- needs page file="path"');
        t2.pages[n2.data.id] = n2.data.file;
      } else
        "chars" === n2.key || "kernings" === n2.key || ("char" === n2.key ? t2.chars.push(n2.data) : "kerning" === n2.key ? t2.kernings.push(n2.data) : t2[n2.key] = n2.data);
  }
  return t2;
};
function splitLine(e4, t2) {
  if (!(e4 = e4.replace(/\t+/g, " ").trim()))
    return null;
  var i2 = e4.indexOf(" ");
  if (-1 === i2)
    throw new Error("no named row at line " + t2);
  var r2 = e4.substring(0, i2);
  e4 = (e4 = (e4 = (e4 = e4.substring(i2 + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map(function(e5) {
    return e5.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
  });
  for (var n2 = [], a2 = 0; a2 < e4.length; a2++) {
    var o2 = e4[a2];
    0 === a2 ? n2.push({ key: o2[0], data: "" }) : a2 === e4.length - 1 ? n2[n2.length - 1].data = parseData(o2[0]) : (n2[n2.length - 1].data = parseData(o2[0]), n2.push({ key: o2[1], data: "" }));
  }
  var s2 = { key: r2, data: {} };
  return n2.forEach(function(e5) {
    s2.data[e5.key] = e5.data;
  }), s2;
}
function parseData(e4) {
  return e4 && 0 !== e4.length ? 0 === e4.indexOf('"') || 0 === e4.indexOf("'") ? e4.substring(1, e4.length - 1) : -1 !== e4.indexOf(",") ? parseIntList$1(e4) : parseInt(e4, 10) : "";
}
function parseIntList$1(e4) {
  return e4.split(",").map(function(e5) {
    return parseInt(e5, 10);
  });
}
var parseASCII = getDefaultExportFromCjs(parseBmfontAscii);
var GLYPH_DESIGNER_ERROR = "chasrset";
var parseAttribs = function(e4) {
  for (var t2 in e4 = Object.assign({}, e4), GLYPH_DESIGNER_ERROR in e4 && (e4.charset = e4[GLYPH_DESIGNER_ERROR], delete e4[GLYPH_DESIGNER_ERROR]), e4)
    "face" !== t2 && "charset" !== t2 && (e4[t2] = "padding" === t2 || "spacing" === t2 ? parseIntList(e4[t2]) : parseInt(e4[t2], 10));
  return e4;
};
function parseIntList(e4) {
  return e4.split(",").map(function(e5) {
    return parseInt(e5, 10);
  });
}
var xmlParseFromString = void 0 !== self.DOMParser ? function(e4) {
  return new self.DOMParser().parseFromString(e4, "application/xml");
} : void 0 !== self.ActiveXObject && new self.ActiveXObject("Microsoft.XMLDOM") ? function(e4) {
  var t2 = new self.ActiveXObject("Microsoft.XMLDOM");
  return t2.async = "false", t2.loadXML(e4), t2;
} : function(e4) {
  var t2 = document.createElement("div");
  return t2.innerHTML = e4, t2;
};
var parseAttributes = parseAttribs;
var parseFromString = xmlParseFromString;
var NAME_MAP = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" };
var browser = function(e4) {
  e4 = e4.toString();
  var t2 = parseFromString(e4), i2 = { pages: [], chars: [], kernings: [] };
  ["info", "common"].forEach(function(e5) {
    var r3 = t2.getElementsByTagName(e5)[0];
    r3 && (i2[e5] = parseAttributes(getAttribs(r3)));
  });
  var r2 = t2.getElementsByTagName("pages")[0];
  if (!r2)
    throw new Error("malformed file -- no <pages> element");
  for (var n2 = r2.getElementsByTagName("page"), a2 = 0; a2 < n2.length; a2++) {
    var o2 = n2[a2], s2 = parseInt(o2.getAttribute("id"), 10), l2 = o2.getAttribute("file");
    if (isNaN(s2))
      throw new Error('malformed file -- page "id" attribute is NaN');
    if (!l2)
      throw new Error('malformed file -- needs page "file" attribute');
    i2.pages[parseInt(s2, 10)] = l2;
  }
  return ["chars", "kernings"].forEach(function(e5) {
    var r3 = t2.getElementsByTagName(e5)[0];
    if (r3)
      for (var n3 = e5.substring(0, e5.length - 1), a3 = r3.getElementsByTagName(n3), o3 = 0; o3 < a3.length; o3++) {
        var s3 = a3[o3];
        i2[e5].push(parseAttributes(getAttribs(s3)));
      }
  }), i2;
};
function getAttribs(e4) {
  return getAttribList(e4).reduce(function(e5, t2) {
    return e5[mapName(t2.nodeName)] = t2.nodeValue, e5;
  }, {});
}
function getAttribList(e4) {
  for (var t2 = [], i2 = 0; i2 < e4.attributes.length; i2++)
    t2.push(e4.attributes[i2]);
  return t2;
}
function mapName(e4) {
  return NAME_MAP[e4.toLowerCase()] || e4;
}
var parseXML = getDefaultExportFromCjs(browser);
var HEADER$1 = [66, 77, 70];
var parseBmfontBinary = function(e4) {
  if (e4.length < 6)
    throw new Error("invalid buffer length for BMFont");
  var t2 = HEADER$1.every(function(t3, i3) {
    return e4.readUInt8(i3) === t3;
  });
  if (!t2)
    throw new Error("BMFont missing BMF byte header");
  var i2 = 3;
  if (e4.readUInt8(i2++) > 3)
    throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
  for (var r2 = { kernings: [], chars: [] }, n2 = 0; n2 < 5; n2++)
    i2 += readBlock(r2, e4, i2);
  return r2;
};
function readBlock(e4, t2, i2) {
  if (i2 > t2.length - 1)
    return 0;
  var r2 = t2.readUInt8(i2++), n2 = t2.readInt32LE(i2);
  switch (i2 += 4, r2) {
    case 1:
      e4.info = readInfo(t2, i2);
      break;
    case 2:
      e4.common = readCommon(t2, i2);
      break;
    case 3:
      e4.pages = readPages(t2, i2, n2);
      break;
    case 4:
      e4.chars = readChars(t2, i2, n2);
      break;
    case 5:
      e4.kernings = readKernings(t2, i2, n2);
  }
  return 5 + n2;
}
function readInfo(e4, t2) {
  var i2 = {};
  i2.size = e4.readInt16LE(t2);
  var r2 = e4.readUInt8(t2 + 2);
  return i2.smooth = r2 >> 7 & 1, i2.unicode = r2 >> 6 & 1, i2.italic = r2 >> 5 & 1, i2.bold = r2 >> 4 & 1, r2 >> 3 & 1 && (i2.fixedHeight = 1), i2.charset = e4.readUInt8(t2 + 3) || "", i2.stretchH = e4.readUInt16LE(t2 + 4), i2.aa = e4.readUInt8(t2 + 6), i2.padding = [e4.readInt8(t2 + 7), e4.readInt8(t2 + 8), e4.readInt8(t2 + 9), e4.readInt8(t2 + 10)], i2.spacing = [e4.readInt8(t2 + 11), e4.readInt8(t2 + 12)], i2.outline = e4.readUInt8(t2 + 13), i2.face = readStringNT(e4, t2 + 14), i2;
}
function readCommon(e4, t2) {
  var i2 = {};
  return i2.lineHeight = e4.readUInt16LE(t2), i2.base = e4.readUInt16LE(t2 + 2), i2.scaleW = e4.readUInt16LE(t2 + 4), i2.scaleH = e4.readUInt16LE(t2 + 6), i2.pages = e4.readUInt16LE(t2 + 8), e4.readUInt8(t2 + 10), i2.packed = 0, i2.alphaChnl = e4.readUInt8(t2 + 11), i2.redChnl = e4.readUInt8(t2 + 12), i2.greenChnl = e4.readUInt8(t2 + 13), i2.blueChnl = e4.readUInt8(t2 + 14), i2;
}
function readPages(e4, t2, i2) {
  for (var r2 = [], n2 = readNameNT(e4, t2), a2 = n2.length + 1, o2 = i2 / a2, s2 = 0; s2 < o2; s2++)
    r2[s2] = e4.slice(t2, t2 + n2.length).toString("utf8"), t2 += a2;
  return r2;
}
function readChars(e4, t2, i2) {
  for (var r2 = [], n2 = i2 / 20, a2 = 0; a2 < n2; a2++) {
    var o2 = {}, s2 = 20 * a2;
    o2.id = e4.readUInt32LE(t2 + 0 + s2), o2.x = e4.readUInt16LE(t2 + 4 + s2), o2.y = e4.readUInt16LE(t2 + 6 + s2), o2.width = e4.readUInt16LE(t2 + 8 + s2), o2.height = e4.readUInt16LE(t2 + 10 + s2), o2.xoffset = e4.readInt16LE(t2 + 12 + s2), o2.yoffset = e4.readInt16LE(t2 + 14 + s2), o2.xadvance = e4.readInt16LE(t2 + 16 + s2), o2.page = e4.readUInt8(t2 + 18 + s2), o2.chnl = e4.readUInt8(t2 + 19 + s2), r2[a2] = o2;
  }
  return r2;
}
function readKernings(e4, t2, i2) {
  for (var r2 = [], n2 = i2 / 10, a2 = 0; a2 < n2; a2++) {
    var o2 = {}, s2 = 10 * a2;
    o2.first = e4.readUInt32LE(t2 + 0 + s2), o2.second = e4.readUInt32LE(t2 + 4 + s2), o2.amount = e4.readInt16LE(t2 + 8 + s2), r2[a2] = o2;
  }
  return r2;
}
function readNameNT(e4, t2) {
  for (var i2 = t2; i2 < e4.length && 0 !== e4[i2]; i2++)
    ;
  return e4.slice(t2, i2);
}
function readStringNT(e4, t2) {
  return readNameNT(e4, t2).toString("utf8");
}
var readBinary = getDefaultExportFromCjs(parseBmfontBinary);
function normalizeArray(e4, t2) {
  for (var i2 = 0, r2 = e4.length - 1; r2 >= 0; r2--) {
    var n2 = e4[r2];
    "." === n2 ? e4.splice(r2, 1) : ".." === n2 ? (e4.splice(r2, 1), i2++) : i2 && (e4.splice(r2, 1), i2--);
  }
  if (t2)
    for (; i2--; i2)
      e4.unshift("..");
  return e4;
}
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(e4) {
  return splitPathRe.exec(e4).slice(1);
};
function resolve2() {
  for (var e4 = "", t2 = false, i2 = arguments.length - 1; i2 >= -1 && !t2; i2--) {
    var r2 = i2 >= 0 ? arguments[i2] : "/";
    if ("string" != typeof r2)
      throw new TypeError("Arguments to path.resolve must be strings");
    r2 && (e4 = r2 + "/" + e4, t2 = "/" === r2.charAt(0));
  }
  return e4 = normalizeArray(filter(e4.split("/"), function(e5) {
    return !!e5;
  }), !t2).join("/"), (t2 ? "/" : "") + e4 || ".";
}
function normalize(e4) {
  var t2 = isAbsolute(e4), i2 = "/" === substr(e4, -1);
  return e4 = normalizeArray(filter(e4.split("/"), function(e5) {
    return !!e5;
  }), !t2).join("/"), e4 || t2 || (e4 = "."), e4 && i2 && (e4 += "/"), (t2 ? "/" : "") + e4;
}
function isAbsolute(e4) {
  return "/" === e4.charAt(0);
}
function join() {
  return normalize(filter(Array.prototype.slice.call(arguments, 0), function(e4, t2) {
    if ("string" != typeof e4)
      throw new TypeError("Arguments to path.join must be strings");
    return e4;
  }).join("/"));
}
function relative(e4, t2) {
  function i2(e5) {
    for (var t3 = 0; t3 < e5.length && "" === e5[t3]; t3++)
      ;
    for (var i3 = e5.length - 1; i3 >= 0 && "" === e5[i3]; i3--)
      ;
    return t3 > i3 ? [] : e5.slice(t3, i3 - t3 + 1);
  }
  e4 = resolve2(e4).substr(1), t2 = resolve2(t2).substr(1);
  for (var r2 = i2(e4.split("/")), n2 = i2(t2.split("/")), a2 = Math.min(r2.length, n2.length), o2 = a2, s2 = 0; s2 < a2; s2++)
    if (r2[s2] !== n2[s2]) {
      o2 = s2;
      break;
    }
  var l2 = [];
  for (s2 = o2; s2 < r2.length; s2++)
    l2.push("..");
  return (l2 = l2.concat(n2.slice(o2))).join("/");
}
var sep = "/";
var delimiter = ":";
function dirname(e4) {
  var t2 = splitPath(e4), i2 = t2[0], r2 = t2[1];
  return i2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), i2 + r2) : ".";
}
function basename(e4, t2) {
  var i2 = splitPath(e4)[2];
  return t2 && i2.substr(-1 * t2.length) === t2 && (i2 = i2.substr(0, i2.length - t2.length)), i2;
}
function extname(e4) {
  return splitPath(e4)[3];
}
var path = { extname, basename, dirname, sep, delimiter, relative, join, isAbsolute, normalize, resolve: resolve2 };
function filter(e4, t2) {
  if (e4.filter)
    return e4.filter(t2);
  for (var i2 = [], r2 = 0; r2 < e4.length; r2++)
    t2(e4[r2], r2, e4) && i2.push(e4[r2]);
  return i2;
}
var substr = "b" === "ab".substr(-1) ? function(e4, t2, i2) {
  return e4.substr(t2, i2);
} : function(e4, t2, i2) {
  return t2 < 0 && (t2 = e4.length + t2), e4.substr(t2, i2);
};
function e3(e4) {
  return e4 && e4.__esModule && Object.prototype.hasOwnProperty.call(e4, "default") ? e4.default : e4;
}
var t = (e4) => {
  if (!e4)
    return null;
  const i2 = {};
  switch (e4.type) {
    case "ELEMENT": {
      let n2 = {};
      const a2 = E(e4.value.attributes), o2 = t(e4.value.children);
      if (a2 && (n2 = Object.assign(n2, a2)), o2) {
        const t2 = r(e4.value.children);
        n2 = Object.assign(n2, t2);
      }
      i2[e4.value.type] = n2;
      break;
    }
    case "ATTRIBUTE": {
      const t2 = e4.value;
      i2[t2.name] = t2.value;
      break;
    }
    case "CONTENT":
      return { content: e4.value };
  }
  return i2;
};
var r = (e4) => e4 && Array.isArray(e4) && 0 !== e4.length ? n(e4) ? { content: e4[0].value } : { children: e4.map(t) } : null;
var n = (e4) => e4 && Array.isArray(e4) && 1 === e4.length && "CONTENT" === e4[0].type;
var E = (e4) => e4 && Array.isArray(e4) ? e4.map(t).reduce((e5, t2) => Object.assign(e5, t2), {}) : null;
var s = { convert: (e4) => t(e4.value.children[0]) };
var a = { Token: (e4, t2) => ({ type: e4, value: t2 }), TOKEN_TYPE: { OPEN_BRACKET: "OPEN_BRACKET", ELEMENT_TYPE: "ELEMENT_TYPE", CLOSE_ELEMENT: "CLOSE_ELEMENT", ATTRIB_NAME: "ATTRIB_NAME", ATTRIB_VALUE: "ATTRIB_VALUE", ASSIGN: "ASSIGN", CLOSE_BRACKET: "CLOSE_BRACKET", CONTENT: "CONTENT", EOF: "EOF" } };
var { Token: T, TOKEN_TYPE: u } = a;
var c = T("EOF");
var l = (e4) => " " === e4 || "\n" === e4 || "\r" === e4 || "	" === e4;
var o = (e4) => e4.replace(/'/g, '"');
var N = { createLexer: function(e4) {
  let t2 = null, i2 = ((e5) => {
    let t3 = 0;
    for (; t3 < e5.length && l(e5[t3]); )
      t3++;
    return ((e6, t4) => {
      if (e6.startsWith("<?xml", t4)) {
        const i3 = e6.length;
        for (; t4 < i3; )
          if ("?" !== e6[t4])
            t4++;
          else {
            if (">" === e6[t4 + 1])
              return t4 + 2;
            t4++;
          }
      }
      return t4;
    })(e5, t3);
  })(e4), r2 = [];
  const n2 = () => e4[i2], a2 = () => t2 !== c && i2 < e4.length, s2 = (e5) => '"' === e5 || "'" === e5, h2 = () => {
    for (; a2() && l(e4[i2]); )
      i2++;
  }, f2 = (t3) => {
    if (a2()) {
      if ("<" === e4[i2]) {
        let t4 = "<";
        return i2++, a2() && "/" === e4[i2] ? (i2++, t4 = "</") : a2() && "!" === e4[i2] && "-" === e4[i2 + 1] && "-" === e4[i2 + 2] && (i2++, i2++, i2++, t4 = "<!--"), t4;
      }
      if ("/" === n2()) {
        let e5 = "/";
        return i2++, a2() && ">" === n2() && (i2++, e5 = "/>"), e5;
      }
      if ("=" === e4[i2] || ">" === e4[i2]) {
        const t4 = e4[i2];
        return i2++, t4;
      }
    }
    return d(!!t3);
  }, d = (t3) => {
    const r3 = t3 ? /[^>=<]/u : /[a-zA-Z0-9_:-]/;
    let n3 = i2;
    for (; a2() && e4[i2].match(r3); )
      i2++;
    return o(e4.substring(n3, i2));
  }, p2 = () => {
    const l2 = i2;
    h2();
    const m = i2 - l2;
    if (a2())
      if (t2 && t2.type === u.OPEN_BRACKET) {
        h2();
        const e5 = f2(false);
        t2 = T(u.ELEMENT_TYPE, e5), r2.push(e5);
      } else if (t2 && t2.type === u.ASSIGN) {
        a2() && s2(n2()) && i2++;
        let r3 = i2;
        for (; a2() && !s2(n2()); )
          i2++;
        const l3 = o(e4.substring(r3, i2));
        i2++, t2 = T(u.ATTRIB_VALUE, l3);
      } else {
        h2();
        let o2 = f2(true);
        switch (o2) {
          case "=":
            t2 = t2.type === u.ATTRIB_NAME ? T(u.ASSIGN) : T(u.CONTENT, o2);
            break;
          case "</": {
            const n3 = i2;
            for (; ">" !== e4[i2]; )
              i2++;
            t2 = T(u.CLOSE_ELEMENT, e4.substring(n3, i2)), i2++, r2.pop();
            break;
          }
          case "/>": {
            const e5 = r2.pop();
            t2 = T(u.CLOSE_ELEMENT, e5);
            break;
          }
          case "<!--": {
            const t3 = ["!", "-", "-"];
            for (; a2() && (">" !== t3[2] || "-" !== t3[1] || "-" !== t3[0]); )
              t3.shift(), t3.push(e4[i2]), i2++;
            return p2();
          }
          case ">":
            t2 = T(u.CLOSE_BRACKET);
            break;
          case "<":
            t2 = T(u.OPEN_BRACKET);
            break;
          default:
            if (o2 && o2.length > 0) {
              if (t2.type === u.CLOSE_BRACKET) {
                let e5 = "";
                "<" !== n2() && (e5 = d(true)), t2 = T(u.CONTENT, o2 + e5);
              } else if (t2.type !== u.ATTRIB_NAME && t2.type !== u.CONTENT)
                t2.type === u.CLOSE_ELEMENT ? (o2 = " ".repeat(m) + o2, t2 = T(u.CONTENT, o2)) : t2 = T(u.ATTRIB_NAME, o2);
              else {
                const e5 = " ".repeat(m) + o2;
                t2 = T(u.CONTENT, e5);
              }
              break;
            }
            {
              const t3 = 'Unknown Syntax : "' + e4[i2] + '"';
              throw new Error(t3);
            }
        }
      }
    else
      t2 = c;
    return t2;
  };
  return { peek: n2, next: p2, hasNext: a2 };
} };
var { createLexer: i } = N;
var { Token: p, TOKEN_TYPE: O } = a;
var [A, f, C, h] = ["ROOT", "ELEMENT", "ATTRIBUTE", "CONTENT"];
var _ = (e4, t2) => ({ type: e4, value: t2 });
var L = (e4) => _(h, e4);
var y = (e4, t2, i2) => _(f, { type: e4, attributes: t2, children: i2 });
var v = (e4, t2) => _(C, { name: e4, value: t2 });
var S = (e4, t2) => {
  const i2 = [];
  for (; e4.hasNext(); ) {
    const r2 = e4.next();
    switch (r2.type) {
      case O.OPEN_BRACKET: {
        const t3 = e4.next(), [r3, n2] = R(e4);
        let a2 = [];
        n2.type !== O.CLOSE_ELEMENT && (a2 = S(e4, t3)), a2 && a2.length > 0 && a2[0].type === O.CONTENT && (a2 = b(a2)), i2.push(y(t3.value, r3, a2));
        break;
      }
      case O.CLOSE_ELEMENT:
        if (r2.value === t2.value)
          return i2;
        break;
      case O.CONTENT:
        i2.push(L(r2.value));
        break;
      case O.EOF:
        return i2;
      default:
        throw new Error(`Unknown Lexem type: ${r2.type} "${r2.value}, scoping element: ${t2.value}"`);
    }
  }
  return i2;
};
var R = (e4) => {
  const t2 = [];
  let i2 = e4.peek();
  if (!e4.hasNext() || i2 && i2.type === O.CLOSE_BRACKET || i2 && i2.type === O.CLOSE_ELEMENT)
    return [t2, i2];
  for (i2 = e4.next(); e4.hasNext() && i2 && i2.type !== O.CLOSE_BRACKET && i2.type !== O.CLOSE_ELEMENT; ) {
    const r2 = i2;
    e4.next();
    const n2 = e4.next(), a2 = v(r2.value, n2.value);
    t2.push(a2), i2 = e4.next();
  }
  return [t2, i2];
};
function b(e4) {
  let t2 = [], i2 = "";
  return e4.forEach((e5) => {
    e5.type === O.CONTENT ? i2 += e5.value : (i2.length && (t2.push(L(i2)), i2 = ""), t2.push(e5));
  }), i2.length && t2.push(L(i2)), t2;
}
var B = { transpile: function(e4, t2) {
  const r2 = ((e5) => _(A, { children: S(e5, p(A, "ROOT")) }))(i(e4));
  return t2 ? t2.convert(r2) : r2;
}, Node: _, ElementNode: y, AttribNode: v };
var M = s;
var { transpile: x } = B;
var k = e3({ convertXML: function(e4, t2) {
  return x(e4, t2 || M);
}, createAST: function(e4) {
  return x(e4);
} });
var simpleXmlToJson_min = k;
var xmlPackage = getDefaultExportFromCjs(simpleXmlToJson_min);
var { convertXML } = xmlPackage;
var isWebWorker = "undefined" != typeof self && void 0 === self.document;
var CharacterJimp = createJimp({ formats: [png] });
var HEADER = Buffer2.from([66, 77, 70, 3]);
function isBinary(e4) {
  if ("string" == typeof e4)
    return "BMF" === e4.substring(0, 3);
  const t2 = e4.slice(0, 4);
  return e4.length > 4 && t2[0] === HEADER[0] && t2[1] === HEADER[1] && t2[2] === HEADER[2];
}
function parseFont(e4, t2) {
  return isBinary(t2) ? ("string" == typeof t2 && (t2 = Buffer2.from(t2, "binary")), readBinary(t2)) : (t2 = t2.toString().trim(), /.json$/.test(e4) || "{" === t2.charAt(0) ? JSON.parse(t2) : /.xml$/.test(e4) || "<" === t2.charAt(0) ? parseXML(t2) : parseASCII(t2));
}
function parseNumbersInObject(e4) {
  for (const t2 in e4) {
    try {
      e4[t2] = parseInt(e4[t2], 10);
    } catch (e5) {
    }
    "object" == typeof e4[t2] && parseNumbersInObject(e4[t2]);
  }
  return e4;
}
async function loadBitmapFontData(e4) {
  if (isWebWorker && "string" == typeof e4) {
    const t2 = await fetch(e4), i2 = await t2.text(), r2 = convertXML(i2).font.children.reduce((e5, t3) => ({ ...e5, ...t3 }), {}), n2 = [], a2 = [], o2 = [];
    for (let e5 = 0; e5 < r2.pages.children.length; e5++) {
      const t3 = r2.pages.children[e5].page;
      n2[parseInt(t3.id, 10)] = parseNumbersInObject(t3.file);
    }
    for (let e5 = 0; e5 < r2.chars.children.length; e5++)
      a2.push(parseNumbersInObject(r2.chars.children[e5].char));
    for (let e5 = 0; e5 < r2.kernings.children.length; e5++)
      o2.push(parseNumbersInObject(r2.kernings.children[e5].kerning));
    return { info: r2.info, common: r2.common, pages: n2, chars: a2, kernings: o2 };
  }
  if ("string" == typeof e4) {
    const t2 = await fetch(e4);
    return parseFont(e4, await t2.text());
  }
  return parseFont("", e4);
}
async function processBitmapFont(e4, t2) {
  const i2 = {}, r2 = {};
  for (let e5 = 0; e5 < t2.chars.length; e5++) {
    const r3 = t2.chars[e5];
    i2[String.fromCharCode(r3.id)] = r3;
  }
  for (let e5 = 0; e5 < t2.kernings.length; e5++) {
    const i3 = String.fromCharCode(t2.kernings[e5].first);
    r2[i3] = r2[i3] || {}, r2[i3][String.fromCharCode(t2.kernings[e5].second)] = t2.kernings[e5].amount;
  }
  return { ...t2, chars: i2, kernings: r2, pages: await Promise.all(t2.pages.map(async (t3) => CharacterJimp.read(path.join(path.dirname(e4), t3)))) };
}
async function loadFont(e4) {
  let t2 = e4;
  if ("undefined" == typeof window && !isWebWorker) {
    const { existsSync: i2, promises: r2 } = await Promise.resolve().then(function() {
      return _polyfillNode_fs$1;
    });
    i2(e4) && (t2 = await r2.readFile(e4));
  }
  return processBitmapFont(e4, await loadBitmapFontData(t2));
}
var pixelmatch_1 = pixelmatch;
var defaultOptions = { threshold: 0.1, includeAA: false, alpha: 0.1, aaColor: [255, 255, 0], diffColor: [255, 0, 0], diffColorAlt: null, diffMask: false };
function pixelmatch(e4, t2, i2, r2, n2, a2) {
  if (!isPixelData(e4) || !isPixelData(t2) || i2 && !isPixelData(i2))
    throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
  if (e4.length !== t2.length || i2 && i2.length !== e4.length)
    throw new Error("Image sizes do not match.");
  if (e4.length !== r2 * n2 * 4)
    throw new Error("Image data size does not match width/height.");
  a2 = Object.assign({}, defaultOptions, a2);
  const o2 = r2 * n2, s2 = new Uint32Array(e4.buffer, e4.byteOffset, o2), l2 = new Uint32Array(t2.buffer, t2.byteOffset, o2);
  let u2 = true;
  for (let e5 = 0; e5 < o2; e5++)
    if (s2[e5] !== l2[e5]) {
      u2 = false;
      break;
    }
  if (u2) {
    if (i2 && !a2.diffMask)
      for (let t3 = 0; t3 < o2; t3++)
        drawGrayPixel(e4, 4 * t3, a2.alpha, i2);
    return 0;
  }
  const h2 = 35215 * a2.threshold * a2.threshold;
  let c2 = 0;
  for (let o3 = 0; o3 < n2; o3++)
    for (let s3 = 0; s3 < r2; s3++) {
      const l3 = 4 * (o3 * r2 + s3), u3 = colorDelta(e4, t2, l3, l3);
      Math.abs(u3) > h2 ? a2.includeAA || !antialiased(e4, s3, o3, r2, n2, t2) && !antialiased(t2, s3, o3, r2, n2, e4) ? (i2 && drawPixel(i2, l3, ...u3 < 0 && a2.diffColorAlt || a2.diffColor), c2++) : i2 && !a2.diffMask && drawPixel(i2, l3, ...a2.aaColor) : i2 && (a2.diffMask || drawGrayPixel(e4, l3, a2.alpha, i2));
    }
  return c2;
}
function isPixelData(e4) {
  return ArrayBuffer.isView(e4) && 1 === e4.constructor.BYTES_PER_ELEMENT;
}
function antialiased(e4, t2, i2, r2, n2, a2) {
  const o2 = Math.max(t2 - 1, 0), s2 = Math.max(i2 - 1, 0), l2 = Math.min(t2 + 1, r2 - 1), u2 = Math.min(i2 + 1, n2 - 1), h2 = 4 * (i2 * r2 + t2);
  let c2, f2, d, p2, m = t2 === o2 || t2 === l2 || i2 === s2 || i2 === u2 ? 1 : 0, _2 = 0, g = 0;
  for (let n3 = o2; n3 <= l2; n3++)
    for (let a3 = s2; a3 <= u2; a3++) {
      if (n3 === t2 && a3 === i2)
        continue;
      const o3 = colorDelta(e4, e4, h2, 4 * (a3 * r2 + n3), true);
      if (0 === o3) {
        if (m++, m > 2)
          return false;
      } else
        o3 < _2 ? (_2 = o3, c2 = n3, f2 = a3) : o3 > g && (g = o3, d = n3, p2 = a3);
    }
  return 0 !== _2 && 0 !== g && (hasManySiblings(e4, c2, f2, r2, n2) && hasManySiblings(a2, c2, f2, r2, n2) || hasManySiblings(e4, d, p2, r2, n2) && hasManySiblings(a2, d, p2, r2, n2));
}
function hasManySiblings(e4, t2, i2, r2, n2) {
  const a2 = Math.max(t2 - 1, 0), o2 = Math.max(i2 - 1, 0), s2 = Math.min(t2 + 1, r2 - 1), l2 = Math.min(i2 + 1, n2 - 1), u2 = 4 * (i2 * r2 + t2);
  let h2 = t2 === a2 || t2 === s2 || i2 === o2 || i2 === l2 ? 1 : 0;
  for (let n3 = a2; n3 <= s2; n3++)
    for (let a3 = o2; a3 <= l2; a3++) {
      if (n3 === t2 && a3 === i2)
        continue;
      const o3 = 4 * (a3 * r2 + n3);
      if (e4[u2] === e4[o3] && e4[u2 + 1] === e4[o3 + 1] && e4[u2 + 2] === e4[o3 + 2] && e4[u2 + 3] === e4[o3 + 3] && h2++, h2 > 2)
        return true;
    }
  return false;
}
function colorDelta(e4, t2, i2, r2, n2) {
  let a2 = e4[i2 + 0], o2 = e4[i2 + 1], s2 = e4[i2 + 2], l2 = e4[i2 + 3], u2 = t2[r2 + 0], h2 = t2[r2 + 1], c2 = t2[r2 + 2], f2 = t2[r2 + 3];
  if (l2 === f2 && a2 === u2 && o2 === h2 && s2 === c2)
    return 0;
  l2 < 255 && (l2 /= 255, a2 = blend(a2, l2), o2 = blend(o2, l2), s2 = blend(s2, l2)), f2 < 255 && (f2 /= 255, u2 = blend(u2, f2), h2 = blend(h2, f2), c2 = blend(c2, f2));
  const d = rgb2y(a2, o2, s2), p2 = rgb2y(u2, h2, c2), m = d - p2;
  if (n2)
    return m;
  const _2 = rgb2i(a2, o2, s2) - rgb2i(u2, h2, c2), g = rgb2q(a2, o2, s2) - rgb2q(u2, h2, c2), b2 = 0.5053 * m * m + 0.299 * _2 * _2 + 0.1957 * g * g;
  return d > p2 ? -b2 : b2;
}
function rgb2y(e4, t2, i2) {
  return 0.29889531 * e4 + 0.58662247 * t2 + 0.11448223 * i2;
}
function rgb2i(e4, t2, i2) {
  return 0.59597799 * e4 - 0.2741761 * t2 - 0.32180189 * i2;
}
function rgb2q(e4, t2, i2) {
  return 0.21147017 * e4 - 0.52261711 * t2 + 0.31114694 * i2;
}
function blend(e4, t2) {
  return 255 + (e4 - 255) * t2;
}
function drawPixel(e4, t2, i2, r2, n2) {
  e4[t2 + 0] = i2, e4[t2 + 1] = r2, e4[t2 + 2] = n2, e4[t2 + 3] = 255;
}
function drawGrayPixel(e4, t2, i2, r2) {
  const n2 = blend(rgb2y(e4[t2 + 0], e4[t2 + 1], e4[t2 + 2]), i2 * e4[t2 + 3] / 255);
  drawPixel(r2, t2, n2, n2, n2);
}
var pixelMatch = getDefaultExportFromCjs(pixelmatch_1);
function diff(e4, t2, i2 = 0.1) {
  let r2 = e4.bitmap, n2 = t2.bitmap;
  if (r2.width === n2.width && r2.height === n2.height || (r2.width * r2.height > n2.width * n2.height ? r2 = methods$d.resize(clone(e4), { w: n2.width, h: n2.height }).bitmap : n2 = methods$d.resize(clone(t2), { w: r2.width, h: r2.height }).bitmap), "number" != typeof i2 || i2 < 0 || i2 > 1)
    throw new Error("threshold must be a number between 0 and 1");
  const a2 = new e4.constructor({ width: r2.width, height: r2.height, color: 4294967295 });
  return { percent: pixelMatch(r2.data, n2.data, a2.bitmap.data, a2.bitmap.width, a2.bitmap.height, { threshold: i2 }) / (a2.bitmap.width * a2.bitmap.height), image: a2 };
}
var defaultPlugins = [methods$h, methods$g, methods$f, methods$e, methods$c, methods$a, methods$b, methods$9, methods$8, methods$7, methods$6, methods$5, methods$4, methods$3, methods$d, methods$2, methods$1, methods];
var defaultFormats = [bmp, msBmp, gif, jpeg$2, png, tiff];
var JimpMime = { bmp: bmp().mime, gif: gif().mime, jpeg: jpeg$2().mime, png: png().mime, tiff: tiff().mime };
var Jimp = createJimp({ formats: defaultFormats, plugins: defaultPlugins });

// main.ts
var CopyImagePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.touchTime = 0;
  }
  async onload() {
    if (import_obsidian.Platform.isMobile) {
      this.registerDomEvent(
        document,
        "touchstart",
        this.handleTouchStart.bind(this)
      );
      this.registerDomEvent(
        document,
        "touchmove",
        this.handleTouchMove.bind(this)
      );
    } else {
      this.registerDomEvent(
        document,
        "contextmenu",
        this.handleContextMenu.bind(this)
      );
    }
    this.addCommand({
      id: "copy-image",
      name: "Copy image to clipboard",
      editorCallback: this.handleCommand.bind(this)
    });
  }
  onunload() {
  }
  async handleCommand(editor, view) {
    const line = editor.getLine(editor.getCursor().line);
    if (!line.includes("![[")) {
      new import_obsidian.Notice("Not an image file or not supported...");
      return;
    }
    let fileNane = line.replace(/.*!\[\[(.*?)\]\].*/, "$1");
    if (fileNane === "") {
      new import_obsidian.Notice("Not an image file or not supported...");
      return;
    }
    if (fileNane.includes("|")) {
      fileNane = fileNane.split("|")[0];
    }
    const ext = fileNane.split(".").pop();
    if (!ext) {
      new import_obsidian.Notice("Not an image file or not supported...");
      return;
    }
    if (!["bmp", "gif", "jpeg", "jpg", "png", "tiff"].includes(ext)) {
      new import_obsidian.Notice("Not an image file or not supported...");
      return;
    }
    this.app.vault.getFiles().forEach(async (file) => {
      if (file.name === fileNane) {
        new import_obsidian.Notice("Copying the image...");
        const url = this.app.vault.adapter.getResourcePath(file.path);
        const response = await fetch(url);
        const imageBlob = await response.blob();
        if (imageBlob.type === "image/png") {
          await this.copyPngToClipboard(imageBlob);
        } else {
          await this.copyNonPngToClipboard(imageBlob);
        }
      }
    });
  }
  async handleTouchStart(evt) {
    if (this.isImage(evt)) {
      this.touchTime = new Date().getTime();
      setTimeout(async () => {
        if (this.touchTime !== 0) {
          new import_obsidian.Notice("Copying the image...");
          await this.copyImageToClipboard(evt);
        }
      }, 1e3);
    }
  }
  async handleTouchMove(evt) {
    if (this.isImage(evt)) {
      this.touchTime = 0;
    }
  }
  async handleContextMenu(evt) {
    if (this.isImage(evt)) {
      try {
        new import_obsidian.Notice("Copying the image...");
        await this.trySetFocus();
        await this.waitForFocus();
        await this.copyImageToClipboard(evt);
      } catch (e4) {
        new import_obsidian.Notice(e4.message);
      }
    }
  }
  async wait(ms) {
    return new Promise((resolve3) => setTimeout(resolve3, ms));
  }
  isImage(evt) {
    return evt.target instanceof HTMLImageElement && evt.target.tagName === "IMG";
  }
  async trySetFocus() {
    if (!document.hasFocus()) {
      const obsidianWindow = window.open("obsidian://open", "_self");
      if (obsidianWindow) {
        obsidianWindow.focus();
      } else {
        throw new Error("Failed to focus Obsidian app.");
      }
    }
  }
  async waitForFocus() {
    let timeElapsed = 0;
    while (!document.hasFocus() && timeElapsed < 2e3) {
      await this.wait(50);
      timeElapsed += 50;
    }
    if (!document.hasFocus()) {
      throw new Error(
        "Cannot copy image to clipboard without Obsidian app focused."
      );
    }
  }
  async copyImageToClipboard(evt) {
    const target = evt.target;
    const response = await fetch(target.src);
    const imageBlob = await response.blob();
    if (imageBlob.type === "image/png") {
      await this.copyPngToClipboard(imageBlob);
    } else {
      await this.copyNonPngToClipboard(imageBlob);
    }
  }
  async copyPngToClipboard(imageBlob) {
    try {
      await navigator.clipboard.write([
        new ClipboardItem({
          [imageBlob.type]: imageBlob
        })
      ]);
      new import_obsidian.Notice("Image copied to clipboard!");
    } catch (error) {
      new import_obsidian.Notice("Failed to copy...");
    }
  }
  async copyNonPngToClipboard(imageBlob) {
    const image = await Jimp.read(URL.createObjectURL(imageBlob));
    const buffer = await image.getBuffer("image/png");
    const blob = new Blob([buffer], { type: "image/png" });
    this.copyPngToClipboard(blob);
  }
};
/*! Bundled license information:

jimp/dist/browser/index.js:
  (*!
  	 * The buffer module from node.js, for the browser.
  	 *
  	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
  	 * @license  MIT
  	 *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cie94.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ciede2000.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cmetric.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * common.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * constants.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ditherErrorDiffusionArray.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * euclidean.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * helper.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * hueStatistics.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * iq.ts - Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * manhattanNeuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * nearestColor.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * palette.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pngQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * point.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pointContainer.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2hsl.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ssim.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * wuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * MIT License
   *
   * Copyright 2015-2018 Igor Bezkrovnyi
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * riemersma.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * colorHistogram.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * neuquant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgbquant.ts - part of Image Quantization Library
   *)
*/

/* nosourcemap */