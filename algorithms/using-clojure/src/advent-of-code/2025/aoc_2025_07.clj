(ns aoc-2025-07
  (:require [clojure.string :as str]
            [clojure.pprint :as pp]
            [clojure.java.io :as io]
            [criterium.core :refer [bench quick-bench]]))


;; You quickly locate a diagram of the tachyon manifold (your puzzle input). A tachyon beam enters the manifold at the location marked S; tachyon beams always move downward. Tachyon beams pass freely through empty space (.). However, if a tachyon beam encounters a splitter (^), the beam is stopped; instead, a new tachyon beam continues from the immediate left and from the immediate right of the splitter.

;; For example:

;; .......S.......
;; ...............
;; .......^.......
;; ...............
;; ......^.^......
;; ...............
;; .....^.^.^.....
;; ...............
;; ....^.^...^....
;; ...............
;; ...^.^...^.^...
;; ...............
;; ..^...^.....^..
;; ...............
;; .^.^.^.^.^...^.
;; ...............
;; In this example, the incoming tachyon beam (|) extends downward from S until it reaches the first splitter:

;; .......S.......
;; .......|.......
;; .......^.......
;; ...............
;; ......^.^......
;; ...............
;; .....^.^.^.....
;; ...............
;; ....^.^...^....
;; ...............
;; ...^.^...^.^...
;; ...............
;; ..^...^.....^..
;; ...............
;; .^.^.^.^.^...^.
;; ...............
;; At that point, the original beam stops, and two new beams are emitted from the splitter:

;; .......S.......
;; .......|.......
;; ......|^|......
;; ...............
;; ......^.^......
;; ...............
;; .....^.^.^.....
;; ...............
;; ....^.^...^....
;; ...............
;; ...^.^...^.^...
;; ...............
;; ..^...^.....^..
;; ...............
;; .^.^.^.^.^...^.
;; ...............
;; Those beams continue downward until they reach more splitters:

;; .......S.......
;; .......|.......
;; ......|^|......
;; ......|.|......
;; ......^.^......
;; ...............
;; .....^.^.^.....
;; ...............
;; ....^.^...^....
;; ...............
;; ...^.^...^.^...
;; ...............
;; ..^...^.....^..
;; ...............
;; .^.^.^.^.^...^.
;; ...............
;; At this point, the two splitters create a total of only three tachyon beams, since they are both dumping tachyons into the same place between them:

;; .......S.......
;; .......|.......
;; ......|^|......
;; ......|.|......
;; .....|^|^|.....
;; ...............
;; .....^.^.^.....
;; ...............
;; ....^.^...^....
;; ...............
;; ...^.^...^.^...
;; ...............
;; ..^...^.....^..
;; ...............
;; .^.^.^.^.^...^.
;; ...............
;; This process continues until all of the tachyon beams reach a splitter or exit the manifold:

;; .......S.......
;; .......|.......
;; ......|^|......
;; ......|.|......
;; .....|^|^|.....
;; .....|.|.|.....
;; ....|^|^|^|....
;; ....|.|.|.|....
;; ...|^|^|||^|...
;; ...|.|.|||.|...
;; ..|^|^|||^|^|..
;; ..|.|.|||.|.|..
;; .|^|||^||.||^|.
;; .|.|||.||.||.|.
;; |^|^|^|^|^|||^|
;; |.|.|.|.|.|||.|
;; To repair the teleporter, you first need to understand the beam-splitting properties of the tachyon manifold. In this example, a tachyon beam is split a total of 21 times.


;; (apply-beams [7] [7])
(defn apply-beams [beam-idxs splitter-idxs]
  (loop [beams beam-idxs
         splitters splitter-idxs
         new-beams []
         count 0]
    (let [beam (first beams)
          splitter (first splitters)]
      (cond
        (nil? beam)
        [(vec (sort (set new-beams))) count]

        (= beam splitter)
        (recur (rest beams)
               (rest splitters)
               (conj new-beams (dec splitter) (inc splitter))
               (inc count))

        (< splitter beam)
        (recur beams (rest splitters) new-beams count)

        :else
        ;; beam passes through without splitting
        (recur (rest beams) splitters (conj new-beams (first beams)) count)))))


;; (solve [7] [[7]])
(defn solve
  [beam-idxs splitter-idxs]
   (loop [beams beam-idxs
          splitters splitter-idxs
          count 0]
     (let [first-splitters (first splitters)]
     (cond
       (empty? first-splitters) count
       :else (recur (first (apply-beams beams first-splitters))
                    (rest splitters)
                    (+ count (second (apply-beams beams first-splitters))))))))


(defn indexes-of
  "returns the indexes at which char appears in chars"
  [chars char]
  (loop [cs chars
         idx 0
         idxs []]
    (let [curr (first cs)]
      (cond
        (empty? cs)   idxs
        (= curr char) (recur (rest cs) (inc idx) (conj idxs idx))
        :else         (recur (rest cs)  (inc idx) idxs)))))


(defn parse-input [input]
  (->> input
       str/split-lines
       (#(map (fn [line] (indexes-of (seq line) \^)) %))
       (#(filter (complement empty?) %))))


(->> "aoc_2025_07.input"
     io/resource
     slurp
     parse-input
     (solve [70]))
